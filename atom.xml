<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏日 の blog</title>
  
  
  <link href="https://zss192.github.io/atom.xml" rel="self"/>
  
  <link href="https://zss192.github.io/"/>
  <updated>2022-11-14T09:36:00.000Z</updated>
  <id>https://zss192.github.io/</id>
  
  <author>
    <name>夏日</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统期末总结</title>
    <link href="https://zss192.github.io/2022/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zss192.github.io/2022/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-11-14T09:36:00.000Z</published>
    <updated>2022-11-14T09:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>作者：夏日</p><p>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><p>思维导图快速复习见我这篇博客：<a href="https://blog.csdn.net/zss192/article/details/112388383">操作系统思维导图总结</a></p><p>本文结合天勤考研的高分笔记和王道考研的PPT进行总结</p><p>所用到的资料：<a href="https://pan.baidu.com/s/1gl936J5fLHBAAndMLGYbsg">传送门</a>  密码: j6md</p><h1>绪论</h1><h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><p>1.操作系统(Operating System即OS)：指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口的环境。它是计算机系统中的最基本的<strong>系统软件</strong>。</p><p>2.操作系统的特征</p><ul><li>并发性(最基本的特征)<ul><li>并发：交替发生(宏观同时发生微观交替发生)；并行：同时进行</li></ul></li><li>共享性(最基本的特征)<ul><li>互斥共享：一个时间段内只允许一个进程访问</li><li>同时访问：一个时间段内允许多个进程&quot;同时&quot;访问(微观上看仍是交替访问)</li></ul></li><li>虚拟性：把一个物理上(实际存在)的实体变为若干个逻辑上(感觉存在)的对应物<ul><li>时分复用技术：利用处理机的空闲时间运行其他程序,提高处理机的利用率</li><li>空分复用技术：利用存储器的空闲空间存放其他程序,提高内存的利用率</li></ul></li><li>异步性：进程以不可预知的速度向前推进</li></ul><p>3.操作系统的五大基本功能</p><blockquote><p>由于功能描述较多，前四个的分类有印象即可(了解后可帮助理解)</p></blockquote><ul><li><strong>处理器管理</strong>：处理器的分配和运行是<strong>以进程为单位</strong>的，因此也是对进程的管理<ul><li>进程控制：负责进程的创建、撤销及状态转换</li><li>进程同步：对并发执行的进程进行协调</li><li>进程通信：负责完成进程间的信息交换</li><li>进程调度：按一定算法进行处理器分配</li></ul></li><li><strong>存储器管理</strong>：对内存进行分配、保护、和扩充<ul><li>内存分配：按一定的策略为每道程序分配内存</li><li>内存保护：保证各程序互不干扰的运行</li><li>内存扩充：为允许大型作业的运行，必须借助虚拟存储技术获得增加内存的效果</li></ul></li><li><strong>设备管理</strong>：对计算机系统内的所有设备实施有效管理<ul><li>设备分配：按一定的分配原则对设备进行分配</li><li>设备传输控制：实现物理的输入/输出操作</li><li>设备独立性：用户程序中的设备与实际使用的物理设备无关</li></ul></li><li><strong>文件管理</strong>：负责信息管理<ul><li>文件存储空间管理：负责存储空间的分配与回收</li><li>目录管理：目录是为方便文件管理而设的数据结构能按名存取</li><li>文件操作管理：实现文件操作，负责文件读写</li><li>文件保护：提供文件保护功能</li></ul></li><li><strong>用户接口</strong>：为方便用户使用操作系统而设<ul><li>命令接口：提供一组命令供用户控制自己的作业<ul><li>联机命令(交互式)：说一句做一句</li><li>脱机命令(批处理)：说一堆一起做</li></ul></li><li>系统调用：用户向OS提出各种服务要求(如磁盘文件操作)</li><li>图形接口：如Windows、安卓、IOS</li></ul></li></ul><p>4.操作系统的形成</p><blockquote><p>各阶段的优点主要是解决了上一阶段的主要缺点</p></blockquote><ul><li>手工操作阶段：将纸带装入输入机，程序运行完成用户取走纸带<ul><li>缺点：用户独占全机、人机速度矛盾导致资源利用率极低</li></ul></li><li>批处理阶段<ul><li>单道批处理系统：引入脱机输入/输出(通过中间设备减少CPU等待输入输出时间)技术，并监督程序(OS的雏形)负责控制作业的输入、输出<ul><li>优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</li><li>缺点：内存中仅有一道程序运行，CPU大量时间空闲等待I/O完成，资源利用率依然很低</li><li>特点：自动性(作业依次自动运行)、顺序性、单道性</li></ul></li><li>多道批处理系统：每次可往内存中输入多道程序。（<strong>操作系统正式诞生</strong>）<ul><li>优点：多道程序并发执行，共享计算机资源，资源利用率大幅提升。</li><li>缺点：用户响应时间长，没有人机交互功能(提交作业后只能等待完成，不能自主控制作业执行)</li><li>特点：脱机使用PC、成批处理(分批次)、多道程序运行</li></ul></li></ul></li></ul><p>5.操作系统的分类</p><ul><li>批处理操作系统：包括单道批处理OS和多道批处理OS(详见上)</li><li>分时操作系统：以时间片为单位轮流为各个作业服务，各用户可通过终端与计算机交互<ul><li>优点：解决人机交互问题，允许多用户同时使用一台计算机，且操作相互独立。</li><li>缺点：不能优先处理一些紧急任务，OS对各个作业完全公平，不区分任务紧急性。</li><li>特点：多路性(多用户)、交互性、独占性(好像自己独占)、及时性</li></ul></li><li>实时操作系统：对外部输入能在<strong>规定时间内</strong>(注意这里的实时不是马上而是规定时间(s/ms/us级))处理完毕并做出反应<ul><li>硬实时系统：必须在规定时间内完成(如导弹控制系统)</li><li>软实时系统：能接受偶尔违反时间规定(如12306订票系统)</li><li>特点：及时性、可靠性</li></ul></li><li>其他操作系统<ul><li>嵌入式OS：运行在嵌入式系统环境中，如各种电器</li><li>网络OS：把网络中各计算机互联起来，实现资源共享、信息交换</li><li>分布式OS：各计算机地位相同(自治性)，工作由它们并行、协同完成且对用户透明</li></ul></li></ul><p>6.两种指令、处理器状态、程序</p><ul><li><p>特权指令：不允许用户直接使用的指令，如I/O指令、中断屏蔽指令、清内存指令</p></li><li><p>非特权指令：普通的运算指令</p></li><li><p>核心态(管态)：能执行一切指令，能访问所有寄存器和存储器</p></li><li><p>用户态(目态)：只能执行非特权指令，访问指定的寄存器和存储器</p></li><li><p>内核程序：系统的管理者，可执行一切指令、运行在核心态</p></li><li><p>应用程序：普通用户程序只能执行非特权指令，运行在用户态</p></li></ul><blockquote><p>助记：类似于Linux系统下的root用户和一般用户</p></blockquote><p>7.操作系统的内核：操作系统最基本最核心的部分</p><ul><li>时钟管理：实现计时功能</li><li>中断处理：负责实现中断机制</li><li>原语：一种特殊的程序<ul><li>处于操作系统最底层，最接近硬件</li><li>运行具有原子性，<strong>只能一气呵成，不能中断</strong></li><li>运行时间短、调用频繁</li></ul></li><li>系统资源的管理：进程管理、存储器管理、设备管理</li></ul><p>8.中断：为实现多道程序并发执行而引入的一种技术(如因I/O请求暂停执行时，可转去运行其它程序)，是CPU<strong>从用户态进入核心态的唯一途径</strong></p><ul><li>内中断：也称异常，由错误引起，信号来自内部</li><li>外中断：系统正常操作，如外设请求，信号来自外部</li></ul><p>9.系统调用：系统给程序员(应用程序)提供的唯一接口，可获得OS的服务。在用户态发生，核心态处理</p><ul><li>无论什么方式，最终都是通过系统调用，这是唯一接口</li></ul><p>程序接口：由一组系统调用组成，进一步封装</p><ul><li>针对操作系统，如凡是在Windows工作环境下执行的应用程序，都可以调用Windows API</li></ul><p>库函数：应用程序通过<strong>高级语言提供</strong>的库函数间接(编程方便)进行系统调用，在用户态运行</p><ul><li>针对某种语言本身，如C语言的库函数只能在C语言中使用</li></ul><p>10.用户执行系统调用的过程：先传递系统调用所需参数，通过陷入(trap)指令进入核心态，然后执行相应服务程序，最后返回用户态。</p><p>11.操作系统的体系结构</p><ul><li><p>大内核：将OS的主要功能模块作为系统内核</p><ul><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul></li><li><p>微内核：只保存基本的功能在内核</p><ul><li>优点：结构清晰，便于维护，可靠性高</li><li>缺点：需频繁在核心态和用户态切换，性能低</li></ul></li></ul><h2 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.操作系统提供给编程人员的接口是（C）</p><p>A.库函数B.高级语言C.系统调用D.子程序</p><p>答：程序员通过调用操作系统提供的<strong>系统调用函数</strong>来使用操作系统提供的服务。</p><p>而库函数是由<strong>程序设计语言提供</strong>的，它不是操作系统提供的接口。</p><p>2.在单处理机系统中，可并行的是（ D ）。</p><p>Ⅰ  进程与进程   Ⅱ  处理机与设备  Ⅲ  处理机与通道  Ⅳ  设备与设备</p><p>A.Ⅰ、Ⅱ和ⅢB.Ⅰ、Ⅱ和Ⅳ</p><p>C.Ⅰ、Ⅲ和ⅣD.Ⅱ、Ⅲ和Ⅳ</p><p>答：注意是并行即同时运行，而又是单处理机即单核，则同一时刻只能运行一个进程，但多个进程可以并发即交替的运行。</p><p>处理器、通道、设备都能并行运行(因为不属于同一类)，比如同时打印(设备)、计算(处理器)、传输数据(通道)</p><p>3.一个多道批处理系统中仅有P1和P2两个作业，P2 比 P1 晚 5ms到达，它们的计算和 I/O操作顺序如下：</p><p>P1  ：计算  60ms ，I/O 80ms，计算 20ms</p><p>P2  ：计算  120ms，I/O 40ms，计算 40ms</p><p>若不考虑调度和切换时间，则完成两个作业需要的时间最少是（B）</p><p>A.240msB.260msC.340msD.360ms</p><p>答：由于P2晚到，所以P1先执行</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201210172938859.png"  alt="image-20201210172938859"></p><blockquote><p>特别注意的是多道只是并发即交替执行，同一时刻CPU还是只能处理一个计算过程，但可以同时计算机处理I/O操作</p></blockquote><p>4.下列选项中，不可能在用户态发生的事件是（C）</p><p>A.系统调用B.外部中断C.进程切换D.缺页</p><p>答：注意题目问的是发生时处于用户态</p><p>系统调用本来就是操作系统提供给用户使用的接口，所以自然是由用户使用</p><p>外部中断比如用户敲击键盘，会产生外部中断，也是在用户态发生的</p><p>缺页会产生缺页中断，也是会发生在用户态下</p><p>而进程切换比如挂起一个正在运行的进程，显然用户是没有这个权限的，实质上需要修改程序状态字，且全程在核心态执行</p><h1>进程的描述与控制</h1><h2 id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2><p>1.进程是进程实体的运行过程，是<strong>资源分配的基本单位</strong>，也是接受调度的基本单位</p><p>2.进程的基本特征</p><ul><li>动态性(最基本特征)：进程是程序的一次执行过程，是动态的产生、变化和消亡的</li><li>并发性：内存中有多个进程，各进程可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li>异步性：各进程以各自独立的、不可预知的速度向前推进(执行结果的不确定性)</li><li>结构性：每个进程都会配置一个PCB,结构上看进程由程序段、数据段、PCB组成</li></ul><p>3.进程和程序的区别</p><ul><li>程序是静态的，就是放在磁盘里的可执行文件，是一系列指令的集合</li><li>进程是动态的，是程序的一次执行过程，一个程序可产生多个不同的进程</li></ul><p>4.进程的组成(严谨的说是进程实体或进程映像的组成)</p><ul><li>进程控制块PCB：<strong>是进程存在的唯一标志</strong>，进程被创建时OS会为其创建PCB,进程结束后回收PCB</li><li>程序段：程序的代码</li><li>数据段：原始数据或运行过程产生的中间或结果数据</li></ul><blockquote><p>PCB是给操作系统用的，程序段和数据段是给进程自己用的</p></blockquote><p>5.进程控制块PCB(Process Control Block)的组成</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214225227721.png"  alt="image-20201214225227721"></p><p>6.进程的组织方式</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214225941662.png"  alt="image-20201214225941662"></p><p>7.进程的5种基本状态</p><ul><li>创建态：此时进程正在被创建，OS会为进程分配资源、初始化PCB</li><li>就绪态：已经<strong>获得除处理器外的所有资源</strong>，一旦获得处理器可立即执行</li><li>运行态：此时进程已获得必要的资源并正在CPU上运行</li><li>阻塞态：由于某事件(如等待I/O完成)无法继续执行，此时即使把<strong>处理器分给它也无法运行</strong></li><li>终止态：此时进程正在消失，OS会回收其内存资源并回收PCB</li></ul><p>8.进程控制：实现进程状态的相互转换，用原语实现</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214231822060.png"  alt="image-20201214231822060"></p><blockquote><p>助记：阻塞到运行转个圈，运行也可到就绪</p></blockquote><p>9.进程的创建</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214233255993.png"  alt="image-20201214233255993"></p><p>进程的终止</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214233328937.png"  alt="image-20201214233328937"></p><p>进程的阻塞和唤醒</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214233425078.png"  alt="image-20201214233425078"></p><p>进程的切换</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214233516560.png"  alt="image-20201214233516560"></p><blockquote><p>无论哪个进程控制原语，其实只做三件事</p><p>1.更新PCB中的信息（修改进程状态）<br>2.将PCB插入合适的队列<br>3.分配/回收资源</p></blockquote><p>10.进程通信：即进程间的信息交换。</p><ul><li>进程的互斥和同步交换信息少且效率低称为低级进程通信方式。<ul><li>PV原语称为低级进程通信原语。</li></ul></li></ul><p>11.高级进程通信可分为三类</p><ul><li>共享存储：划出一块共享存储区，多个进程互斥的对其进行读写来实现通信</li><li>信息传递：进程间以消息为单位，通过OS提供的发送/接收消息原语进行数据交换<ul><li>直接通信方式：消息直接挂到接收进程的消息缓冲队列上</li><li>间接通信方式：消息先发到中间实体(信箱)中，也称为信箱通信方式。(eg：计网的电子邮件系统)</li></ul></li><li>管道：用于连接读写进程的一个共享文件，其实就是一个缓冲区<ul><li>一个管道只能实现半双工，双向通信需两个管道</li><li>写满不能再写，读空不能再读。没写满不能读，没读空不能写。</li></ul></li></ul><p>12.引入线程带来的变化</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215002014259.png"  alt="image-20201215002014259"></p><p>13.线程的属性</p><ul><li>处理机调度的基本单位（引入线程前是进程）</li><li>也有就绪、阻塞、运行三种基本状态</li><li>几乎不拥有系统资源，切换同进程的线程系统开销较小</li><li>进程间的多个线程也可并发执行，提高了系统的吞吐量</li><li>由于共享内存地址空间，同一进程的线程通信甚至无需OS干预</li><li>本身不能单独运行，只能包含在进程中并在进程中执行</li></ul><p>14.线程的实现方式</p><ul><li>用户级线程：通过线程库实现，由应用程序负责线程管理，用户看有多线程而OS意识不到线程的存在<ul><li>优点：线程切换无需进入核心态，开销小效率高</li><li>缺点：当一个线程被阻塞时，整个进程都会阻塞，多个线程不可并行运行</li></ul></li><li>内核级线程：由OS内核管理，OS为每个线程建立相应的TCB，<strong>是处理机分配的单位</strong><ul><li>优点：一个线程阻塞后其它线程仍可执行，多线程可并行执行</li><li>缺点：线程切换要在核心态完成，管理成本高，开销大</li></ul></li></ul><blockquote><p>很多编程语言提供了线程库(用户级)，而大多数操作系统都实现了内核级线程(内核级)</p><p>两个的区别关键在于OS能不能意识到线程的存在</p></blockquote><p>15.多线程模型：根据用户级线程和内核级线程的映射关系，可分为以下三种</p><ul><li>一对一模型：一个用户级线程映射到一个内核级线程<ul><li>优点：一个线程阻塞不影响其它线程，各个线程可并行执行，并发度高</li><li>缺点：线程管理都需要操作系统支持，开销大</li></ul></li><li>多对一模型：多个用户级线程映射到一个内核级线程<ul><li>优点：在用户空间管理，开销小效率高</li><li>缺点：一个线程阻塞会导致整个进程阻塞，多个用户级线程不能并行执行</li></ul></li><li>多对多模型：m个用户级线程映射到n个内核级线程(m≥n)<ul><li>优点：多个用户级线程可并行执行，不会限制用户级线程数量，一个用户级线程阻塞不影响其它线程</li></ul></li></ul><p>16.七状态模型</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487486948-692d915e-a888-4ee5-bd98-6b40503de95c.png"  alt="image-20201215002014269"></p><blockquote><p>注意挂起和阻塞都没获得CPU服务和所需资源，但挂起是将进程映像调到外存，而阻塞仍在内存</p></blockquote><h2 id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>由于所参考资料书中将进程描述和处理机调度合为了一章，进程的描述习题放在下章处理机调度中</p><h1>处理机调度与死锁</h1><h2 id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2><p>1.处理机调度：按某种算法选择一个进程将处理机分配给它</p><ul><li>高级调度(作业调度)：从<strong>后备</strong>队列中选择合适的<strong>作业</strong>将其调入<strong>内存</strong>，并为其创建进程</li><li>中级调度(内存调度)：从<strong>挂起</strong>队列中选择合适的<strong>进程</strong>将其数据调回<strong>内存</strong></li><li>低级调度(进程调度)：从<strong>就绪</strong>队列中选择一个<strong>进程</strong>为其分配<strong>处理机</strong></li></ul><blockquote><p>助记：从高到低的调度其实也是从外到内的过程，先是作业调度创建进程然后是进程调度执行进程。而发生频率由低到高</p></blockquote><p>2.引起进程调度或进程切换的原因</p><ul><li>进程主动放弃处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞(如等待I/O)</li></ul></li><li>进程被动放弃处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理(如I/O中断)</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul><p>3.不能进行进程调度和进程切换的情况</p><ul><li>处理中断的过程中</li><li>在操作系统<strong>内核程序</strong>临界区(互斥访问的一段程序)中</li><li>原子操作中(不可中断要一气呵成)</li></ul><p>4.进程调度的方式</p><ul><li><p>非抢占方式(不可剥夺式)：只允许进程主动放弃(完成或主动进入阻塞态)处理机，即使有更紧迫的任务到达也不搭理它</p><ul><li>实现简单，开销小但无法及时处理紧急任务，适用于早期批处理系统</li></ul></li><li><p>抢占方式(可剥夺方式)：有个更重要的进程需使用处理机，则立即暂停当前进程，将处理机分配给它</p><ul><li>可优先处理更紧急的任务，也可让进程按时间片轮流执行，适用于分时、实时操作系统</li></ul></li></ul><p>5.进程的切换与过程</p><ul><li>先对原来运行进程各种数据的保存</li><li>然后对新的进程各种数据的恢复</li></ul><blockquote><p>进程调度和切换都是有代价的，过于频繁会使系统效率下降</p></blockquote><p>6.调度算法的评价指标</p><ul><li>CPU利用率：CPU忙碌的时间占总时间的比例（忙碌时间/总时间）</li><li>系统吞吐量：单位时间内完成作业的数量      （完成作业数量/花了多少时间）</li><li>周转时间：作业从提交到完成的时间间隔      （作业完成时间-提交时间）<ul><li>用户更关心自己单个作业的周转时间</li></ul></li><li>平均周转时间：多个作业周转时间的平均值    （各作业周转时间之和/作业数）<ul><li>操作系统更关心系统的整体表现即所有作业的周转情况</li></ul></li><li>带权周转时间：作业周转时间与运行时间之比   （周转时间/运行时间）<ul><li>若周转时间相同，实际运行时间越长用户越满意    (等的时间相对少)</li></ul></li><li>平均带权周转时间：多个作业的带权周转时间的平均值 （各作业带权周转时间之和/作业数）</li></ul><p>7.周转时间包括四部分</p><ul><li>作业在外存后备队列等待调度的时间(高级调度)</li><li>进程在就绪队列等待进程调度的时间(低级调度)</li><li>进程在CPU上执行的时间</li><li>进程等待I/O操作完成的时间</li></ul><blockquote><p>由此可看出周转时间含很多等待时间，显然运行时间越长即等待时间越短用户越满意</p></blockquote><p>8.早期批处理的调度算法</p><ul><li>先来先服务算法(FCFS----&gt;First Come First Serve)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487741194-4a1e43a6-4819-4372-9bcd-0ab8e1d299a9.png"  alt="image-20201215002014271"></p><ul><li>短作业优先算法(SJF----&gt;Shortest Job First)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215111142387.png"  alt="image-20201215111142387"></p><ul><li>高响应比优先算法(HRRN----&gt;Hightest Response Ratio Next)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215111412289.png"  alt="image-20201215111412289"></p><p>三种调度算法对比</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215112543300.png"  alt="image-20201215112543300"></p><p>9.交互式系统的调度算法</p><ul><li>时间片轮转算法(RR----&gt;Round-Robin)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487858888-881de75c-ebec-430f-8e64-6275d82d1b56.png"  alt="image-20201215112543302"></p><ul><li>优先级调度算法</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215120938537.png"  alt="image-20201215120938537"></p><ul><li>多级反馈队列调度算法</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215121333296.png"  alt="image-20201215121333296"></p><p>三种调度算法对比</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215121427700.png"  alt="image-20201215121427700"></p><p>10.各调度算法优点</p><table><thead><tr><th>算法</th><th>优点</th></tr></thead><tbody><tr><td>FCFS</td><td>公平</td></tr><tr><td>SJF</td><td>能尽快处理完短作业，平均等待/周转时间等参数很优秀</td></tr><tr><td>时间片轮转调度</td><td>可让各个进程得到及时的响应</td></tr><tr><td>优先级调度</td><td>可灵活的调整各进程被服务的机会</td></tr><tr><td>多级反馈队列调度</td><td>对以上算法折中权衡，综合表现优秀平衡</td></tr></tbody></table><p>11.进程同步与互斥</p><ul><li><p>同步(直接制约关系)：异步性结果不可预知用同步实现<strong>先后顺序执行</strong>的目的</p></li><li><p>互斥(间接制约关系)：一个进程访问临界资源时，另一个进程必须等待</p><blockquote><p>临界资源：同时仅允许一个进程使用的资源</p></blockquote></li></ul><p>12.对临界资源的访问分为</p><ul><li>进入区：检查是否可进入临界区，若可访问则设置正在访问标志(上锁)</li><li>临界区：用于访问临界资源的代码</li><li>退出区：解除正在访问标志(解锁)</li><li>剩余区：其余代码部分</li></ul><p>13.互斥的要求</p><ul><li>空闲让进：临界区空闲时，可以允许一个进程进入临界区</li><li>忙则等待：当已有进程进入临界区时，其它进程必须等待</li><li>有限等待：请求访问的进程要在有限时间内进入临界区(避免饥饿)</li><li>让权等待：若进程不能进入临界区，应立即释放处理机，防止忙等待</li></ul><p>14.进程互斥的软件实现方法</p><ul><li>单标志法：进程访问完临界区后把使用权交给另一个进程。违背空闲让进原则 <img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223193511224.png"  alt="image-20201223193511224"></li></ul><blockquote><p>如果此时允许P0进入，P0却一直不进入使得虽然空闲P1也一直访问不了</p></blockquote><ul><li>双标志先检查法：先检查后上锁。违背忙则等待原则(检查和上锁不是一气呵成)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223193834481.png"  alt="image-20201223193834481"></p><blockquote><p>由于异步性，若按照125637的顺序两个进程将会同时访问临界区</p></blockquote><ul><li>双标志后检查法：先上锁后检查。违背空闲让进和有限等待，可能会产生饥饿</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223194127733.png"  alt="image-20201223194127733"></p><blockquote><p>若按1526的顺序两个进程都无法进入</p></blockquote><ul><li>Peterson算法：综合考虑，若都想进临界区则尝试让给对方。违背让权等待</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223194606686.png"  alt="image-20201223194606686"></p><p>15.进程互斥的硬件实现方法</p><ul><li>中断屏蔽方法：采用开/关中断实现，简单高效但只适用于单处理机</li><li>TestAndSet(TS/TSL)：old记录此时是否上锁，将lock设为ture，检查old若上锁则循环前几步</li><li>Swap(XCHG)：逻辑同上，二者简单高效，但不满足让权等待</li></ul><p>16.信号量机制</p><p>wait又称P操作即申请资源，signal又称V操作即释放资源</p><ul><li><p>整型信号量：用一个整型变量表示某种资源数，不满足让权等待</p></li><li><p><strong>记录型信号量</strong>：P操作若无可用资源则阻塞(block)，V操作唤醒(wakeup)链表第一个进程</p><blockquote><p>S.L表等待队列，S.value表资源数。P会S.value–，V会S.value++。满足让权等待</p></blockquote></li></ul><p>17.信号量实现同步与互斥</p><ul><li><p>实现互斥：信号量(可理解成资源数)初值为1，临界区之前P，临界区之后V</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex=<span class="number">1</span>;    P(mutex); 临界区代码; V(mutex);</span><br></pre></td></tr></table></figure></li><li><p>实现同步：信号量初值为0，前操作V释放资源后，后操作才能P申请资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若先P1才能P2   -----&gt;   P1&#123;代码...<span class="built_in">V</span>(s);&#125;      P2&#123;<span class="built_in">P</span>(s);代码...&#125;</span><br></pre></td></tr></table></figure></li></ul><p>18.生产者-消费者问题：缓冲区没满生产者才能放数据，缓冲区不空消费者才能取数据，所以两个同步信号量</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223202354872.png"  alt="image-20201223202354872"></p><p>必须先P资源信号量(full和empty)再P互斥信号量(mutex)，否则可能有占用权但无可用资源发生死锁</p><blockquote><p>要会默写上述代码，其它问题与这个类似</p></blockquote><p>19.其它同步问题</p><ul><li>吸烟者问题：轮流让三个吸烟者抽烟必须轮流的放组合一二三</li><li>读者写者问题：核心思想为设置一个count记录正在访问共享文件的读进程数，用count判断当前进程是否为第一个或最后一个读进程</li><li>哲学家进餐问题：关键在于解决进程死锁</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210104153055476.png"  alt="image-20210104153055476"></p><p>20.为解决信号量机制编程麻烦、易出错的问题引入管程</p><ul><li>进程只有调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li><li>各进程必须互斥访问管程是由编译器实现的</li><li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题</li></ul><blockquote><p>如Java中用关键字synchronized声明的函数，同一时间段内只能被一个线程调用</p></blockquote><p>21.死锁：各进程都在等待对方的资源导致各进程都阻塞</p><p>22.死锁产生的必要条件</p><ul><li>互斥条件：对互斥使用的资源的争抢才会导致死锁</li><li>不可抢占条件：进程获得的资源只能自己主动释放</li><li>请求和保持条件：进程保持着资源不放又去请求其它资源</li><li>循环等待条件：存在一种进程资源的循环等待链</li></ul><p>23.预防死锁：破坏死锁产生的四个必要条件中的一个或多个</p><ul><li>破坏互斥条件：将临界资源改造为可共享的资源(如SPOOLing技术)<ul><li>可行性不高，很多时候无法破坏互斥条件</li></ul></li><li>破坏不可抢占条件：无法申请到所需资源时应立即释放现有资源<ul><li>实现复杂，可能会导致部分工作失效，系统开销大且可能会饥饿</li></ul></li><li>破坏请求和保持条件：可采用静态分配方法，运行前分配所需资源且一直保持<ul><li>资源利用率低，可能会导致饥饿</li></ul></li><li>破坏循环等待条件：<strong>给资源编号</strong>必须按照从小到大的顺序申请资源<ul><li>不方便增加新设备、导致资源浪费、用户编程麻烦</li></ul></li></ul><p>24.避免死锁：避免系统进入不安全状态(银行家算法)</p><p>安全序列：按照此序列分配资源每个进程都能顺利完成</p><p>安全状态：此时系统至少存在一个安全序列</p><blockquote><p>不安全状态不一定会导致死锁，但死锁一定不安全。例如你在河边走处于不安全的状态只是有可能掉下去，而你要是掉下去了肯定处于不安全状态。但你要是离河远远地你就处于安全状态肯定不会掉下去。</p></blockquote><p>25.银行家算法：在资源分配之前先判断会不会进入不安全状态，若不会再分配</p><p>用到的数据结构：</p><ul><li>一维数组Available[m]表空闲资源m的数量</li><li>最大需求矩阵Max[n][m]表进程n对资源m最大需求数</li><li>已分配矩阵Allocation[n][m]表进程n已拥有的资源m的数量</li><li>需求矩阵Need[n][m]表进程n还需资源m的数量（=Max-Allocation）</li><li>向量Request<sub>n</sub>表进程n此次申请的各资源数量</li></ul><p>算法步骤</p><p>①检查此次申请是否超过之前声明的最大需求数（Request<sub>i</sub> ≤ Need<sub>i</sub>）</p><p>②检查此时剩余可用资源是否满足这次请求（Request<sub>i</sub> ≤ Available<sub>i</sub>）</p><p>③对于请求的资源预分配，修改以下向量</p><p>Available<sub>i</sub>=Available<sub>i</sub>-Request<sub>i</sub>//可用=可用-申请</p><p>Allocation<sub>i</sub>=Allocation<sub>i</sub>+Requesti//已分配=已分配+申请</p><p>Need<sub>i</sub>=Need<sub>i</sub>-Request<sub>i</sub>//需求=需求-申请</p><p>④用安全性算法检测此次分配是否会进入不安全状态</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201224164121330.png"  alt="image-20201224164121330"></p><p>25.死锁的检测与解除：允许死锁发生，系统负责检测出死锁并解除</p><p>死锁的检测：类似拓扑排序，找到一个点消除它的所有连接边直到消除所有边</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201224165707851.png"  alt="image-20201224165707851"></p><blockquote><p>找到既不阻塞又不孤立的点即P1(P1申请的资源还足够)，消除它的所有边，此时P2向R1申请一个资源，而R1还剩两个可用资源满足要求则消除P2所有边，所有边均消除说明没有死锁。</p></blockquote><p>死锁的解除：一旦检验到死锁就应该立即解除</p><ul><li>剥夺资源：<strong>挂起</strong>某些死锁进程，抢夺它的资源分给其它死锁进程，但应防止饥饿</li><li>撤销进程：撤销部分进程直到有足够的资源分给其它进程，实现简单但可能快结束而功亏一篑</li><li>进程回退：让一个或多个进程<strong>回退到足以回避死锁的地步</strong>，注意回退是进程自愿释放资源，需设置还原点</li></ul><h2 id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2><p>1.进程处于临界区不能进行处理机调度（X）</p><p>答：对于内核程序临界区访问的资源如果不尽快释放，极有可能影响OS内核的其它管理工作，所以处于内核程序临界区的时候不能进行调度和切换。</p><p>而题目所说的是临界区，这包括普通的临界区如打印机，此时调度和切换并不会影响OS内核的管理工作。而且如果访问打印机这种慢速外设如果不能调度系统性能肯定非常低。</p><p>2.适用于早期批处理调度算法的计算</p><ul><li>先来先服务算法(FCFS)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487747580-88c0b185-41ef-40a2-83cf-0183ec7dc383.png"  alt="image-20201215002014276"></p><ul><li>非抢占式的短作业优先调度算法(SPF)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215111716009.png"  alt="image-20201215111716009"></p><blockquote><p>由于非抢占，t=2时虽然P2已经到了但也只能等P1执行完</p></blockquote><ul><li>抢占式的短作业优先调度算法(SRTN)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215112027037.png"  alt="image-20201215112027037"></p><ul><li>高响应比优先算法</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215112211464.png"  alt="image-20201215112211464"></p><p>3.适用于交互式系统的算法的计算</p><ul><li>时间片轮转算法中时间片为2时</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487869975-cee512a6-a13e-4f77-8457-a0bf1ee1a0dc.png"  alt="image-20201215112211466"></p><blockquote><p>注：以下括号内表示当前处于就绪队列的进程，下同</p></blockquote><p>0时刻(P1(5))：0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片</p><p>2时刻(P2(4) &gt; P1(3))：2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。(注意: 2时刻， P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，<strong>默认新到达的进程先进入就绪队列</strong>)</p><p>4时刻(P1(3)→ P3(1) &gt; P2(2))：4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾</p><p>5时刻(P3(1) &gt; P2(2) &gt; P4(6))：5时刻，P4到达插到就绪队尾（注意：<strong>由于P1的时间片还没用完，因此暂时不调度</strong>。另外，<strong>此时P1处于运行态，并不在就绪队列中</strong>）</p><p>6时刻(P3(1)→ P2(2) &gt; P4(6)→P1(1))：6时刻，P1时间片用完，下 处理机，重新放回就绪队尾，发生调度</p><p>7时刻(P2(2) →P4(6)→P1(1))：虽然<strong>P3的时间片没用完</strong>，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。</p><p>9时刻(P4(6) &gt; P1(1))：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机</p><p>11时刻(P1(1)→ P4(4) )：P4时间片用完，重新回到就绪队列。P1上处理机</p><p>12时刻(P4(4))：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机</p><p>14时刻()：就绪队列为空，因此让P4接着运行一个时间片。</p><p>16时刻：所有进程运行结束</p><ul><li>时间片轮转算法中时间片为5时</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215122143265.png"  alt="image-20201215122143265"></p><p>0时刻(P1(5) )：只有P1到达，P1. 上处理机。</p><p>2时刻(P2(4))：P2到达，但P1时间片尚未结束，因此暂不调度</p><p>4时刻(P2(4)&gt; P3(1))：P3到达，但P1时间片尚未结束，因此暂不调度</p><p>5时刻( P2(4)&gt; P3(1)&gt; P4(6) )：P4到达，同时，P1运行结束。发生调度，P2上处理机。</p><p>9时刻( P3(1)&gt; P4(6) )：P2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。</p><p>10时刻( P4(6) )：P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。</p><p>15时刻( )：P4时 间片用完，但就绪队列为空，因此会让P4继续执行一个时间片。</p><p>16时刻( )：P4运行完，主动放弃处理机。所有进程运行完。</p><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此<strong>时间片不能太大</strong>。</p><p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果<strong>时间片太小，会导致进程切换过于频繁</strong>，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见<strong>时间片也不能太小。</strong></p><ul><li>非抢占式优先级调度算法</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593487927217-c4f02d78-a485-402e-8906-7210924af5ef.png"  alt="image-20201215122143277"></p><p>0时刻(P1)：只有P1到达，P1上处理机。</p><p>7时刻(P2、P3、P4)：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机。</p><p>8时刻(P2、P4)：P3完成，P2、 P4优先级相同，由于P2先到达，因此P2优先上处理机</p><p>12时刻(P4)：P2完成，就绪队列只剩P4，P4上处理机。</p><p>16时刻()：P4完成，所有进程都结束</p><ul><li>抢占式优先级调度算法</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215122522783.png"  alt="image-20201215122522783"></p><p>0时刻(P1)：只有P1到达， P1上处理机。</p><p>2时刻(P2)：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。</p><p>4时刻(P1、P3)：P3到达， 优先级比P2更高，P2回到就绪队列，P3抢占处理机。</p><p>5时刻(P1、P2、P4)：P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机</p><p>7时刻(P1、P4)：P2完成,就绪队列只剩P1、P4，P4上处理</p><p>11时刻(P1)：P4完成，P1上处理机</p><p>16时刻()：P1完成，所有进程均完成</p><ul><li>多级反馈队列调度算法</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1593488009525-1e4f8020-a00a-44d3-8ebe-30d4df840daf.gif"  alt="image-20201215122522799"></p><p>4.并发进程执行的相对速度是（C）<br>A.由进程的程序结构决定的B.由进程自己来控制的<br>C.与进程调度策略有关的  D.在进程被创建时确定的</p><p>答：并发速度受调度策略影响，采用不同的调度策略(FCFS、SJF)会影响执行的相对速度。要不然也不会那么费力去研究调度算法了。</p><p>5.中断扫描机构是（B）扫描一次中断寄存器。<br>A.每隔一个时间片 B.每条指令执行周期内最后时刻<br>C.每当进程释放CPUD.每产生一次中断</p><p>答：处理器执行完一条指令后，中断扫描机构立即检查有无中断，无中断就继续下一条指令，若有中断就处理中断，这一过程称为&quot;中断响应&quot;</p><p>6.关于临界问题的一个算法（假设只有P0和P1可能会进入临界区）如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">retry:</span><br><span class="line"><span class="keyword">if</span>(turn!=<span class="number">-1</span>)turn=i;</span><br><span class="line"><span class="keyword">if</span>(turn!=i)go to retry;</span><br><span class="line">turn=<span class="number">-1</span>;</span><br><span class="line">临界区;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line">其他区域;</span><br><span class="line">until <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>该算法（B）</p><p>A.不能保持进程互斥进入临界区,且会出现“饥饿”<br>B.不能保持进程互斥进入临界区,但不会出现“饥饿”<br>C.保证进程互斥进入临界区,但会出现“饥饿”<br>D.保证进程互斥进入临界区,不会出现“饥饿”</p><p>答：最容易出错的地方就是两个进程同时申请进入临界区的时候，由于并发交替进行无法确定执行顺序可能就会带来问题。</p><p>①若P0先执行两个判断然后P1执行两个判断，然后他们再执行turn=-1。</p><p>P0：满足turn!=-1置turn=0;满足turn=0不回退</p><p>P1：满足turn!=-1置turn=1;满足turn=1不回退</p><p>P0执行turn=-1然后P1执行turn=-1,就会发生他们同时进入临界区的问题</p><p>②对于饥饿问题，根本原因在于进程一直进不去临界区，而只有turn=-1时他们才会进不去，但如果turn=-1那么肯定有个进程已经进去临界区了，它出来的时候就会把turn置为0所以不会有进程饿死。</p><p>7.（B）有利于CPU繁忙型的作业,而不利于I/O繁忙型的作业(进程)。<br>A.时间片轮转调度算法B.先来先服务调度算法<br>C.短作业(进程)优先调度算法D.优先权调度算法</p><p>答：CPU繁忙型指该类作业需要大量的CPU时间进行计算而很少请求I/O，例如一般的科学计算。I/O繁忙型指CPU进行处理的时候需要频繁请求I/O，而每次操作I/O时间又很短，例如目前大多数事务处理。</p><p>因此可以转换为哪个算法有利于长作业而不利于短作业？</p><p>FCFS先来先服务有利于长作业不利于短作业。例如排队买杯奶茶但前面却有人要了100杯。</p><p>8.下面哪一个不会引起进程创建（C）<br>A.用户登录B.作业调度C.设备分配D.应用请求</p><p>答：引起进程创建的四类典型事件除了ABD还有提供服务</p><ul><li>用户登录：要为用户提供服务，之前没有就要创建</li><li>设备分配：由内核自动完成，不需要创建进程</li><li>提供服务：系统为用户创建进程</li><li>应用请求：用户程序自己创建进程</li><li>作业调度：为调度的作业分配资源并为其创建进程</li></ul><p>9.要实现两个进程互斥,设一个互斥信号量 mutex,当 mutex为0时,表示（B）<br>A.没有进程进入临界区</p><p>B.有一个进程进入临界区</p><p>C.有一个进程进入临界区,另外一个进程在等候</p><p>D.两个进程都进入临界区</p><p>答：两个进程互斥，互斥信号量mutex的取值为1，0，-1且初值为1。</p><p>当一个进程请求访问后mutex为0，再有一个进程申请的时候执行P操作mutex-1=-1此时一个进入一个在等待。因此为0时时一个进入了临界区</p><blockquote><p>注意C中的另一个在等候，第二个进程要是不申请就不会等候，而它要是申请了mutex=-1</p></blockquote><p>10.下面关于管程的叙述错误的是（C）<br>A.管程是进程的同步工具,解决信号量机制大量同步操作分散的问题<br>B.管程每次只允许一个进程进入管程<br>C.管程中ⅴ操作的作用和信号量机制中V操作的作用相同<br>D.管程是被进程调用的,是语法范围,无法创建和撤销</p><p>答：管程的V操作不同于信号量机制中的V操作，前者V必须在P之后，而后者则没有这个要求，只要P和V成对出现即可。</p><p>11.若系统中有5台绘图仪,有多个进程需要使用两台,规定每个进程一次仅允许申请一台,则最多允许（D）个进程参与竞争,而不会发生死锁。<br>A.5B.2C.3D.4</p><p>答：m个进程，都需要两个同类资源，不会发生死锁的最少资源数是m*(2-1)+1即m+1 ≤ 5，所以m ≤ 4</p><blockquote><p>最坏情况，所有进程都差了一个资源(先给其中一个进程等它运行完就会释放资源)</p></blockquote><p>12.若系统中有n个进程,则在阻塞队列中进程的个数最多为（A）<br>A.nB.n-1C.n-2D.1</p><p>答：一定不要忘了有种特殊情况就是死锁，n个进程都在互相等待对方手里的资源最终都处于阻塞状态。</p><p>13.下列关于线程的叙述中,正确的是（D）<br>Ⅰ.在采用轮转调度算法时,一进程拥有10个用户级线程,则在系统调度执行时间上占用10个时间片<br>Ⅱ.属于同一个进程的各个线程共享栈空间<br>I.同一进程中的线程可以并发执行,但不同进程内的线程不可以并发执行<br>Ⅳ.线程的切换,不会引起进程的切换<br>A.仅Ⅰ、Ⅱ、ⅢB.仅Ⅱ、Ⅳ<br>C.仅Ⅱ、Ⅲ    D.全错</p><p>答：I错误，由于用户级线程不依赖于系统内核，内核是看不到用户级线程的，别管你有几个线程在它看来看到的都只是一个进程，因此只分一个时间片</p><p>而对于内核级线程，由于内核知道线程的存在，所以有多少线程就能分多少时间片</p><p>II错误，共享进程的地址空间，共享进程的资源但线程有自己的栈空间不与其他线程共享</p><p>III错误，同一进程的线程可并发，甚至不同进程的线程也可以并发</p><p>IV错误，从一个进程的线程切换到另一个进程的线程，进程都变了肯定会引起进程的切换</p><p>14.若一个用户进程通过read系统调用读取一个磁盘文件中的数据,则下列关于此过程的叙述中,正确的是（A）<br>I.若该文件的数据不在内存中,则该进程进入睡眠等待状态<br>II.请求read系统调用会导致CPU从用户态切换到核心态<br>Ⅲ.read系统调用的参数应包含文件的名称<br>A.仅I、ⅡB.仅1、ⅢC.仅Ⅱ、ⅢD.1、Ⅱ和Ⅲ</p><p>答：若用户读取的磁盘文件不在内存中，就会转向中断处理，导致CPU从用户态切换到核心态，此时该进程进入睡眠等待状态(其实就是阻塞态)</p><p>对于III，调用read之前需要用open打开文件，而open函数会指定文件的名称然后产生一个文件编号或索引，之后的所有操作都是操作这个编号或索引号就可以，因此read系统调用的参数并不会包含文件名称</p><p>15.若某单处理器多进程系统中有多个就绪进程,则下列关于处理器调度的叙述中,错误的是（C）<br>A.在进程结束时能进行处理器调度<br>B.创建新进程后能进行处理器调度<br>C.在进程处于临界区时不能进行处理器调度<br>D.在系统调用完成并返回用户态时能进行处理器调度</p><p>答：A.进程结束后进程撤销处理器应当处理下一个进程了，自然会出现处理器调度</p><p>B.创建新进程后若该进程较紧急，处理器可能就会暂停当前活动而转向调度执行新创建的进程，因此也可能会发生处理器调度</p><p>C.进程处于临界区，其它进程肯定进不去临界区，但是系统可以暂停执行处于临界区的进程而转去执行其它进程，处理完之后再继续执行临界区的剩余代码即可，因此也可能会发生处理机调度</p><p>D.系统调用结束后返回正常执行的过程，此时肯定也可以继续进行系统调用</p><p>16.某系统有n台互斥使用的同类设备,3个并发进程分别需要3、4、5台设备,可确保系统不发生死锁的设备数n最小为（B）<br>A.9B.10C.11D.12</p><p>答：当系统只有(3-1)+(4-1)+(5-1)=9台设备时，三个进程分别分配2、3、4台。这种情况下3个进程都无法继续执行发生死锁，而只需要再添加一个设备把它分配给任意一个进程就保证都可以执行完成，也就是最少需要10台</p><blockquote><p>这类问题都是固定解法，先找最坏情况或者说都缺一个的情况</p></blockquote><p>17.若系统S1采用死锁避免方法,S2采用死锁检测方法,下列叙述中,正确的是(B)<br>I.S1会限制用户申请资源的顺序,而S2不会<br>Ⅱ.S1需要进程运行所需资源总量信息,而S2不需要<br>Ⅲ.S1不会给可能导致死锁的进程分配资源,而S2会<br>A.仅I、ⅡB.仅Ⅱ、ⅢC.仅I、ⅢD.I、Ⅱ、Ⅲ</p><p>答：死锁避免最典型的是银行家算法，注意它会限制分配资源的顺序而不会限制申请资源的顺序，你原先咋申请现在还咋申请，只不过我不一定给你分配</p><p>而对于死锁预防典型代表为顺序资源分配，只能按编号从小到大申请资源，其限制了申请资源的顺序。</p><p>而对于死锁检测就是你得先出事(发生死锁)我才会管你</p><p>因此I是错的</p><p>18.系统中有3个不同的临界资源R1、R2和R3,被4个进程p1、p2、p3及p4共享。各进程对资源的需求为:pl申请R1和R2,p2申请R2和R3,p3申请R1和R3,p4申请R2。若系统出现死锁,则处于死锁状态的进程数至少是（C）<br>A.1B.2C.3D.4</p><p>答：可用死锁检测画图来计算</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227003422442.png"  alt="image-20201227003422442"  /><p>而要是想形成循环和P4没关系，当发生下图时形成一个循环</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227003537916.png"  alt="image-20201227003537916"></p><p>若先分配给P4那么死锁就是3个，要是没事先分配就是4个</p><h1>内存管理</h1><h2 id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2><p>1.内存管理的功能</p><ul><li>内存的分配与回收：使程序员摆脱存储空间分配的麻烦<ul><li>分为连续分配管理和非连续分配管理</li></ul></li><li>地址变换：将程序中的逻辑地址转换为内存中的物理地址(地址重定位)</li><li>扩充内存：借助于虚拟存储等技术为用户提供比内存大的地址空间，从逻辑上扩充内存容量<ul><li>分为覆盖技术、交换技术、虚拟存储技术</li></ul></li><li>内存保护：保证内存的各道作业都在自己的存储空间内运行，互不干扰<ul><li>上、下限寄存器：分别存放进程的上、下限地址，访问地址时先检查是否越界</li><li>重定位和界地址寄存器：二者分别存放起始地址和最大逻辑地址以此检查<ul><li>如逻辑地址80，小于界地址179，则物理地址为80+重定位100=180</li></ul></li></ul></li></ul><p>2.从源程序到执行的过程，经历了三个阶段</p><ul><li>编译：由编译程序将源代码编译成若干个目标模块（其实就是将高级语言翻译成机器语言）</li><li>链接：编译好的目标模块以及所需的库函数链接在一起，生成装入模块(得到逻辑地址)<ul><li>静态链接：程序运行前将各目标模块及所需库链接成完整的可执行文件，之后<strong>不再拆开</strong><ul><li><strong>装入前</strong>链接成一整块一下链接完，后面俩都是链接成一个个装入模块</li></ul></li><li>装入时动态链接：将编译后得到的目标模块装入内存时边装入边链接<ul><li>编译后链接<strong>和装入一起进行</strong>（所有模块都被链接）</li></ul></li><li>运行时动态链接：<strong>程序运行需要</strong>一些模块时，才把这些模块进行链接<ul><li>运行时要啥你再链接啥（部分模块被链接）</li></ul></li></ul></li><li>装入：由装入程序将装入模块装入内存运行（得到物理地址）<ul><li>绝对装入：编译时就产生绝对地址<ul><li>只适用于单道程序，编译器负责地址转换</li></ul></li><li>可重定位装入：又称为静态重定位，将逻辑地址重定位转换为物理地址<ul><li>如物理地址=逻辑地址+1000</li><li>必须分配作业所需全部内存空间，否则不能装入，且运行期间<strong>不能移动</strong></li><li>装入程序负责地址转换，适用早期多道批处理阶段</li></ul></li><li>动态运行装入：运行时才将逻辑地址转换为物理地址，需设置重定位寄存器<ul><li>物理地址=重定位(基址)寄存器内容+逻辑地址</li><li>可将程序分配到不连续的存储区，动态分配内存，允许程序在内存移动</li><li>运行时才进行地址转换，适用于现代操作系统</li></ul></li></ul></li></ul><p>3.覆盖技术：将程序分为多个段，常用的段常驻内存，不常用的段在需要时调入内存，解决大作业小内存问题</p><ul><li>固定区：存放常用的段，调入后除非运行结束否则不能再调出</li><li>覆盖区：存放不常用的段，需要时调入内存，用不到时调出内存<ul><li>可以让那些不可能同时被访问的程序段共享一个覆盖区</li></ul></li><li>必须由<strong>程序员声明覆盖结构</strong>，操作系统完成自动覆盖</li><li>缺点：对用户不透明，增加编程负担，用于早期操作系统</li><li>在同一个作业或进程中发生</li></ul><p>4.交换技术：内存紧张时换出(挂起)某些进程再换入某些已具备运行条件的进程</p><ul><li><p>文件区：占磁盘小部分，存放文件，追求存储空间的利用率</p></li><li><p>对换区：存放被换出的进程数据(PCB不会被换出)，追求换入换出速度</p></li><li><p>由中级(内存)调度决定将哪个挂起的进程调入内存</p></li><li><p>在不同作业或进程之间发生</p></li></ul><p>5.内部碎片：<strong>已经分配</strong>给作业但不能被利用的内存空间</p><p>外部碎片：<strong>还未分配</strong>给作业但由于碎片太小无法分配给作业</p><p>6.连续分配管理：为用户进程分配的必须是一个连续的内存空间</p><blockquote><p>助记：只要是固定大小的分配都会产生内部碎片，其余的都会产生外部碎片</p></blockquote><ul><li><p>单一连续分配：内存分为系统区和用户区，只能有一道用户程序且独占用户区</p><ul><li>实现简单，只适用单道程序，存储器利用率低</li><li>无外部碎片，有内部碎片</li></ul></li><li><p>固定<strong>分区</strong>分配：将内存空间分为若干个固定大小的分区，每个分区只能装一道程序</p><ul><li>各分区大小相等：缺乏灵活性，但适用于控制多个相同对象</li><li>各分区大小不等：增加了灵活性，可根据作业大小情况进行划分</li><li>无外部碎片，有内部碎片</li></ul></li><li><p>动态分区分配：进程装入内存时才根据进程大小动态创建分区</p><ul><li><p>记录内存使用情况的数据结构</p><ul><li>空闲分区表：每个空闲分区对应一个表项，包括分区号、分区大小、起始地址、状态等信息</li><li>空闲分区链：各分区起始和结尾设置前向指针和后向指针</li></ul></li><li><p>动态分区分配算法：解决应选择哪个空闲分区的问题</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185037811.png"  alt="image-20201223185037811"></p><blockquote><p>助记：别人找你要100块，你就只给他100是最佳即优先给少点</p><p>你给他10000然后你就喝西北风了这是最坏即优先给多点</p></blockquote></li><li><p>回收分区时要将相邻空闲分区合并</p></li><li><p>外部碎片可用紧凑技术解决</p></li><li><p>有外部碎片，无内部碎片</p></li></ul></li></ul><p>7.非连续分配：为用户进程分配的可以是一些分散的内存空间</p><ul><li>基本分页存储管理</li><li>基本分段存储管理</li><li>段页式存储管理</li></ul><p>8.基本分页存储管理：把进程分页，各个页面可离散放到各个内存块中</p><ul><li><p>将进程分成若干大小相等区域，称为<strong>页</strong>或页面</p><ul><li>每个页面有一个编号即页号，从0开始</li></ul></li><li><p>将内存空间分成与页面大小相等的区域，称为页框(页框=页帧=<strong>内存块</strong>=物理块=物理页面)。</p><ul><li>每个页框也有一个编号即页框号(页框号=页帧号=内存块号=物理块号=物理页号)，从0开始。</li></ul></li><li><p>OS将进程中的任意一页放到内存中的任意一个页框(页框装着页)中。</p></li></ul><blockquote><p>简单来说就是将内存和进程都划分成若干大小相等区域，然后把进程的区域&quot;随便&quot;放到内存的区域中一一对应（进程分页，内存分块）</p></blockquote><p>9.页表：记录每个页面和内存中实际存放的内存块之间的映射关系</p><ul><li>一个进程对应一张页表，进程的每一页对应一个页表项<ul><li>页表项由页号(页面的位置)和块号(内存块的位置)组成</li><li>每个页表项大小相同</li><li>页表项连续存放，因此页号可以是隐含的(不占存储空间)</li><li>i号页表项存放地址 = 页表起始地址 + i*页表项大小</li></ul></li></ul><blockquote><p>假设有一本书，每一页有固定字数，页面大小就是每一页字数数量，每本书都有目录，一个目录项(页表项)对应一页</p></blockquote><p>10.基本地址变换机构（由逻辑地址确定物理地址）</p><ul><li>地址变换过程<ul><li>计算页号P（逻辑地址/页面大小）和页内偏移量W（逻辑地址%页面大小）</li><li>若页号大于页表长度表示已超越进程的地址空间产生越界中断</li><li>根据页表起始地址和页号找到对应页表项（第一次访存）</li><li>根据页表项中记录的内存块号和页内偏移量得到最终物理地址</li><li>访问物理内存对应的内存单元（第二次访存）</li></ul></li><li>页式管理中地址是一维的：只要给一个逻辑地址系统就能计算页号和页内偏移量</li><li>实际应用中会让页表项占更多字节使得页框刚好放下整个页表项而没有剩余</li><li>为了方便找到页表项，页表项一般会放在连续的内存中</li></ul><p>11.具有快表的地址变换机构：是基本地址变换机构的改进版本</p><ul><li><p>快表(TLB)：访问速度比内存快很多的高速缓存，存放最近访问的页表项的副本</p></li><li><p>页表寄存器：存放页表在内存中的起始地址F和页表长度M</p><ul><li>起始地址F用来得到页表页号在内存中的具体地址：起始地址+页号*页表项长度</li></ul></li><li><p>页表长度表示页表有多少个页表项用来判断是否越界：若p ≥ M则越界中断</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227124319360.png"  alt="image-20201227124319360"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185157788.png"  alt="image-20201223185157788"></p><blockquote><p>若命中先访问的是快表，而快表是高速缓存不属于内存，所以只需一次访存</p><p>查快表和查页表其实看着都一样，只不过查快表速度要快的多，可理解成一个速度快得多的页表</p><p>注意给的是一个逻辑地址，而一个页或一个块中有很多地址，所以需要一个页内偏移指出要访问的是哪个块中的具体哪个地址</p></blockquote></li></ul><p>12.局部性原理</p><ul><li><p>时间局部性：使用了某个指令或数据，不久后很可能又再次使用</p></li><li><p>空间局部性：程序访问了某个存储单元，不久后其附近的存储单元也可能被访问</p><blockquote><p>基本地址变换机构中，每次访问一个逻辑地址都要查询页表，由于局部性原理，可能连续多次查到的都是同一个页表项</p></blockquote></li></ul><p>13.单级页表存在的问题及解决方法</p><ul><li>所有页表连续存放，页表过大时需很大的连续空间(因为页表项一般都连续存储)<ul><li>用两级页表解决，即把页表再分页并离散存储，再建立一张页表记录原页表各部分存放位置，称为页目录表(或外层页表、顶层页表)</li></ul></li><li>一段时间内并非所有页面都能用到，没必要让整个页表常驻内存<ul><li>可以在需要访问页面时才把页面调入内存（虚拟存储技术）</li><li>可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</li></ul></li></ul><p>14.两级页表如何实现地址变换</p><p>①按照地址结构将逻辑地址拆分成三部分（之前是页号+页内偏移量）<br>②从PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置<br>③根据二级页号查二级页表，找到最终想访问的内存块号<br>④结合页内偏移量得到物理地址</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227145700475.png"  alt="image-20201227145700475"></p><p>15.基本分段存储管理：思想和过程类似于基本分页存储管理，但各段长度可以不同</p><ul><li>分段：将程序的地址空间按自身逻辑划分为若干段，每个段都有段名，每段从0开始编制</li><li>内存分配规则：以段为单位，每个段在内存是连续的，各段可不相邻</li><li>段表：记录逻辑段到实际存储地址的映射关系<ul><li>每个段对应一个段表项，各段表项长度相同，段号可隐含</li></ul></li></ul><p>16.分段地址变换</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227151557944.png"  alt="image-20201227151557944"></p><blockquote><p>注意分页存储中，物理地址的格式为块号+页内偏移，而分段存储中物理地址格式为段基址+段内地址</p></blockquote><p>17.分页和分段的对比</p><ul><li>页是信息的物理单位对用户不可见，段是信息的逻辑单位对用户可见，编程时需显式给出段名</li><li>页的大小固定且由系统决定而段长度不固定由用户决定</li><li>分页的地址是一维的(给出逻辑地址即可)，而分段地址是二维的(给出段名和段内地址)</li><li>分段更容易实现信息的共享和保护</li></ul><p>18.段页式存储管理：将进程按逻辑分段，再将各段分页。然后将内存分为与页面大小相等的内存块。就是分段+分页</p><ul><li>段号：给出页表是在哪个块号中和页表的长度</li><li>页号：根据段号查段表得到的页表所在块号去找对应块然后根据页号就能得到具体内存块号<ul><li>注意块和页的大小是一样的，所以给出块号就能唯一确定页表了</li></ul></li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227153138338.png"  alt="image-20201227153138338"></p><p>19.传统存储管理方式的缺点(连续、非连续分配)：</p><ul><li>一次性：作业必须一次全部调入内存</li><li>驻留性：作业数据在整个运行期间常驻内存</li></ul><p>20.虚拟内存：程序不需全部装入即可运行，运行时根据需要动态调入，若内存不够还需换出一些数据</p><ul><li>多次性：作业无需一次全部调入内存，可多次调入</li><li>对换性：作业运行无需常驻内存，允许将作业换入、换出</li><li>虚拟性：逻辑上扩充了内存，使用户看到的内存容量远大于实际容量</li><li>虚拟内存的实现<ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式管理</li></ul></li></ul><p>21.请求分页存储管理：基本分页+请求调页+页面置换</p><ul><li><p>页表结构</p><ul><li>页号和物理号：和基本分页存储管理功能一样</li><li>状态位：表示页面是否已在内存中</li><li>访问字段：记录一段时间内被访问次数，或多久未被访问</li><li>修改位：表示页面调入内存后是否修改过，只有修改过的才需在置换时写回外存</li><li>外存地址：页面在外存中存放的位置</li></ul></li><li><p>缺页中断机构</p><ul><li>找到页表项检查页表是否在内存中，若没在<strong>产生缺页中断</strong><ul><li>传统存储管理作业一次性调入内存所以不存在页表不在内存的情况，也不会有缺页中断</li></ul></li><li>缺页中断处理中，要将目标页面调入内存，必要时换出页面</li><li>缺页中断属于内中断的&quot;故障&quot;，即可能被系统修复的异常</li><li>一条指令执行过程中可能产生多次缺页中断</li></ul></li><li><p>地址变换机构</p><ul><li>找到页表项检查页表是否在内存中<ul><li>若不在内存中，需要<strong>请求调页</strong></li></ul></li><li>若内存空间不够，还需<strong>页面置换</strong>换出页面</li><li>页面调入内存后，需要修改相应页表项</li></ul><blockquote><p>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：查快表(未命中)——查慢表(发现未调入内存)——调页(调入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元</p></blockquote></li></ul><p>22.页面置换算法：决定将内存中哪个页面置换出去</p><blockquote><p>以下前三个算法是重点</p><p>最佳置换OPT向后看淘汰最远，最近最少使用LRU向前看淘汰最远</p><p>只有FIFO才可能产生Belady异常</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185453974.png"  alt="image-20201223185453974"></p><p>23.页面分配策略</p><ul><li>驻留集：请求分页存储管理中给进程分配的物理块的集合</li><li>页面分配、置换策略<ul><li>固定分配局部置换：运行前分配一定数量物理块，缺页时只能换出自己的某一页</li><li>可变分配全局置换：只要缺页就分配新物理块，可能来自空闲物理块，也可能需换出别的进程页面</li><li>可变分配局部置换：频繁缺页的进程多分配一些物理块，缺页率很低的进程回收一些物理块，直到缺页率合适。</li></ul></li><li>页面调入策略（何时调入）<ul><li>预调页策略：将预测要访问的页面预先调入内存，用于程序运行前调入</li><li>请求调页策略：运行期间发生缺页才将所缺页面调入内存</li></ul></li><li>从何处调入页面<ul><li>补充知识：对换区采用连续存储方式，I/O速度更快。文件区采用离散存储方式，速度更慢</li><li>对换区足够大：运行前将数据从文件区复制到对换区，之后都从对换区调入调出</li><li>对换区不够大：不会被修改的数据从文件区调入无需换出，会被修改的数据调出到对换区，需要时从对换区调入</li><li>UNIX方式：第一次使用的页面都从文件区调入。调出的页面都写回对换区，再次使用时从对换区调入。</li></ul></li><li>抖动(颠簸)现象：页面频繁换入换出。主要原因是页面置换算法不合理。</li><li>工作集：某段时间间隔里，进程实际访问的页面的集合。一般小于驻留集。</li></ul><p>24.3种离散分配方式的比较</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227175957572.png"  alt="image-20201227175957572"></p><blockquote><p>助记：只要是固定大小的分配都会产生内部碎片，其余的都会产生外部碎片</p><p>分页和分段都2次访存，带快表就访存1或2次，段页式访存3次</p></blockquote><p>25.几种内存管理方式的比较</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227180029960.png"  alt="image-20201227180029960"></p><h2 id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2><p>1.假设某系统物理内存大小为4GB,页面大小为4KB,则每个页表项至少应该为多少字节?<br>答：内存块大小=页面大小=4KB=2<sup>12</sup>B<br>4GB的内存总共会被分为2<sup>32</sup>/2<sup>12</sup>=2<sup>20</sup>个内存块<br>内存块号的范围应该是0~2<sup>20</sup>-1<br>内存块号至少要用20bit来表示即至少要用3B来表示块号(3*8=24bit)</p><p>页表项=页号+块号，由于页号可以是隐含的所以页表项至少为3B</p><p>2.若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E</p><p>答：题目等价描述：某系统按字节寻址，页内偏移量占10位(2<sup>10</sup>=1KB)，页号2对应的内存块号 b = 8，将逻辑地址 A=2500 转换为物理地址E</p><p>①页号P=A/L=2500/1024=2  页内偏移量W=A%L=2500%1024=452</p><p>②根据题目描述页号2没有越界（因为其有对应的内存块号）</p><p>③物理地址E=b*L+W=8*1024+452=8644</p><p>3.某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？</p><p>答：①若先查快表再查慢表：(1+100)*0.9 + (1+100+100)*0.1=111us<br>②有的系统支持快表和慢表同时查找，平均耗时为 (1+100)*0.9 + (100+100) *0.1=110.9 us</p><blockquote><p>若未引入快表，需要100+100=200us，这题关键在于是几次访存</p></blockquote><p>4.在一个请求分页系统中,采用LRU页面置换算法时,加入一个作业的页面走向为:1,3,2,1,1,3,5,1,3,2,1,5。当分配给该作业的物理块数分别为3和4时,在访问过程中所发生的缺页率为（C）<br>A.25%,33%B.25%,100%<br>C.50%,33%D.50%,75%</p><p>答：物理块为3时，缺页情况如下</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201230202312545.png"  alt="image-20201230202312545"></p><p>解释：LRU即最近最少使用算法，向前看找访问串里离缺页那一列最远出现的数替换掉它</p><p>如第四次缺页时，现在有1、3、2，我们往前看访问串依次是3112到这3个数字都出现了，而2是排最后所以把它替换掉。又如第五次缺页，此时有1、3、5，我们向前看访问串依次是315到这3个数字全部出现而最远的是5所以替换掉5</p><p>缺页次数为6，缺页率为6/12=50%</p><p>物理块数为4时，也可以向上图一样画表，但我们可以发现访问串访问的其实就只有1325这四个数，所以一定是只有4次缺页</p><p>即缺页次数为4，缺页率为4/12=33%</p><p>5.设有8页的逻辑空间,每页有1024B,它们被映射到32块的物理存储区中。那么,逻辑地址的有效位是()位,物理地址至少是()位。 （C）</p><p>A.10、11B.12、14C.13、15D.14、16</p><p>答：8页=2<sup>3</sup>，所以页号地址有3位。每页有1024B=2<sup>10</sup>，所以页内偏移量有10位，因此逻辑地址至少要有13位</p><p>物理块大小和页面大小相同，所以物理块大小为1024B，而内存至少要有32个物理块，因此内存至少为32*1024B=2<sup>15</sup>B，因此物理地址至少为15位，不然无法访问内存的所有区域</p><p>6.假定某页式管理系统中,主存为128KB,分成32块,块号为0,1,2,3,…,31。某作业有5块,其页号为0,1,2,3,4,被分别装入主存的3,8,4,6,9块中。有一逻辑地址为[3,70]。试求出相应的物理地址(其中方括号中的第一个元素为页号,第二个元素为页内地址,按十进制计算)(B)</p><p>A.14646B.24646C.24576D.34576</p><p>答：每块大小为128KB/32=4KB，所以每页也为4KB大小</p><p>第3页被装入到第6块中，因此[3,70]对应的物理地址为6*4K+70=24646</p><p>7.©存储管理方式能使存储碎片尽可能少,而且使内存利用率较高。</p><p>A.固定分区B.可变分区C.分页管理D.段页式管理</p><p>答：分页管理与固定分区和可变分区相比碎片明显减少。因为分页管理的碎片都能控制在一个页面大小内，而页面大小通常都较小。</p><p>段页式虽然结合了段式和页式的优点，但一个进程会有很多段，其中一个段对应一张页表每段都会有一个页内碎片，而页式管理中一个进程对应一张页表只有一个页内碎片。</p><p>8.下列选项中,属于多级页表优点的是（D）<br>A.加快地址变换速度<br>B.减少缺页中断次数<br>C.减少页表项所占字节数<br>D.减少页表所占的连续内存空间</p><p>答：对于A，多级页表不仅不会加快地址变换速度反而会减慢速度(多级一级一级查肯定没有单级只查一级快)</p><p>对于B，如果访问过程中多级的页表都不在内存中反而增加了缺页中断次数</p><p>对于C，多级和页表项长度没关系</p><p>对于D，既然多级上面三个都不是它优点那为什么还要发明它呢？因为如果页表太大占了太多连续内存空间，我们可以把它分级使得每一级的页表大小在一定范围内</p><p>9.系统为某进程分配了4个页框,该进程已访问的页号序列为2,0,2,9,3,4,2,8,2,4,8,4,5。若进程要访问的下一页的页号为7,依据LRU算法,应淘汰页的页号是（A）<br>A.2B.3C.4D.8</p><p>答：LRU最近最久未访问算法，现在最后一个访问的是5，向前看然后是4，再接着是8，然后又是4，现在占了3个页框，然后是2占满了4个页框，显然在5482里最久未访问的是2所以替换2</p><p>10.在请求分页系统中,页面分配策略与页面置换策略不能组合使用的是©<br>A.可变分配,全局置换<br>B.可变分配,局部置换<br>C.固定分配,全局置换<br>D.固定分配,局部置换</p><p>答：固定分配：操作系统为每个进程分配一组固定数组的物理块，在进程运行期间不再改变。</p><p>全局置换：可以将操作系统保留的空闲物理块<strong>分配</strong>给缺页的进程，也可以将别的进程保持有的物理块置换到外存，再<strong>分配</strong>给缺页进程。</p><p>局部置换：发生缺页时只能选进程自己的物理块进行置换。</p><p>固定分配后页数是固定的了不能再接受全局置换的分配了，只能自己内部置换</p><p>11.某计算机按字节编址,其动态分区内存管理采用最佳适应算法,每次分配和回收内存后都对空闲分区链重新排序。当前空闲分区信息如下</p><table><thead><tr><th>分区起始地址</th><th>20K</th><th>500K</th><th>1000K</th><th>200K</th></tr></thead><tbody><tr><td>分区大小</td><td>40K</td><td>80K</td><td>100K</td><td>200K</td></tr></tbody></table><p>回收起始地址为60K、大小为140KB的分区后,系统中空闲分区的数量、空闲分区链第一个分区的起始地址和大小分别是（B）<br>A.3、20K、380KB<br>B.3、500K、80KB<br>C.4、20K、180KB<br>D.4、500K、80KB</p><p>答：回收了起始地址为60K大小为140K的分区(60+140=200K)后它会与表中第一个和最后一个分区合并(第一个末尾地址20+40=60K,最后一个起始200K)形成起始地址20K大小为380K的分区。</p><p>但是题目中说了每次回收内存都要重新排序，而采用最佳适应算法，排序后空闲分区由小到大排列。排列后的分区为500K+80K、1000K+100K、20K+380K</p><p>所以空闲分区数量为3，第一个起始为500K大小为80K</p><p>12.某虚拟存储器的用户编程空间共32个页面，每页为1KB，内存为16KB。假定某时刻一用户页表中已调入内存的页面的页号和物理块号的对照表如下：</p><table><thead><tr><th>页号</th><th>物理块号</th></tr></thead><tbody><tr><td>0</td><td>5</td></tr><tr><td>1</td><td>10</td></tr><tr><td>2</td><td>4</td></tr><tr><td>3</td><td>7</td></tr></tbody></table><p>则逻辑地址 0A5D（H）所对应的物理地址是什么？</p><p>答：这道题有两种解法</p><p>(1)：按照一般解法，页号=逻辑地址/页面大小，偏移量=逻辑地址%页面大小</p><p>每页1KB，所以页面大小为1024，逻辑地址0A5D即0000 1010 0101 1101转为十进制后是2653</p><p>页号=2653/1024=2，偏移量=2653%1024=605</p><p>页号2对应的物理块号是4即0100，605转为二进制后是1001 0111 01</p><p>物理地址=物理块号+偏移量 发现4位加10位不满16位前面补0即可</p><p>最终结果为0001 0010 0101 1101 即 125D(H)</p><blockquote><p>也可用十进制计算</p><p>页号2对应的物理块号是4，而每页1KB，因此物理地址为4*1024+605=4701</p><p>转换为二进制为1001001011101，则最终结果为0001 0010 0101 1101 即 125D(H)</p><p>这题偏移量固定占10位，如果十进制转为二进制后不足10位，要补成10位</p></blockquote><p>(2)：事实上我们发现题目中有的条件没用到，我们也可以用下面方法求解</p><p>页面有32个即2<sup>5</sup>，所以要用逻辑地址中5位页号来表示这32个页面。每页1KB所以偏移量占10位</p><p>所以0A5D即0<strong>000 10</strong>10 0101 1101中000 10是页号，10 0101 1101是偏移量</p><p>00010即十进制的2对应的物理块号是4即0100</p><p>所以物理地址=物理块号+偏移量即0100 10 0101 1101 前面补0成16位即125D(H)</p><p>13.在基本分页存储管理系统中，假定页面大小为 1024 字节，每个页表项占用 4 个字节。（题目中所有数据都是十进制）</p><p>(1)若采用一级页表，系统能支持的逻辑空间最多为多少？</p><p>答：一级页表即在一本书中有一页目录，一页纸能写1024个字，每个目录项占4个字，那么一页纸就能有1024/4=256个目录项。而一个目录项对应着书本里的一页，256个目录项对应256页，按字节寻址即一个字节为一个地址，页面大小为1024字节说明一页能表示1024个地址，256页就能表示256*1024=256K个地址即最多为256K</p><p>(2)若采用两级页表，系统能支持的逻辑空间最多为多少？</p><p>答：二级页表能表示256*256个页面即2<sup>16</sup>个页面，一个页面能表示1024个地址即2<sup>10</sup></p><p>所以总共能表示2<sup>16</sup>*2<sup>10</sup>=2<sup>26</sup>=64M</p><p>(3)在两级页表中，现有逻辑地址为 542783，求该地址对应的外层页号（页表页面号）、页号和页内地址。</p><p>答：如下图所示，已知逻辑地址我们先求外层页号。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210105094010970.png"  alt="image-20210105094010970"></p><p>我们可以把二级页表中的页面看成是连续的页面。再给他们编上序号，那542783对应着542783/1024=530，也就是说542783在序号为530的页面中。</p><blockquote><p>其实这个时候问题可以转换为已知逻辑地址为530，求它的页号(对应着本题的外层表号)和页内地址(对应着本题的页号)</p></blockquote><p>这个序号530又在哪个一级页表中呢，一个一级页表项能表示256个页面即序号0-255在一级页表中的0，256-511在一级页表中的1</p><p>那530就在530/256=2及序号为2的页表项里，那在对应的二级页表中的哪一项呢，即530%256=18</p><p>对于页内地址，还是来看二级页表把所有页表当成连续的来看，那542783/1024是所在编号，而542783%1024正是页内地址即63</p><ul><li>当然我们已知外层页号2和页号18，他们所能表示的页面的起始地址是2*256*1024+18*1024=542720，那页内地址就等于542783-542720=63</li></ul><blockquote><p>总结：外层页号=逻辑地址/页面大小/一页有多少页表项 （542783/1024/256）</p><p>页号=逻辑地址/页面大小%一页有多少页表项（542783/1024%256）</p><p>页内地址=逻辑地址%页面大小（542783%1024）</p></blockquote><h1>文件管理</h1><h2 id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2><p>1.文件的属性</p><ul><li>名称</li><li>标识符：各文件标识符唯一，对用户来说透明</li><li>文件类型</li><li>文件位置：指向文件的指针</li><li>大小</li><li>创建时间、上次修改时间</li><li>文件所有者信息</li><li>保护信息：对文件进行保护的访问控制信息</li></ul><p>2.文件的逻辑结构分为两种，如下</p><p>无结构文件：文件内部数据是一系列<strong>二进制流或字符流</strong>，又称流式文件如txt</p><p>有结构文件：由一组相似的记录组成，又称记录式文件，每条记录由若干数据项组成</p><ul><li><p>顺序文件：文件中记录逻辑上一个接一个顺序排列，记录可定长可变长</p><ul><li>串结构：记录之间的顺序与关键字无关（通常按时间排序）</li><li>顺序结构：记录之间的顺序按关键字顺序排序</li><li>可变长记录的顺序文件无法实现随机存取，定长记录可以</li><li>采用顺序结构的定长记录文件可以快速检索(如折半查找)</li><li>缺点：不方便增加/删除记录</li></ul><blockquote><p>类比数据结构的顺序表</p></blockquote></li><li><p>索引文件：建立一张索引表，每个记录对应一个表项，各记录不用保持顺序</p><ul><li>索引表本身就是定长记录的顺序文件，因此支持随机存取</li><li>若索引表按关键字顺序排列，则可支持快速检索</li><li>优点：解决了顺序文件不方便增/删的问题，让不定长记录文件实现随机存取</li><li>缺点：每个记录对应一个索引表项，可能占用很多空间</li></ul><blockquote><p>相当于建了个目录</p></blockquote></li><li><p>索引顺序文件：将记录分组每一组对应一个索引表项</p><ul><li>检查记录时先顺序查索引表，找到分组后再顺序查找分组</li><li>记录过多时可建立多级索引表</li></ul><blockquote><p>先分组再建立目录</p></blockquote></li></ul><p>3.文件目录：一个文件对应一个FCB(文件控制块)，一个FCB就是一个目录项，多个FCB构成文件目录</p><ul><li><p>对目录的操作</p><ul><li>搜索：根据文件名搜索目录，找到对应目录项</li><li>创建文件：需在其所属目录增加一个目录项</li><li>删除文件：从目录中删除对应目录项</li><li>显示目录：用户可请求显示目录内容，如显示目录中所有文件及属性</li><li>修改目录：如文件重命名</li></ul><p>4.目录结构</p><ul><li>单级目录结构：一个系统只有一张目录表，不允许文件重名</li><li>两级目录结构：不同用户的文件可以重名但用户不能对文件分类</li><li>多级(树形)目录结构：各级目录之间用&quot;/&quot;隔开<ul><li>系统根据文件路径找到目标文件</li><li>根目录出发是绝对路径，当前路径出发是相对路径(可减少I/O)</li><li>不同目录下文件可重名，可分类但不方便文件共享</li></ul></li><li>无环图目录结构：在树形目录结构基础上增加一些指向同一节点的有向边，使整个目录成为一个有向无环图<ul><li>为共享结点设置一个共享计数器，计数器为0时才真正删除该结点</li><li>不同于复制文件，其中一个用户修改了数据，所有用户都能看到变化</li></ul></li></ul><p>5.索引结点：FCB的改进，除了文件名之外的所有信息都放到索引结点中，每个文件对应一个索引结点</p><ul><li>目录项中只包含文件名、索引结点指针，每个目录项长度大幅减少</li><li>目录项长度减少每个磁盘块就能放更多目录项，大大提高文件检索速度</li><li>放入外存的索引结点为磁盘索引结点，放入内存后为内存索引结点</li></ul><p>6.文件的物理结构（也就是文件应怎样存在外存中）（相较于逻辑结构这个更容易考）</p><ul><li>补充知识点：类似于内存分页，磁盘中存储单元也会分成一个个磁盘块，通常它与内存块、页面的大小相等</li><li>内存与磁盘之间数据交换以块为单位</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185947141.png"  alt="image-20201223185947141"></p><blockquote><p>连续(顺序)分配可随机存取但不便于文件长度动态增长(<strong>随机存取能力最强</strong>)</p><p>链接便于文件动态长度增长但不可随机存取</p><p>索引既可随机存取也便于文件长度动态增长</p></blockquote></li></ul><p>7.文件逻辑结构对比物理结构</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190025398.png"  alt="image-20201223190025398"></p><p>8.文件的基本操作</p><ul><li><p>创建文件：create系统调用，分配外存空间，创建目录项</p></li><li><p>删除文件：delete系统调用，回收外存空间，删除目录项</p></li><li><p>打开文件：open系统调用，将目录项中的信息复制到内存中的打开文件中，并将<strong>打开文件表的索引号返回给用户</strong></p><ul><li>打开文件后，对文件的操作不用查询目录，<strong>根据内存中的打开文件表操作</strong></li><li>每个进程都有自己的打开文件表，系统有一张总的打开文件表</li><li>进程打开文件表中特有的属性：读写指针，访问权限</li><li>系统打开文件表中特有的属性：打开计数器（有多少进程打开了该文件）</li></ul></li><li><p>关闭文件：close系统调用，将进程中打开文件表的相应表项删除并让系统打开表的打开计数器减1，若减为0则删除系统打开表表项</p></li><li><p>读文件：read系统调用，根据读指针、读入数据量、内存位置<strong>将数据从外存读入内存</strong></p><blockquote><p>根据打开文件得到的文件描述符(索引号)即可指明文件，无需文件名，下同</p></blockquote></li><li><p>写文件：write系统调用，根据写指针、写出数据量、内存位置将文件数据从内存写入外存</p></li></ul><p>9.文件存储空间管理</p><ul><li>补充知识<ul><li>目录区主要存文件目录信息(FCB)，用于磁盘存储空间管理</li><li>文件区用于存放文件数据</li></ul></li><li>空闲表法：空闲盘块表中记录每个连续空闲区的起始盘块号、盘块数<ul><li>分配时可采用首次适应、最佳适应等策略。回收时要注意表项的合并问题</li></ul></li><li>空闲链表法<ul><li>空闲盘块链：以盘块为单位组成一条空闲链<ul><li>分配时从链头依次取出空闲块，回收时将空闲块插到链尾</li></ul></li><li>空闲盘区链：以盘区(多个连续的盘块为一盘区)为单位组成一条空闲链<ul><li>分配时可采用首次适应、最佳适应等策略。回收时要注意相邻盘区的合并问题</li></ul></li></ul></li><li><strong>位示图法</strong>：一个二进制位对应一个盘块<ul><li>位示图中0和1分别代表空闲或不空闲</li></ul></li><li>成组链接法：文件卷的目录区专门一个磁盘块作为超级块，系统启动读入内存<ul><li>UNIX常用策略，适合大型文件系统，理解即可。</li></ul></li></ul><p>10.文件共享：使得多个用户共享同一个文件</p><ul><li><p>基于索引结点的共享方式–硬链接</p><ul><li>各个用户目录项指向同一索引结点，索引结点指向文件</li><li>索引结点中设有链接计数表示当前有几个用户在共享此文件</li><li>用户删除文件，链接计数减1当减为0时才真正删除文件数据和索引结点</li></ul></li><li><p>基于符号链的共享方式–软链接（快捷方式）</p><ul><li><p>在一个Link型文件中记录共享文件的存放路径(如windows快捷方式)</p></li><li><p>操作系统根据存放路径一层一层查找目录，会有多次磁盘I/O，因此比硬链接速度慢</p></li><li><p>即使软链接指向的共享文件已删除，Link型文件依然存在，而通过Link型文件中的路径去找文件会提示失败</p><blockquote><p>例如快捷方式指向的文件被删除了，快捷方式依然存在但双击会提示找不到文件</p></blockquote></li></ul></li></ul><p>11.文件保护：即保护文件数据的安全</p><ul><li>口令保护：为文件设置一个口令，访问文件需要验证口令<ul><li>开销小，但口令放在系统内部不够安全</li></ul></li><li>加密保护：用一个密码对文件加密，访问文件需要提供正确的密码<ul><li>安全性高，但加解密需要耗费一定的时间（如异或加密）</li></ul></li><li>访问控制：用一个访问控制列表(ACL)记录各个(或各组)用户对文件的访问权限<ul><li>对文件的访问类型可分为读/写/执行/删除等（类似linux的文件权限）</li><li>若对某目录设定了访问控制，那目录下的所有文件也要设相同的访问控制</li><li>实现灵活，可实现复杂的文件保护功能</li></ul></li></ul><p>12.文件系统的层次结构</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201227233449615.png"  alt="image-20201227233449615"></p><p>小案例如下</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190209262.png"  alt="image-20201223190209262"></p><p>13.磁盘：由表面涂有磁性物质的圆形盘片组成</p><ul><li>磁道：从里到外一个个小圆圈就是磁道</li><li>扇区：一个磁道被分为一个个扇区，最内侧扇区面积最小数据密度最大</li><li>读写数据：磁头移到目标磁道，盘片旋转，对应扇区从磁头下划过完成读写</li><li>磁盘由多个盘片摞起来，每个盘片有两个盘面</li><li>所有磁头连接在一个磁臂上，只能共进退</li><li>可用柱面号(哪个圆柱)，盘面号(哪一层)，扇区号(一层的哪一个)确定任意一个磁盘块</li></ul><p>14.磁盘的分类</p><ul><li>根据磁头是否可以移动<ul><li>固定头磁盘：每个磁道有一个磁头</li><li>移动头磁盘：每个扇面有一个磁头，磁臂可来回伸缩</li></ul></li><li>根据盘片是否可更换<ul><li>固定盘磁盘</li><li>可换盘磁盘</li></ul></li></ul><p>15.一次磁盘读/写操作所需时间=寻道时间+延迟时间+传输时间</p><ul><li>寻找(寻道)时间：将磁头移到目标磁道所花时间<ul><li>Ts=启动磁臂时间s + 移动一个磁道时间m*移动磁道数目n</li></ul></li><li>延迟(旋转)时间：旋转磁盘到目标扇区的时间<ul><li>转半圈时间，一般求解为转速分之一的一半</li></ul></li><li>传输时间：读/写数据时间<ul><li>转一圈的时间*转多少圈</li></ul></li></ul><p>16.磁盘调度算法</p><ul><li>先来先服务FCFS：按访问请求的先后顺序进行处理</li><li>最短寻找时间优先SSTF：每次优先选择离磁头最近的磁道访问</li><li>扫描算法(电梯算法SCAN)：磁头移动到边缘磁道时才改变磁头方向</li><li>循环扫描算法C-SCAN：只有磁头朝某个方向移动时才会响应请求，到边缘后立即返回起点而不处理任何请求</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228001919894.png"  alt="image-20201228001919894"></p><p>17.减少磁盘延迟时间的方法</p><ul><li>交替编号：让编号相邻的扇区在物理上不相邻<ul><li>原理：读完一个扇区要一段时间才能读下一个扇区若物理上也相邻这段时间内可能就划过目标扇区了</li></ul></li><li>错位命名：让相邻盘面的扇区编号错位，原理同上</li><li>磁盘地址结构的设计为(柱面号,盘面号，扇区号)而不是(盘面号,柱面号,扇区号)<ul><li>原因：在读取连续的物理地址的扇区时，前者不需要移动磁头。</li><li>后者要是柱面号换了磁头就要换磁道，前者盘面号换了只要激活相邻盘面的磁头即可</li></ul></li></ul><p>18.磁盘的管理</p><ul><li>磁盘初始化过程<ul><li>进行低级格式化(物理格式化)，将各个磁道划分扇区，确定扇区检验码位数</li><li>磁盘分区（如C盘、D盘等）</li><li>逻辑格式化：建立文件系统、根目录和用于存储空间管理的数据结构如空闲分区表</li></ul></li><li>引导块：就是启动分区，拥有启动分区的磁盘为启动磁盘或系统磁盘(如C盘)<ul><li>计算机开机时需运行初始化程序(自举程序)完成初始化</li><li>ROM只存放很小的自举程序而完整的自举程序在引导块中</li></ul></li><li>坏块的管理：无法正常使用的扇区就是坏块，系统无法修复因此要标记出来<ul><li>简单的磁盘：逻辑格式化将坏块标记出来，对OS不透明</li><li>复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区，对OS透明</li></ul></li></ul><h2 id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2><p>1.若8个字(字长32位)组成的位示图管理内存,假定用户归还一个块号为100的内存块,它对应位示图的位置为（B）。假定字号、位号、块号均从1开始算起,而不是从0开始。<br>A.字号为3,位号为5B.字号为4,位号为4<br>C.字号为3,位号为4D.字号为4,位号为5</p><p>答：位示图中一位可表示一个内存块</p><p>字长32位，由于都是从1开始所以依次是1-32、33-64、65-96、97-98-99-100</p><p>因此字号是4，位号也是4（注意都从1开始）</p><blockquote><p>这样的题当然可以用公式算，但是由于有时候是0开始有时候1开始，保险起见写下来更稳点</p></blockquote><p>2.现代操作系统是用（C）来实现重名(即允许不同用户的文件可以具有相同的文件名)问题的</p><p>A.重名翻译结构B.建立索引表<br>C.树形目录结构D.建立指针</p><p>答：树形目录结构由一个根目录和若干层子目录组成。这种目录结构一是能够解决文件重名问题,即不同的目录可以包含相同的文件名或目录名;二是能够解决文件多而根目录容量有限带来的问题。</p><p>3.文件系统采用两级索引分配方式。若每个磁盘块的大小为1KB,每个盘块号占4B,则该系统中单个文件的最大长度是(A)。<br>A.64MBB.128MBC.32MBD.都不对</p><p>答：每个磁盘块最多有1KB/4B=256个索引项，两级索引可表示256*256个磁盘块，这些磁盘块可以占256*256*1KB=64MB大小，因此单个文件最大长度为64MB</p><p>4.下列算法中,用于磁盘调度的是©。<br>A.时间片轮转法B.LRU算法<br>C.最短寻道时间优先算法 D.高优先级算法</p><p>答：时间片轮转法是进程调度算法,LRU算法是页面淘汰算法。</p><p>最短寻道时间优先算法是磁盘调度算法,髙优先级算法是进程调度和作业调度的算法。</p><blockquote><p>之所以记录这道题是提醒大家由于学了很多调度算法不要弄混了</p><p>单看这道题，从C的寻道也能看出它和磁盘有关(磁道)</p></blockquote><p>5.如果当前读写磁头正在53号柱面上执行操作,依次有4个等待访问的请求,柱面号依次为98、37、124、65,当采用©算法时,下一次磁头才可能到达37号柱面。<br>A.先来先服务B.最短寻道时间优先<br>C.电梯调度(初始磁头移动方向向着小磁道方向)<br>D.循环扫描(磁头移动方向向着大磁道方向)</p><p>答：先来先服务FCFS先来的先访问所以下一次访问98</p><p>最短寻道时间优先SSTF先访问寻道时间最短的这其中65离53最近</p><p>电梯调度SCAN向小磁道移动而只有37比53小满足题意</p><p>循环扫描C-SCAN向大磁道移动下一个访问65</p><blockquote><p>注意题目选项可能只给出英文要知道对应的中文及算法思想</p></blockquote><p>6.下面关于文件的叙述中,错误的是（D）<br>I.打开文件的主要操作是把指定文件复制到内存指定的区域</p><p>Ⅱ.对一个文件的访问,常由用户访问权限和用户优先级共同限制<br>Ⅲ.文件系统采用树形目录结构后,对于不同用户的文件,其文件名应该不同<br>Ⅳ.为防止系统故障造成系统内文件受损,常采用存取控制矩阵方法保护文件</p><p>A.仅ⅡB.仅Ⅰ、Ⅲ<br>C.仅I、Ⅲ、Ⅳ D.I、Ⅱ、Ⅲ、Ⅳ</p><p>答：Ⅰ错误,系统调用open把文件的信息目录放到打开文件表中并将文件编号返回给用户。</p><p>读取文件才会把指定文件复制到内存指定的区域</p><p>Ⅱ错误,对一个文件的访问,常由用户访问权限和文件属性共同限制。<br>Ⅲ错误,文件系统采用树形目录结构后,对于不同用户的文件,其文件名可以不同,也可以相同。<br>Ⅳ错误,常采用备份的方法保护文件,而存取控制矩阵的方法是用于多用户之间的存取权限保护。</p><p>7.在一个文件被用户进程首次打开的过程中,操作系统需做的是（B）<br>A.将文件内容读到内存中B.将文件控制块读到内存中<br>C.修改文件控制块中的读写权限</p><p>D.将文件的数据缓冲区首指针返回给用户进程</p><p>答：一个文件被用户进程首次打开即被执行了Open操作,会把文件的FCB调入内存,而不会把文件的内容读到内存中,只有进程希望获取文件内容的时候才会读入文件内容。</p><blockquote><p>这个类似的题经常考，考点就是Open函数是否将文件内容读到了内存</p><p>助记：想一下平常编程都是先open打开文件然后再读取文件内容，并不是open打开文件就直接获得了内容</p></blockquote><p>8.在文件的索引结点中存放直接索引指针10个,一级和二级索引指针各1个。磁盘块大小为1KB,每个索引指针占4B。若某文件的索引结点已在内存中,则把该文件偏移量（按字节编址）为 1234和 307400 处所在的磁盘块读入内存，需访问的磁盘块个数分别是（B）</p><p>A.1,2B.1,3C.2,3D.2,4</p><p>答：注意索引结点存的是指针，一级索引就是根据这个指针找一级索引表，根据一级索引表的内容访问磁盘。而直接索引指针存放的就是数据的地址</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201231093132662.png"  alt="image-20201231093132662"></p><blockquote><p>如上图所示，一级索引需根据索引指针先访问一次一级索引表(存在磁盘中)再根据表内容第二次访问磁盘</p></blockquote><p>10个直接索引指针指向的数据块大小为10×1KB=10KB;<br>每个索引指针占4B,则每个磁盘块可存放1KB/4B=256个索引指针，索引指针指向的数据块大小为256×1KB=256KB;<br>二级索引指针指向的数据块大小为256×256×1KB=2<sup>16</sup>=64MB。</p><p>按字节编址,偏移量为1234时,因为1234B&lt;10KB,则由直接索引指针可得到其所在的磁盘块地址。然后再根据磁盘块地址访问。要注意的是文件的索引结点已在内存中即直接索引指针也在内存中，访问直接索引指针访问的是内存而不是磁盘，故仅需1次访盘即可。</p><p>偏移量为307400时,因为10KB+256KB&lt;307400&lt;64MB,可知该偏移量的内容在二级索引指针所指向的某个磁盘块中,索引结点已在内存中,先根据索引结点的指针一次访盘访问一级索引表，再根据一级索引表的内容二次访盘访问二级索引表，最后根据二级索引表的内容即文件的真正地址三次访盘取得数据</p><p>9.文件系统用位图法表示磁盘空间的分配情况,位图存于磁盘的32~127号块中,每个盘块占1024B,盘块和块内字节均从0开始编号。假设要释放的盘块号为40962,则位图中要修改的位所在的盘块号和块内字节序号分别是©<br>A.81、1B.81、2C.82、1D.82、2</p><p>答：409612/(1024*8)=50    409612%(1024*8)=12</p><p>除后取整为50说明它相对起始块偏移了五十个块，块号为32+50=82</p><blockquote><p>如果取整为1块号为32+1，取整为2块号为32+2，建议试一下保险</p></blockquote><p>取模为12，12是求得的位号，而问的是字节序号，1字节为8位，块内字节又从0开始所以它的块内字节序号为1</p><p>10.某文件系统的簇和磁盘扇区大小分别为1KB和512B。若一个文件的大小为1026B,则系统分配给该文件的磁盘空间大小是（D）<br>A.1026BB.1536BC.1538BD.2048B</p><p>答：绝大多数操作系统为改善磁盘访问时间,以簇为单位进行空间分配,该文件大小为1026B&gt;1024B=1KB,故分配给其两个簇的大小,即2048B。</p><blockquote><p>簇：由若干个连续的磁盘块组成</p></blockquote><p>11.某文件系统中,针对每个文件,用户类别分为4类:安全管理员、文件主、文件主的伙伴、其他用户;访问权限分为5类:完全控制、执行、修改、读取、写入。若文件控制块中用二进制位串表示文件权限,为表示不同类别用户对一个文件的访问权限,则描述文件权限的位数至少应为（D）</p><p>A.5B.9C.12D.20</p><p>答：可以把用户访问权限抽象成一个矩阵,行代表用户,列代表访问权限。这个矩阵有4行5列,1代表tue,0代表 false,所以需要20位,选D</p><blockquote><p>可能会误认为4*5=20而2<sup>5</sup>=32所以用5位就够了</p><p>其实不然，如果20位的话那是一类用户只有一个权限的时候，而比如&quot;其他用户&quot;可能同时会有修改、读取、写入的权限那你用20位怎么表示这个状态？</p></blockquote><p>12.若文件f1的硬链接为f2,两个进程分别打开f1和f2,获得对应的文件描述符为fd1和fd2,则下列叙述中,正确的是(B)</p><p>I.f1和f2的读写指针位置保持相同Ⅱ.f1和f2共享同一个内存索引结点<br>Ⅲ.fd1和fd2分别指向各自的用户打开文件表中的一项<br>A.仅ⅢB.仅ⅡⅢC.仅I、ⅡD.I、Ⅱ和Ⅲ</p><p>答：硬链接各个用户目录项指向同一索引结点，索引结点指向文件，所以f1和f2共享一个内存索引结点</p><p>硬链接在用户看来好像是自己创建的文件一样，如甲可读文件头同时乙读文件尾，所以读写指针不可能一样。</p><p>13.某磁盘文件系统使用链接分配方式组织文件,簇大小为4KB。目录文件的每个目录项包括文件名和文件的第一个簇号,其他簇号存放在文件分配表FAT中。</p><p>（1）假定目录树如下图所示，各文件占用的簇号及顺序如下表所示，其中dir、dir1是目录，file1、file2是用户文件。请给出所有目录文件的内容。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/7366756_1525401510755_300F1006E274A3A81D6610B98EFFED0C"  alt="image-20201231093132664"></p><p>答：两个目录文件的dir和dir1的内容如下</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/7366756_1525401555132_694A264BD5DAEC0B990DC0CFE4BFEB36"  alt="image-20201231093132666"></p><blockquote><p>注意目录项只包括文件的第一个簇号</p></blockquote><p>（2）若FAT的每个表项仅存放簇号，占2个字节，则FAT的最大长度为多少字节？该文件系统支持的文件长度最大是多少？</p><p>答：FAT即文件分配表，簇号占2个字节即16bit，全1时是最大表项数即FAT表中最多允许2<sup>16</sup>个表项。</p><p>一个FAT文件最多含有2<sup>16</sup>个簇(表项全不为空时)，而一个簇号占2个字节，所以FAT长度=2<sup>16</sup>*2B=128KB</p><blockquote><p>FAT即文件分配表，FAT的最大长度即这个表的最大长度就等于多少个表项*每个表项的长度</p></blockquote><p>文件的最大长度就等于一个FAT文件可表示的最大簇数*一个簇的大小即2<sup>16</sup> * 4KB=256MB</p><p>（3）系统通过目录文件和FAT实现对文件的按名存取，说明file1的106、108两个簇号分别存放在FAT的哪个表项中。</p><p>答：FAT的每个表项存放的是下一个簇号(题目说是链接分配)，所以file1的簇号106存放在FAT的100号表项里，而簇号108存放在FAT的106号表项里</p><p>（4）假设仅FAT和dir目录文件已读入内存，若需将文件dir/dir1/file1的第5000个字节读入内存，则要访问哪几个簇？</p><p>答：先在dir目录文件里找到dirl的簇号,然后读取48号簇,得到dirl目录文件,接着找到file1的第一个簇号,据此在FAT里查找fiel的第5000B所在的簇号,最后访问磁盘中的该簇。</p><p>因此,需要访问目录文件dirl所在的48号簇,及文件flel的106号簇(5000B&gt;簇大小4KB所以访问第二个簇)。</p><p>14.在某个文件系统中，每个盘块为 512 字节，文件控制块占 64 个字节，其中文件名占 8 个字节。如果索引结点编号占 2 个字节，对一个存放在磁盘上的 256 个目录项的目录，试比较引入索引结点前后，为找到其中一个文件的FCB，平均启动磁盘的次数。</p><p>答：：引入索引节点前，每个目录项中存放的是对应文件的 FCB，故 256 个目录项的目录总共需要占用 256×64/512=32 个盘块。故在该目录中检索到一个文件平均启动磁盘次数为 (1+32)/2=16.5</p><p>引入索引节点后，每个目录项中只需<strong>存放文件名和索引节点的编号</strong>，因此 256 个目录项的目录总共需要占用 256×(8+2)/512=5 个盘块。因此，找到匹配的目录项平均需要启动 3 次磁盘；而得到索引结点编号后还需启动磁盘将<strong>对应文件的索引结点读入内存</strong>，故平均需要启动磁盘 4 次。</p><h1>设备管理</h1><h2 id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2><p>1.I/O设备：可以将数据输入到计算机或者可以接收计算机输出数据的外部设备</p><ul><li>按使用特性分类<ul><li>人机交互设备：用于人机交互传输速度慢如鼠标、键盘、打印机</li><li>存储设备：用于数据存储数据传输速度快如移动硬盘</li><li>网络通信设备：用于网路通信传输速度在上述二者之间，如调制解调器</li></ul></li><li>按传输速率分类<ul><li>低速设备：传输速率为每秒几个到几百字节，如鼠标、键盘</li><li>中速设备：传输速率为每秒数千到上万字节，如激光打印机</li><li>高速设备：传输速率为每秒数千到千兆字节，如磁盘</li></ul></li><li>按信息交换的单位分类<ul><li>块设备：处理信息以字符块(512B~4KB)为单位，可寻址，如磁盘</li><li>字符设备:处理信息以字符为单位，不可寻址，如鼠标、键盘</li></ul></li><li>按设备的共享属性分类<ul><li>独占设备：同一时刻只允许一个进程使用，如打印机</li><li>共享设备：允许多个进程同时访问，如磁盘</li><li>虚拟设备：通过虚拟技术让一个独占设备逻辑上被多个进程同时使用，如虚拟技术后的打印机</li></ul></li></ul><p>2.I/O控制器：CPU可控制I/O控制器，由I/O控制器控制设备</p><ul><li>主要功能<ul><li>接收和识别CPU发出的命令：要有控制寄存器</li><li>向CPU报告设备的状态：要有状态寄存器</li><li>数据交换：要有数据寄存器暂存输入/输出数据</li><li>地址识别：由I/O逻辑实现</li></ul></li><li>组成<ul><li>CPU与控制器之间的接口：实现控制器与CPU之间的通信</li><li>I/O逻辑：负责识别CPU发出的命令，并向设备发出命令</li><li>控制器与设备之间的接口：实现控制器与设备之间的通信</li></ul></li><li>两种寄存器编址方式<ul><li>内存映像I/O：控制器中的寄存器与内存统一编址<ul><li>简化了指令，可以采用对内存进行操作的指令来操作控制器</li></ul></li><li>寄存器独立编址：控制器中的寄存器独立编址<ul><li>需要设置专门的指令来操作控制器</li></ul></li></ul></li></ul><p>3.IO控制方式：即用什么样的方式来控制I/O设备的数据读/写</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190614810.png"  alt="image-20201223190614810"></p><p>4.I/O软件层次</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190722845.png"  alt="image-20201223190722845"></p><blockquote><p>用户发出I/O请求系统从上到下处理(一定要记住这个顺序可能考选择)</p><p>助记：俩软件(先用户再设备)，俩程序(先设备再中断)</p></blockquote><p>5.I/O核心子系统：上图中设备独立性软件、设备驱动程序和中断处理程序属于OS的内核部分即I/O核心子系统。提供的服务有以下几种</p><ul><li>I/O调度：用某种算法确定一个好的顺序来处理各个I/O请求，如磁盘调度</li><li>高速缓存与缓冲区：即缓冲区管理，详见下</li><li>设备分配与回收</li><li>假脱机(SPOOLing)技术</li></ul><p>6.高速缓存与缓冲区：缓冲区是一个存储区域，一般<strong>用内存作为缓冲区</strong></p><ul><li><p>缓冲区的作用</p><ul><li>缓和<strong>CPU和I/O设备</strong>速度不匹配的原因</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li><li>解决数据粒度不匹配的问题</li><li>提高CPU与I/O设备之间的并行性</li></ul></li><li><p>单缓冲：操作系统在主存中为其分配一个缓冲区(通常为一个块大小)</p><ul><li>设备–&gt;缓冲区时间为T,缓冲区–&gt;工作区时间为M,CPU处理时间为C。下同</li><li>分析问题的初始状态：工作区满，缓冲区空</li><li>处理一块数据平均耗时MAX(C,T)+M</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201230124752840.png"  alt="image-20201230124752840"></p></li><li><p>双缓冲：操作系统在主存中为其分配两个缓冲区</p><ul><li>分析问题的初始状态：工作区空，一个缓冲区满，另一个为空</li><li>处理一块数据平均耗时MAX(T,C+M)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201230124956121.png"  alt="image-20201230124956121"></p></li><li><p>循环缓冲区：将多个大小相等的缓冲区链接成一个循环队列</p><ul><li>下图中橙色表示已充满数据的缓冲区，绿色表示空缓冲区</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201230125322834.png"  alt="image-20201230125322834"></p></li><li><p>缓冲池：由系统中共用的缓冲区组成</p><ul><li>按使用状况可以分为<ul><li>空缓冲队列</li><li>装满输入数据的缓冲队列(输入队列)</li><li>装满输出数据的缓冲队列(输出队列)</li></ul></li><li>按实际运算中的功能设置了以下四中缓冲区<ul><li>用于收容输入数据的工作缓冲区</li><li>用于提取输入数据的工作缓冲区</li><li>用于收容输出数据的工作缓冲区</li><li>用于提取输出数据的工作缓冲区</li></ul></li></ul></li></ul><p>7.设备的分配与回收</p><ul><li>应考虑的因素<ul><li>固有属性：独占设备、共享设备、虚拟设备(SPOOLing)</li><li>分配算法：先来先服务、优先级高者优先、段任务优先…</li><li>安全性：安全分配方式(一个进程只能用一个设备)、不安全分配方式(可用多个设备)</li></ul></li><li>两种分配方式<ul><li>静态分配：进程运行前分配所有所需资源，结束后归还</li><li>动态分配：进程运行过程中动态申请设备资源</li></ul></li><li>设备分配管理中的数据结构<ul><li>背景知识：一个通道可控制多个设备控制器，一个设备控制器可控制多个设备</li><li>设备控制表(DCT)：系统为每个设备配置一张DCT，用于记录设备情况<ul><li>关键字段：设备类型、设备标识符、设备状态、指向COCT的指针、等待队列指针</li></ul></li><li>控制器控制表(COCT)：每个设备控制器对应一张COCT，OS根据COCT的信息对控制器操作和管理<ul><li>关键字段：控制器状态、指向CHCT的指针、等待队列指针</li></ul></li><li>通道控制表：每个通道对应一张CHCT，系统根据CHCT信息对通道操作和管理<ul><li>关键字段：状态、等待队列指针</li></ul></li><li>系统设备表(SDT)：记录了全部设备的情况，每个设备对应一个表目<ul><li>关键字段：类型、标识符、设备控制表(DCT)、驱动程序入口</li></ul></li></ul></li><li>设备分配的步骤<ul><li>根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配<br>给进程</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进<br>程</li></ul></li></ul><p>8.假脱机(SPOOLing)技术：用软件的方式模拟脱机技术，<strong>可将独占式设备改造成共享式设备</strong></p><ul><li>组成<ul><li>输入井和输出井：模拟脱机输入/输出时的磁带</li><li>输入缓冲区和输出缓冲区：内存中的缓冲区，输入/输出时的中转站</li><li>输入进程和输出进程：模拟脱机输入/输出时的外围控制机</li></ul></li><li>技术特点<ul><li>提高了I/O速度</li><li>设备没有分配给任何进程</li><li>实现了虚拟设备功能</li><li>除了是一种速度匹配技术外还是一种虚拟设备技术</li></ul></li></ul><h2 id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2><p>1.下列关于 SPOOLing的叙述中,不正确的是（D）<br>A. SPOOLing系统中必须使用独占设备<br>B. SPOOLing系统加快了作业执行的速度<br>C. SPOOLing系统使独占设备变成了共享设备<br>D. SPOOLing系统利用了处理器与通道并行工作的能力</p><p>答：SPOOLing是操作系统中采用的一种将独占设备改造为共享设备的技术,它有效减少了进程等待读入/读出信息的时间,加快了作业执行的速度。</p><p>不过,无论有没有通道,SPOOLing系统都可以运行,因此D选项是不对的。</p><p>2.在如下几种类型的系统中,（B）采用忙等待I/O是合适的。<br>a.专门用来控制单IO设备的系统<br>b.运行一个单任务操作系统的个人计算机<br>C.作为一个负载很大的网络服务器的工作站<br>A. aB. a、bC. b、cD. c</p><p>答：忙等待I/O就是CPU等待I/O的完成的时候，进程不能继续执行。</p><p>对于a和b只有单个设备或单个任务，执行I/O时OS不会处理其它事情</p><p>而对于c负载很大有个I/O请求就CPU就停止工作了显然是不合理的，必须让CPU具有并行处理的能力</p><p>3.在采用 SPOOLing技术的系统中,用户暂时未能打印的数据首先会被送到(A)<br>存储起来。<br>A.磁盘固定区域B.内存固定区域<br>C.终端   D.打印机</p><p>答：采用 SPOOLing技术的系统中,用户的打印数据首先由内存经过缓冲区传递至输出井暂存,等输出设备(打印机)空闲时再将输出井中的数据经缓冲区传递到输出设备上。而输出井通常是在磁盘上开辟的一块固定存储区。</p><p>4.下列有关设备独立性的说法中,正确的是(B)。<br>A.设备独立性是指I/O设备具有独立执行I/O功能的一种特性<br>B.设备独立性是指用户程序独立于具体物理设备的一种特性<br>C.设备独立性是指能够实现设备共享的一种特性<br>D.设备独立性是指设备驱动程序独立于具体物理设备的一种特性</p><p>答：设备独立性是指用户程序独立于具体物理设备的一种特性。其他选项都不是设备独立性的描述。</p><p>D选项中设备驱动程序是不可能独立于具体物理设备的,因为驱动程序就是为具体物理设备而专门定制的。</p><p>5.通道又称I/O处理器,用于实现(A)之间的信息传输<br>A.内存与外设B.CPU与外设C.内存与外存D.CPU与外存</p><p>答：在设置了通道后,CPU只需向通道发送一条I/O指令。通道在收到该指令后,便从内存中取岀本次要执行的通道程序,然后执行该通道程序。</p><p>仅当通道完成规定的I/O任务后,才向CPU发出中断信号。因此,通道用于完成内存与外设的信息传输。</p><p>6.在 SPOOLing系统中,用户进程实际分配到的是(B)<br>A.用户所要求的外设  B.内存区,即虚拟设备<br>C.设备的一部分存储区D.设备的一部分空间</p><p>答：通过 SPOOLing技术可将一台物理设备转换为多台虚拟设备,允许多个用户共享一台物理设备。所以在 SPOOLing系统中并不是将物理设备分配给用户进程,而仅仅是虚拟设备。</p><p>如采用SPOOLing技术将磁盘的一部分作为公共缓冲区以代替打印机,用户对打印机的操作实际上是对磁盘的存储操作。</p><p>7.下列关于设备驱动程序的叙述中,正确的是(A)<br>I.与设备相关的中断处理过程是由设备驱动程序完成的<br>Ⅱ.由于驱动程序与I/O设备(硬件)紧密相关,故必须全部用汇编语言书写<br>Ⅲ.磁盘的调度程序是在设备驱动程序中运行的<br>Ⅳ.一个计算机系统配置了2台同类绘图机和3台同类打印机,为了正确驱动这些设备,系统应该提供5个设备驱动程序<br>A.仅I、ⅢB.仅Ⅱ、ⅢC.仅I、Ⅲ、ⅣD.I、Ⅱ、III、Ⅳ</p><p>答：Ⅰ正确,设备驱动程序的低层部分在发生中断时调用,以进行中断处理。<br>II错误,由于驱动程序与硬件紧密相关,因而其中的一部分必须用汇编语言书写,其他部分则可以用高级语言(如CC++)来书写。<br>Ⅲ.正确<br>Ⅳ.错误,因为绘图机和打印机属于两种不同类型的设备,系统只要按设备类型配置设备驱动程序即可,即应提供2个设备驱动程序。</p><p>8.(A)是操作系统中采用的以空间换取时间的技术。<br>A.SPOOLing技术B.虚拟存储技术C.覆盖与交换技术D.通道技术</p><p>答：SPOOLing技术是操作系统中用的以空间换取时间的技术(用内存换I/O速度)</p><p>虚拟存储技术和覆盖与交换技术是为了扩充内存容量，它们都属于以时间换空间的技术(处理需要时间但处理后空间变大了)<br>而通道技术是为了提高设备速度，增加了硬件,不属于这两者中的任何一种</p><p>9.<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210101161719481.png"  alt="image-20210101161719481"></p><p>答：单缓冲，当上一个磁盘块从缓冲区读入用户区完成时下一个磁盘块才能开始读入。如下图所示</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210101162235813.png"  alt="image-20210101162235813"></p><p>所以最短时间为100+5+100+5+90=300</p><p>10.下列关于 SPOOLing技术的叙述中,错误的是（D）<br>A.需要外存的支持<br>B.需要多道程序设计技术的支持<br>C.可以让多个作业共享一台独占设备<br>D.由用户作业控制设备与输入输出井之间的数据传送</p><p>答：SPOOLing是利用专门的外围控制机,将低速IO设备上的数据传送到高速磁盘上;或者相反。</p><p>SPOOLing的意思是外部设备同时联机操作,又称为假脱机输入输出操作,是操作系统中采用的一项将独占设备改造成共享设备的技术。高速磁盘即外存,A正确。<br>SPOOLing技术需要输入输出操作,单道批处理系统无法满足,B正确。</p><p>SPOOLing技术实现了将独占设备改造成共享设备的技术,C正确。</p><p>设备与输入出井之间数据的传送是由系统实现的,D错误。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;作者：夏日&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思维导图快速复习见我这篇博客：&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>网络安全期末总结</title>
    <link href="https://zss192.github.io/2022/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>https://zss192.github.io/2022/11/14/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2022-11-14T09:36:00.000Z</published>
    <updated>2022-11-14T09:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>作者：夏日</p><p>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><h1>题型</h1><p>选择题：20*1</p><p>判断题：5*2</p><p>简答题：包括问答题和分析题 8*5</p><p>应用题：15*2</p><h1>选择题</h1><blockquote><p>选择题不必每个都记忆特别深，有印象能选出来就行。17个知识点包含所有选择题考点</p></blockquote><h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><p>1.网络安全确保的5个维度（预测挖一个空让选）</p><p>保密性、完整性、可用性、可控性、可审查性。</p><p>2.网络安全包括哪些内容？</p><p>可能让选<strong>系统</strong>上的安全和<strong>信息本身</strong>的安全</p><p>也可能让选实体安全（物理安全）、系统安全、运行安全、管理安全、应用安全。</p><p>3.常见攻击方式（了解名词的意思即可，预测给出一个描述让选是什么攻击方式）</p><ul><li>缓冲区溢出：是指通过向缓冲区写入超出其长度的大量文件或信息内容，造成缓冲区溢出（当计算机向缓冲区内存储调入填充数据时，超过了缓冲区本身限定的容量，致使溢出的数据覆盖在合法数据上），破坏程序的堆栈，使程序转而执行其他指令或使得攻击者篡改程序运行的控制权。</li><li>DOS攻击：黑客利用合理的服务请求来占用过多的服务资源，使合法用户无法得到服务的响应，直至瘫痪而停止提供正常的网络服务的攻击方式。(一对一)</li><li>DDOS攻击：指借助于客户/服务器技术，将网络中的多个计算机联合作为攻击平台，对一个或多个目标发动DOS攻击，从而成倍的提高拒绝服务攻击的威力。(多对一或多对多)</li><li>字典攻击：字典穷举法，此法采用破解工具可自动从定义的字典中取出单词作为用户的口令尝试登录，如果口令错误，就按序列取出下一个单词再次尝试，直到找出正确的密码或字典中的单词测试完成为止，这种方法不受网段限制。</li><li>非授权访问：指未经授权使用网络资源或以未授权的方式使用网络资源，主要包括非法用户进入网络或系统进行违法操作和合法用户以未授权的方式进行操作</li><li>网络监听：通过某种手段监视网络状态、数据流及网络上传输信息的行为(网卡开<strong>混杂模式</strong>)</li><li>端口扫描：就是逐个对一段端口或指定的端口进行扫描。通过扫描结果可以知道一台计算机上都提供了哪些服务，然后就可以通过所提供的这些服务的己知漏洞就可进行攻击。</li></ul><p>4.HTTPS工作原理（老师提示可用推理排除法）</p><p>HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过<strong>传输加密</strong>和<strong>身份认证</strong>保证了传输过程的安全性。HTTPS 在HTTP 的基础下<strong>加入SSL层</strong>，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。</p><p>HPPTS是HTTP+SSL/TCP的简称。</p><p>TLS（传输层安全）是更为安全的升级版 SSL。</p><p>将一个网站Web应用启用SSL技术来加密，并使用HTTPS协议进行传输</p><p><strong>SSL协议提供的服务主要有：</strong></p><p>1）认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>2）加密数据以防止数据中途被窃取；</p><p>3）维护数据的完整性，确保数据在传输过程中不被改变。</p><p>服务器认证阶段：</p><p>1）客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；</p><p>2）服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；</p><p>3）客服根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；</p><p>4）服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p><p>用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。</p><p>5.对称加密非对称加密</p><ul><li><strong>对称</strong>加密：加密过程和解密过程都使用<strong>同一个密钥</strong></li><li>非对称加密：加密和解密使用不同的密钥即公钥和私钥<ul><li>加密信息传输：公钥加密，私钥解密</li><li>签名：私钥加密，公钥解密</li></ul></li></ul><p>6.网络安全的保障包括哪些？</p><p>网络安全<strong>策略</strong>、网络安全<strong>政策和标准</strong>、网络安全<strong>管理</strong>、网络安全<strong>运作</strong>、网络安全<strong>技术</strong>。</p><p>7.网络常用的加密有哪些？</p><p><strong>结点</strong>(路由器、交换机、服务器、终端…)的加密、<strong>端到端</strong>的加密、<strong>链路</strong>加密</p><p>8.数据存储的加密</p><p>利用<strong>系统本身</strong>的加密(和OS有关)、<strong>密码</strong>加密、<strong>密钥</strong>加密</p><p>9.网络安全的管理规范</p><p>大概要问网络安全管理规范是不是法律上的要求或者是有什么要求，实际上不是法律或什么，他是有一定的强制力</p><p>10.防火墙位置、功能，能干嘛，不能干嘛</p><p>防火墙是位于<strong>多个网络之间</strong>，通过执行<strong>访问控制策略</strong>保护网络安全的系统。</p><p>防火墙的主要功能有：建立一个集中的监视点、隔绝内外网络，保护内部网络、强化网络安全策略、有效记录和审计内外网络之间的活动。</p><p>防火墙可以与入侵检测系统互动，可在线升级，划分不同安全级别的区域，可实时警告等。不可以防范不经过防火墙的攻击，不能防止利用服务器系统漏洞进行的攻击，不能防止本身的安全漏洞威胁等。</p><p>以前是硬件实现，现在是软件实现(利用NFV(网络功能虚拟化)技术即用软件实现硬件功能)，比较方便调整资源，流量大就多启动几台机器，需求少就关停部分机器。</p><p><strong>防火墙在网络的边界，不能防御网络内部的流量</strong></p><p>11.网络中常用命令（重点在于输入命令能看到什么）</p><ul><li>ping：使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常（<strong>大概率考这个</strong>）</li><li>ipconfig命令：显示所有TCP/IP网络配置信息、刷新动态主机配置协议和域名系统DNS设置。</li><li>netstart：显示活动的连接、计算机监听的端口、以太网统计信息、IP路由表和ipv4统计信息。</li></ul><p>12.凯撒加密属于什么样的加密方法</p><p>使用<strong>代换</strong>技术：即将明文中的每个元素映射为另一个元素的技术</p><p>属于<strong>古典对称</strong>密码：加密和解密都是同一个密钥</p><p>大致思想就是每个字母都有一个偏移量，如偏移量为2，加密时就把a换成c，b换成d这种。</p><p>解密只需逆操作即可如e解密成c</p><p>13.IP地址欺诈</p><p>IP地址欺骗是指行动产生的IP数据包为伪造的源IP地址，以便冒充其他系统或发件人的身份。这是一种黑客的攻击形式，黑客使用一台计算机上网,而借用另外一台机器的IP地址,从而冒充另外一台机器与服务器打交道。</p><p>源IP地址欺骗：<strong>盗用他人的IP</strong>地址进行欺骗攻击。</p><p>为什么会出现IP地址欺诈：<strong>没对源IP验证</strong></p><p>14.数据备份的方式</p><p>完全备份：对所有数据都进行备份；</p><p>增量备份：备份自从上次备份操作以来新改变的数据</p><p>15.如何进行系统恢复（就选下面加粗的内容）</p><p>按照备份时部分或全部<strong>正常启动运行的数值特征</strong>来进行运作</p><p>16.实验中的嗅探攻击用wireshark软件，网卡需要开启<strong>混杂模式</strong>来捕获信息</p><p>17.计算机病毒的特征</p><p>计算机病毒概念：具有影响或破坏服务器、计算机、手机或平板电脑等系统正常运行的功能、人为编制的一组指令或程序。</p><p><strong>病毒的特征：病毒具有传播性、隐蔽性、潜伏性、触发及控制性、影响破坏性、多态及不可预见性。</strong></p><p>木马概念：木马是一些具备破坏和删除文件、发送密码、记录键盘与攻击DOS等特殊功能的后门程序。</p><p>蠕虫概念：蠕虫病毒并不依赖宿主寄生，而是通过复制自身在网络环境下进行传播。破坏性更强。是一组计算机指令或者程序代码。</p><blockquote><p>后台自动安装垃圾软件的软件不属于木马病毒属于流氓软件</p></blockquote><h2 id="书上选择题-大概率考原题"><a class="header-anchor" href="#书上选择题-大概率考原题">¶</a>书上选择题(大概率考原题)</h2><blockquote><p>画对勾的为预计会考原题的题目</p></blockquote><h3 id="第一章"><a class="header-anchor" href="#第一章">¶</a>第一章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107155858592.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107160017237.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第二章"><a class="header-anchor" href="#第二章">¶</a>第二章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107160123630.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2021010716021554.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第三章"><a class="header-anchor" href="#第三章">¶</a>第三章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107160501382.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第四章"><a class="header-anchor" href="#第四章">¶</a>第四章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107160557648.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107160644200.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第五章"><a class="header-anchor" href="#第五章">¶</a>第五章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/202101071607381.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2021010716082627.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第六章"><a class="header-anchor" href="#第六章">¶</a>第六章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107160913926.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第七章"><a class="header-anchor" href="#第七章">¶</a>第七章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161004417.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161042662.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第八章"><a class="header-anchor" href="#第八章">¶</a>第八章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161134273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第九章"><a class="header-anchor" href="#第九章">¶</a>第九章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161220114.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161257803.jpg"  alt="在这里插入图片描述"></p><h3 id="第十章"><a class="header-anchor" href="#第十章">¶</a>第十章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161414908.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161452526.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第十一章"><a class="header-anchor" href="#第十一章">¶</a>第十一章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161542644.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161632691.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="第十二章"><a class="header-anchor" href="#第十二章">¶</a>第十二章</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161725703.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210107161754493.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1>判断题</h1><p>没说考什么，但提示选对的多一点。(推测4对1错)</p><h1>简答题</h1><blockquote><p>每一题必须全部背会，原理概念性问题写对大致思路即可</p></blockquote><h2 id="必考题"><a class="header-anchor" href="#必考题">¶</a>必考题</h2><p>1.DoS和DDoS是什么，它们的区别是什么</p><p>DoS攻击：即拒绝服务攻击，是指黑客利用合理的服务请求来占用过多的服务资源，使合法用户无法得到服务的响应，直至瘫痪而停止提供正常的网络服务的攻击方式。</p><p>DDoS攻击：即分布式拒绝服务攻击，是指借助于客户/服务器技术，将网络中的多个计算机联合作为攻击平台，对一个或多个目标发动DOS攻击，从而成倍的提高拒绝服务攻击的威力。</p><p>区别：DoS攻击是利用一台计算机攻击目标，是一对一的关系。当攻击目标性能指标不高时效果明显，否则将达不到攻击效果。</p><p>而DDoS是DoS攻击基础之上产生的一种新的攻击方式，通过控制成百上千台肉鸡，组成一个DDoS攻击群，同一时刻对目标发起攻击，是多对一或多对多的关系。其攻击的强度和造成的威胁要比DOS严重很多，更具破坏性。</p><p>2.黑客常用的攻击步骤和攻击手段</p><p><strong>黑客的攻击步骤（大概率考这个）</strong></p><ul><li>隐藏IP(来无影)：就是隐藏黑客的IP地址，典型方法是利用被控制的其它主机作为跳板</li><li>踩点扫描：通过各种途径和手段对所要攻击的目标对象信息进行多方探寻搜集，确保具体信息准确，确保攻击时间和地点等</li><li>获得控制权：即获得管理权限，目的是通过网络登录到远程计算机上，对其实施控制，达到攻击目的</li><li>种植后门：利用程序的漏洞进入系统后安装的后门程序，以便于以后可以不被察觉地再次进入系统</li><li>隐身退出(去无踪)：入侵完毕后及时清除登陆日志和其它相关的系统日志，及时隐身退出</li></ul><p>黑客攻击手段：网络监听、拒绝服务攻击、欺骗攻击(源IP地址欺骗、源路由欺骗攻击)、缓冲区溢出、病毒及密码攻击、应用层攻击。</p><p>3.VPN的实现技术及技术特点</p><p>虚拟专用网VPN：是利用Internet等公共网络的基础设施，通过隧道技术，为用户提供的与<strong>专用网络</strong>具有相同通信功能的安全数据<strong>通道</strong>。</p><p>VPN的实现技术：隧道技术(核心技术)、加解密技术(利用非对称加密技术进行密钥协商，利用对称加密技术进行数据传输)、密钥管理技术、身份认证技术。</p><p>VPN的技术特点：安全性高、费用低廉、管理<strong>便利</strong>、灵活性<strong>强</strong>、服务质量佳。</p><p>4.防火墙如何去防止利用三次握手的DoS攻击？（写一个的原理过程）</p><p>应用代理型防火墙的防御方法是由于它位于客户端与服务器端中间，充当代理角色，这样客户端要与服务端建立一个TCP连接，就必须先与防火墙进行一个三次握手。当客户端和防火墙三次握手成功以后，再由防火墙和服务器进行三次握手。一个成功的TCP连接所经历的两个三次握手过程如下图所示</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/4ba9a208312cb7274efbaeb8219f1b15.png"  alt="image-20210102011218912"></p><p>当外部对内部网络中的服务器端发起攻击时，实际上遭受攻击的不是服务器而是防火墙。而防火墙自身具有抗攻击能力，可以通过规则设置，拒绝外界客户端不断发送的报文。</p><blockquote><p>防火墙是位于两个或多个内外网络之间，通过执行访问控制策略保护网络安全的系统.</p><p>功能：建立一个集中的监视点；隔绝内外网络，保护内部网络；强化网络安全策略、有效记录和审计内、外网路之间的活动。</p><p>缺点：客户端要与服务端建立一个TCP连接就要经历六次握手，要求防火墙具有较强的处理能力和较大的内存。不适合访问流量大的服务器或者网络。</p><p>（可能会考，上面的一定会考）</p></blockquote><p>5.物理层的实体的安全防护有哪些？</p><ul><li><p>防火：网络中心的机房发生火灾一般是由于电气原因、人为事故或外部火灾蔓延等引起的</p></li><li><p>防盗：被偷窃所造成的损失可能会远远超过计算机及网络设备本身的价值，因此必须采取严格防范措施</p></li><li><p>防静电：静电产生后，能量会不断增加，从而产生静电放电火花，造成火灾，因此要采取相应措施</p></li><li><p>防雷击：传统避雷针防雷，不仅增大雷击的可能性还会产生感应雷，因此要采取防雷击措施</p></li><li><p>防电磁泄露：计算机、服务器等设备在工作时会产生电磁<strong>发射</strong>，其可能会被高灵敏度的接收设备接收、分析或还原，造成信息泄露</p></li></ul><p>6.计算机病毒有哪些危害？介绍一个病毒</p><p>计算机病毒的危害：破坏系统、文件和数据，窃取机密文件和数据，造成网络堵塞或瘫痪，消耗内存、磁盘空间和系统资源，计算机运行缓慢，对用户造成心理压力。</p><p>熊猫烧香是一种经过多次变种的蠕虫病毒。被列为我国2006年十大病毒之首。自爆发后,短时间内出现近百个变种,上百万台计算机中毒,并深受其害。<br>感染中毒的计算机系统中,可执行文件会出现“熊猫烧香”图案,其他更为明显的中毒症状表现为计算机蓝屏、反复重启或硬盘数据遭破坏等。同时,作为蠕虫病毒的一类变种,熊猫烧香病毒同样可以通过网络进行传播,感染网络内所有的计算机系统,造成不同程度的局域网和互联网瘫痪。</p><p>7.拖库和撞库是什么？</p><p>拖库：是指黑客入侵有价值的网络站点，把注册用户的资料数据库全部盗走的行为，因为谐音，也经常被称作“脱裤”。<br>撞库：黑客通过收集互联网已泄露的用户和密码信息，生成对应的<strong>字典表</strong>，尝试批量登陆其他网站后，得到一系列可以登录的用户。</p><blockquote><p>可能要考：拖库可以通过数据库安全防护技术解决，撞库可通过大数据安全技术防护解决</p></blockquote><p>8.5G本身需求和特点，针对这些需求特点设计它的安全协议应该注意什么（分析题-不一定写完但尽量多写点）</p><blockquote><p>5G：即第五代移动通信技术，5G 可以在毫米波中运行，5G可用的频谱数量意味着数据传输的速度比目前可能的速度要快得多。</p><p>用到技术：SDN，NFV，边缘计算</p><p>（帮助理解，考试应该不考）</p></blockquote><p>5G需求特点：高速度、高可靠性、低时延、低功耗、万物互联、重构安全</p><p>5G有高可靠性低时延需求如远程医疗，无人驾驶。要考虑协议产生的时延是否会对5G的低时延要求造成较大影响。</p><p>超密集部署技术使单个接入节点覆盖范围很小，车辆等终端快速移动时，信号可能会不稳定从而影响时延，这也是设计协议所必须考虑的。</p><p>对于万物互联，其与传统的无线网络相比，更容易受到威胁和攻击。而如果对每个设备都单独认证则会消耗大量资源，安全协议也应考虑这个问题。</p><p>5G的高速度要求将出现数量众多的小站，因此也必须考虑除了传统移动互联网所存在的安全威胁外，在这种密集组网场景下可能会存在小站接入的安全威胁。</p><p>5G的低功耗要求，如对于手机等移动终端的功耗，通信过程若消耗大量能量就很难让用户广泛接受，因此也必须考虑功耗问题。</p><h2 id="可能考点"><a class="header-anchor" href="#可能考点">¶</a>可能考点</h2><p>9.无线网络安全（做一些解释）</p><p>无线网络安全包括应用于无线（或 WiFi）网络的典型网络层安全控制。无线网络安全是存在于当今移动工作场所中的一大严峻问题。管理员面临着日益增长的保护公司关键资源免受攻击的需求。当员工通过无线网络访问公司的私人数据时，如果用户没有屏蔽外部人员的连接（例如，通过密码保护的访问），数据可能会被未经授权的查看者破坏。</p><p>无线局域网的协议设计还应该考虑到网络特点 。由于无线特点，消息暴露，攻击者将变得更多，协议应该有很强的抗篡改性。除了加密的信息，暴露的明文信息应该不足以被攻击者利用来破解密文。</p><p>10.入侵检测系统</p><p>入侵检测系统（intrusion detection system，简称“IDS”）是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。它与其他网络安全设备的不同之处便在于，IDS是一种积极主动的安全防护技术。在很多中大型企业，政府机构，都会布有IDS。我们做一个比喻——假如防火墙是一幢大厦的门锁，那么IDS就是这幢大厦里的监视系统。一旦小偷进入了大厦，或内部人员有越界行为，只有实时监视系统才能发现情况并发出警告。</p><p>入侵检测系统的作用</p><ul><li>防火墙的重要补充</li><li>构建网络安全防御体系重要环节</li><li>克服传统防御机制的限制</li></ul><p>入侵检测系统功能</p><ul><li>监测并分析用户和系统的活动</li><li>核查系统配置和漏洞</li><li>对操作系统进行日志管理，并识别违反安全策略的用户活动</li><li>针对已发现的攻击行为作出适当的反应，如告警、中止进程等</li></ul><p>11.IP协议的缺点</p><p>答：IP地址可以暴露个人位置…</p><p>12.区块链去中心化的优点和缺点</p><p>答：优点：不再存在由于少数节点的物理崩溃而造成所搭建的体系崩溃的问题</p><ul><li>解决了目前中心化的信任问题，信用的认证依赖于整个网络，而不再依赖中心节点</li><li>数据被分割成小块，经过加密后才会分散存储在众多结点上，能够避免中心化存储的集中式风险，即便某一块数据被泄露，也只是部分而非全部数据。</li><li>去中心化存储能够发挥共享经济的优势，硬盘的空余空间可以被充分地利用起来</li></ul><p>缺点：存取速度问题：由于并不是所有节点带宽都比较大，导致去中心化存储存取速度较慢</p><ul><li>由于数据存放在众多结点，而不是每个结点都有很多好的防护，如何保证结点的安全也是问题</li></ul><h1>应用题</h1><h2 id="RSA算法（计算）"><a class="header-anchor" href="#RSA算法（计算）">¶</a>RSA算法（计算）</h2><p>工作原理如下（帮助理解，主要是计算）</p><p>假定用户Aice要发送消息m给用户Bob,则RSA算法的加/解密过程如下<br>1)首先,Bob产生两个大素数p和q（p、q是保密的）<br>2)Bob计算n=p*q 和 φ(n)=(p-1)*(q-1)<br>3)Bob选择一个随机数e(0&lt;e&lt;φ(n)，使得(e,φ(n))=1(即e和φ(n)互素)。<br>4)Bob计算得出d,使得 d*e mod φ(n)=1(即在与n互素的数中选取与φ(n)互素的数，可以通过欧几里得算法得出)。私钥是d，Bob自留且加密<br>5)Bob将(e,n)作为公钥公开<br>6)Alice通过公开信道查到n和e。对m加密,加密E(m)= m<sup>e</sup> mod n<br>7)Bob收到密文c后,解密D©= c<sup>d</sup> mod n</p><p><strong>重点公式如下</strong></p><p>n=p*q   φ(n)=(p-1)*(q-1)  d*e ≡ 1 mod φ(n)</p><p>加密：c ≡ m<sup>e</sup> mod n    （e和n会给出）</p><p>解密：m ≡ c<sup>d</sup> mod n      (一般d要自己求)</p><p>习题</p><p>1.假设明文m=5，e=7，p=11，q=13，给出RSA的加密解密过程  (<strong>预测考这种求加密和解密两个过程的题</strong>)</p><p>答：n=p*q=11*13=143           φ(143) = (p-1)*(q-1) = 10*12=120</p><p>因为d*e ≡ 1 mod φ(n)  即d*7 ≡ 1 mod 120   所以 d=103 (考试时d不会那么大，试几次就知道啦)</p><p>加密：c ≡ m<sup>e</sup> mod n  ≡ 5<sup>7</sup> ≡ 47 mod 143</p><p>解密：m ≡ c<sup>d</sup> mod n  ≡ 47<sup>103</sup> ≡ 5 mod 143</p><blockquote><p>预测老师所说和学号有关的是明文m，考试时我的m应该为6</p><p>6<sup>2</sup>=36  6<sup>3</sup>=2166<sup>4</sup>=12966<sup>5</sup>=7776（在此仅为先列出有个印象到时候别算错了）</p></blockquote><p>2.RSA加密体制中，接收方的公开钥是(e,n)=(5,35)，接收到的密文是C=10，求明文M (<strong>预测n、e等数值和本题一样，密文或明文和学号有关</strong>)</p><p>答：（    m ≡ c<sup>d</sup> mod n         所以得先算出d  -----&gt; d*e ≡ 1 mod φ(n)  ）</p><p>n=35             所以 p=5，q=7</p><p>φ(35) = (p-1)*(q-1) =4*6=24</p><p>因为 d*e ≡ 1 mod φ(n)   所以d=5      （这个到时候一个一个试就行）</p><p>m ≡ c<sup>d</sup> mod n ≡ 10<sup>5</sup> mod 35 ≡ 5          （注意不是等号）</p><h2 id="签名过程-叙述题"><a class="header-anchor" href="#签名过程-叙述题">¶</a>签名过程(叙述题)</h2><h3 id="加密和签名"><a class="header-anchor" href="#加密和签名">¶</a>加密和签名</h3><p>创建数字签名</p><ul><li>发方将原文用哈希算法求得数字摘要；</li><li>发方用自己的私钥对数字摘要加密求得数字签名，并将签名附在原文的后面；</li><li>发方用<strong>加密密钥</strong>对原文和签名进行加密；</li><li>发方用收方的公钥<strong>对加密密钥进行加密</strong>，发送给收方；</li></ul><p>验证数字签名</p><ul><li>收方用自己的私钥解密加密密钥；</li><li>收方用加密密钥解密密文，得到原文和发方签名；</li><li>收方用相同的哈希算法对解密后的原文计算摘要记为摘要1；</li><li>收方用发方公钥解密数字签名得到发方摘要记为摘要2；</li><li>收方对比摘要1和摘要2，若结果相同签名得到验证。</li></ul><h3 id="只签名-预计考这个"><a class="header-anchor" href="#只签名-预计考这个">¶</a>只签名(预计考这个)</h3><p>创建数字签名</p><ul><li>发方将原文用哈希算法求得数字摘要；</li><li>发方用自己的私钥对数字摘要加密求得数字签名；</li><li>发方将签名附在原文的后面发给收方；</li></ul><p>验证数字签名</p><ul><li>收方将收到的消息中的原文及其数字签名分离出来</li><li>收方用相同的哈希算法对原文计算摘要记为摘要1；</li><li>收方用发方公钥解密数字签名得到发方摘要记为摘要2；</li><li>收方对比摘要1和摘要2，若结果相同签名得到验证。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;作者：夏日&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;题型&lt;/h1&gt;
&lt;p&gt;选择题：20*1&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>密码学期末总结</title>
    <link href="https://zss192.github.io/2022/11/14/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <id>https://zss192.github.io/2022/11/14/%E5%AF%86%E7%A0%81%E5%AD%A6/</id>
    <published>2022-11-14T09:36:00.000Z</published>
    <updated>2022-11-14T09:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>所用教材：杨波的现代密码学第四版<br>由于老师后来给画了重点，本篇博客后半部分主要记录的是老师画的重点。个人复习使用，仅供参考<br>对于河南大学的学弟学妹们，如果你们任课老师是袁老师的话，他会给复习要点，跟着复习要点有针对性的复习就行。</p><h1>1.引言</h1><h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIwMjYxMjY2Ni5wbmc?x-oss-process=image/format,png"  alt="image-20200616202612666"></p><p>1.在本书中，c指密文，m指明文，E()表示加密函数，D()表示解密函数</p><p>2.仿射变换：加密和解密中a，b为秘钥  （属于单表变换）</p><p>c=E<sub>a,b</sub>(m)=am+b(mod 26)</p><p>m=D<sub>a,b</sub>(m)=a<sup>-1</sup>(c-b)(mod 26)</p><blockquote><p>注意a<sup>-1</sup>*a≡1 mod 26</p></blockquote><p>3.多表代换密码：其中A为n*n的矩阵，n等于几代表明文每几个分成一组。一般N为26。</p><p>C<sub>i</sub>≡AM<sub>i</sub>+B(mod N)，i=1,2,3…</p><p>M<sub>i</sub>≡A<sup>-1</sup>(C<sub>i</sub>-B)(mod N)，i=1,2,3…</p><p>4.人为攻击分为</p><ul><li>被动攻击       就是窃听，是对系统保密性的攻击<ul><li>获取信息的内容</li><li>业务流分析     敌收无法获得消息但可能获得通信双方身份、次数…</li></ul></li><li>主动攻击       对数据流的篡改或产生假数据流<ul><li>中断      如破坏硬件、系统是对系统可用性的攻击</li><li>篡改      修改数据是对系统完整性的攻击</li><li>伪造      如插入伪造消息或记录，是对系统真实性的攻击</li></ul></li></ul><blockquote><p>被动攻击不改变消息而主动攻击改变消息内容</p><p>抵抗被动攻击：预防                抵抗主动攻击：检测修复</p></blockquote><p>5.密码算法的安全性包括哪两类？？(暂时没找到)</p><p>6.密钥管理：密钥产生、分配、存储、销毁等问题</p><p>7.密码体质从原理上可分为两类</p><ul><li>对称(单钥)密码体制             （可用于数据加密和消息认证）<ul><li>流密码                             逐位加密</li><li>分组密码                         消息分组，逐组加密</li></ul></li><li>非对称(双钥)密码体制            两密钥，一公开一私密</li></ul><p>8.对密码系统的攻击按攻击者可获取的信息量可分为</p><ul><li>唯密文攻击                           仅知道一些密文</li><li>已知明文攻击                       知道一些密文和相应的明文</li><li>选择明文攻击                       密码分析者可以选择一些明文并得到相应的密文</li><li>选择密文攻击                       密码分析者可以选择一些密文，并得到相应的明文</li></ul><blockquote><p>以上攻击都建立在已知算法的基础之上，且攻击强度依次增加</p></blockquote><p>9.单向陷门函数就是有一个陷门的一类特殊单向函数。</p><p>若y=f(x)，已知x很容易计算y，但已知y很难计算x（单向性）。特别的是存在一个z使得知道了z那么就很容易由y计算出x，那么z则称为陷门（有陷门也称后门）</p><p>10.加密算法满足下列两点则认为是计算上安全的</p><ul><li>破译密文的代价超过被加密信息的价值</li><li>破译密文所花的时间超过信息的有用期</li></ul><p>11.攻击密码体制的常用方法</p><ul><li>穷举攻击                             （解决方法 : 增大密钥量）</li><li>统计分析攻击                     （解决方法：使明文的统计特性与密文的统计特性不一样）</li><li>数学分析攻击                     （解决方法：选用足够复杂的加密算法）</li></ul><p>12.密钥体制组成部分（加密系统的五元组）：明文，密文，密钥，加密算法，解密算法。</p><p>13.一个好密钥体制至少应满足的两个条件：</p><ul><li>已知明文和加密密钥计算密文容易，已知密文和解密密钥计算明文容易</li><li>在不知解密密钥的情况下，不可能由密文 c 推出明文</li></ul><p>14.==清楚信息安全专业学习密码学的原因==   （非标准答案）（==必考！==）</p><p>答：信息在社会中的地位和作用越来越重要，则其安全愈发重要，而密码学是保障信息安全的核心技术。可以说没有密码学就没有信息安全。</p><h2 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.设由仿射变换对一个明文加密得到的密文为edsgickxhuklzveqzvkxwkzukvcuh，又已知明文的前两个字符是“if&quot;，对该密文解密。</p><p>答：e=4  d=3  i=8   f=5    （26个字母下标从0开始）E<sub>a,b</sub>(m)=am+b(mod 26)</p><p>E(i)=e，4≡8*a+b(mod 26)</p><p>E(f)=d，3≡5*a+b(mod 26)</p><p>由上述两个式子可推出a=9，b=10，所以m=9<sup>-1</sup>(c-10)(mod 26)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609204054393.png"  alt="image-20200609204054393" style="zoom:80%;" /><p>2.设多表代换密码C≡AM<sub>i</sub>+ B(mod26)中，A是2X2矩阵，B是0矩阵，又知明文“dont”被加密为“elni”，求矩阵A。</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609205229494.png"  alt="image-20200609205229494" style="zoom:67%;" /><blockquote><p>注意矩阵相乘的结果要模26，上式求b的时候算得125b=13，其实应是125b≡13(mod 26)，即为21b≡13(mod 26)，解得b=13，其他类似</p></blockquote><h1>2.流密码</h1><h2 id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIwMjcyMDEyMi5wbmc?x-oss-process=image/format,png"  alt="image-20200616202720122"></p><p>1.==流密码的基本思想==：  (==必考！==)</p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIxNTIxNTUyNy5wbmc?x-oss-process=image/format,png"  alt="image-20200616215215527"></p><p>2.流密码中密钥流就等于明文串和密文串异或</p><p>3.移位寄存器是流密码产生密钥流的一个重要组成部分</p><p>4.m序列密码的破译就是求密钥流的递推关系即a<sub>m+i</sub>=c<sub>m</sub>ai⊕c<sub>m-1</sub>a<sub>i+1</sub>⊕…⊕c<sub>1</sub>a<sub>m+i-1</sub></p><p>(公式中的m即题目说多少级级线性反馈移位寄存器就是多少)</p><blockquote><p>比如是3级，我们求得是a<sub>i+3</sub>，当i=1，i+3=4即第四个这样根据前三个就可知道后面所有的数</p></blockquote><h2 id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.求矩阵的逆（这章习题会用到，复习下）</p><p>核心公式：A<sup>-1</sup>=A<sup>*</sup>/|A|</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609214703300.png"  alt="image-20200609214703300" style="zoom:80%;" /><p>若是三阶矩阵：A<sub>ij</sub>=(-1)<sup>i+j</sup>M<sub>ij</sub>，M<sub>ij</sub>为除去a<sub>ij</sub>所在那一行和那一列得到的二阶矩阵</p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYwOTIxNTE0MDU1MS5wbmc?x-oss-process=image/format,png"  alt="image-20200609215140551"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYwOTIxNTUyMTg4NS5wbmc?x-oss-process=image/format,png"  alt="image-20200609215521885"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDYwOTIxNTczNjYwOS5wbmc?x-oss-process=image/format,png"  alt="image-20200609215736609"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDYwOTIxNTk0MTk1OS5wbmc?x-oss-process=image/format,png"  alt="image-20200609215941959"></p><p>2.已知流密码的密文串1010110110和相应的明文串0100010001，而且还已知密钥流是使用3级线性反馈移位寄存器产生的，试破译该密码系统。(和P65例2-6类似)</p><p>答：由已知可得密钥流为1010110110⊕0100010001=1110100111，因为是3级线性反馈</p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYwOTIxMjI0OTMyNi5wbmc?x-oss-process=image/format,png"  alt="image-20200609212249326"></p><blockquote><p>按照上面矩阵：a<sub>4</sub>=c<sub>3</sub>*a<sub>1</sub>+c<sub>2</sub>*a<sub>2</sub>+c<sub>1</sub>*a<sub>3</sub>正是密钥流递推关系(m=3,i=1然后是m=3,i=2…)</p></blockquote><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYwOTIxNDIzNTA4NC5wbmc?x-oss-process=image/format,png"  alt="image-20200609214235084"></p><blockquote><p>记住c从高到低，a从低到高</p></blockquote><p>3.如图是一个3级反馈移位寄存器，其初始状态为(a1,a2,a3)=(1,0,1)，求输出序列</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609221112648.png"  alt="image-20200609221112648" style="zoom:80%;" /><p>从图中可看到a1、a2、a3经f函数送至左边形成一个循环，比如f(a1,a2,a3)=b，那么b将代替a3的位置，a3～a1均右移，所以a1输出，以此类推。</p><p>答：f(a1,a2,a3)=f(1,0,1)=1*0⊕1=1，然后f(1,1,0)</p><p>可总结规律，右边的3为参与f函数生成的数放在左边，然后以左边这个数向右数3个数分别当做a3,a2,a1参与f生成的又放在最左边…最后输出是从右到左</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200609_222216.jpg"  alt="IMG_20200609_222216" style="height:170px;" /><p>即输出序列为10111011101…，周期为4</p><h1>3.分组密码</h1><h2 id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616202818895.png"  alt="image-20200616202818895" style="zoom:80%;" /><p>1.分组密码：将明文划分为长为n的组x(x0,x1,…,xn-1)，各组在密钥k=(k0,k1,…kt-1)控制下变换成等长的数字序列y=(y0,y1,…ym-1)。实质是对字长为n的数字序列的代换密码 （一般m=n）</p><p>2.扩散和混淆是Shannon提出的设计密码系统的两个基本方法(分组密码安全设计性原则)  (了解)</p><ul><li>扩散：使明文与密文之间的统计关系变得尽可能复杂，以使敌手无法得到密钥<ul><li>明文每一比特变换尽量多的影响密文序列的变化，以隐蔽明文的统计特性（雪崩效应）</li><li>P盒(置换)用于扩散</li></ul></li><li>混淆：使密文与密钥之间的统计关系变得尽可能复杂，以使敌手无法得到密钥<ul><li>S盒(代换)用于混淆</li></ul></li></ul><p>3.很多分组密码结构本质都基于Feistel结构</p><p>将每组明文分为左右两半L<sub>0</sub>和R<sub>0</sub>，n轮迭代后再合在一起产生密文分组</p><p>第i轮迭代（代换）：      L<sub>i</sub>=R<sub>i-1</sub>  (左等右上)             R<sub>i</sub>=L<sub>i-1</sub>⊕F(R<sub>i-1</sub>,K<sub>i</sub>)  （右等左上异或F即右上和K）</p><p>最后一轮交换左右两半数据（置换）</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614145605923.png"  alt="image-20200614145605923" style="zoom: 80%;" /><p>解密和加密本质过程一样，密文作为输入，但使用子密钥K<sub>i</sub>的次序和加密相反（这一特性保证了加密和解密可用同一算法）</p><p>4.DES加密过程可分为三个阶段 (64比特明文，64比特密钥(每个第8位设置奇偶校验位实际56位)）</p><ul><li>初始置换IP，用于重排明文分组的64比特         （由IP置换表实现）</li><li>生成子密钥</li><li>迭代过程即16轮变换(代换和置换)然后交换左右次序</li><li>逆初始置换IP<sup>-1</sup></li></ul><p>:two: 生成子密钥过程                参考：<a href="https://www.cxyxiaowu.com/1478.html">算法科普：神秘的 DES 加密算法</a> ，下同</p><p>56比特密钥经PC-1置换后分为左右C<sub>0</sub>和D<sub>0</sub>，然后由表左循环经PC-2产生48比特的本轮密钥</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1571057977-17488ca32598db6.jpg"  alt="image-20200614145605923" style="zoom: 80%;" /><p>:three: 迭代过程等同于Feistel结构(左等右上，右等左上异或F)，而其中用到的F函数为：</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614155257147.png"  alt="image-20200614155257147" style="zoom:67%;" /><p>5.分组密码的运行模式</p><ul><li>ECB(电话本)模式                      各明文组以同一密钥加密</li><li><strong>CBC(密码分组链接)模式</strong>          加密的输入是当前明文组和前一密文组的异或</li><li>CFB(密码反馈)模式                  每次处理j位输入，上次密文加密产生伪随机再与当前明文异或</li><li>OFB(输出反馈)模式           与CFB不同的是加密的输入是前一次加密的输出(与明文异或的那个)</li></ul><p>:two: ==CBC模式加解密示意图== （==必考！==）</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614163017246.png"  alt="image-20200614163017246" style="height:450px" /><p>加密: C<sub>i</sub>= E<sub>k</sub>[P<sub>i</sub>⊕C<sub>i-1</sub>] (可认为C<sub>0</sub>=IV)         解密:P<sub>i</sub>= D<sub>K</sub>[C<sub>i</sub>]⊕C<sub>i-1</sub></p><blockquote><p>IV初始向量与第一个明文分组异或，应像密钥一样被保护。该模式能够获得保密性也可认证，适合加密64比特的消息</p></blockquote><p>==工作模式为==：它一次对一个明文分组加密，每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或，因此加密算法的输入不会显示出这次的明文分组之间的固定关系，所以重复的明文分组不会在密文中暴露出这种重复关系                   （==必须背会！==）</p><p>6.AES是DES的替代者，也是当今最流行的对称加密算法之一</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20190527200618151.png"   /><p>AES轮函数包括字节代换、行移位、列混合、密钥加</p><p>:one: 字节代换：根据S盒把明文块的每一个字节都替代成另外一个字节</p><p>:two: 行移位：如第1行不变，第2行循环左移C1个字节，第3行左移C2个字节，第4行移C3 要根据表</p><p>:three: 列混合：输入数组每一列和修补矩阵的二维常量数组做矩阵相乘，得到对应的输出列。</p><p>:four: 密钥加：输入数组的每个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]</p><p>7.SM4算法，数据和密码分组均为128比特</p><p>加密：Xi+4=F(X<sub>i</sub>,X<sub>i+1</sub>,X<sub>i+2</sub>,X<sub>i+3</sub>,rk<sub>i</sub>)=X<sub>i</sub>⊕T(X<sub>i+1</sub>⊕X<sub>i+2</sub>⊕X<sub>i+3</sub>⊕rk<sub>i</sub>)（i=0,1,2…31）</p><p>后经反序R处理：(Y<sub>0</sub>,Y<sub>1</sub>,Y<sub>2</sub>,Y<sub>3</sub>)=(X<sub>35</sub>,X<sub>34</sub>,X<sub>33</sub>,X<sub>32</sub>)=R(X<sub>32</sub>,X<sub>33</sub>,X<sub>34</sub>,X<sub>35</sub>)</p><p>解密算法和加密算法相同，轮密钥使用顺序相反</p><p><a href="http://8.GF">8.GF</a>(2<sup>8</sup>)中   a*a<sup>-1</sup>=1(mod x8+x4+x5+x+1)</p><p>GF(2)上的可逆的仿射变换  （x是题目中a的逆）</p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNDIwNTMzNTYzMi5wbmc?x-oss-process=image/format,png"  alt="image-20200614205335632"></p><h2 id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2><p>1.==对字节a=1011  0110字节替代变换，设a的逆为a<sup>-1</sup>==                 （ ==必考！==）</p><p>答：先求a的逆，再用仿射变换即可</p><p>:one: 由a得(x<sup>7</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>2</sup>+x)a<sup>-1</sup> ≡ 1(mod x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1)</p><p>所以a<sup>-1</sup>=x<sup>6</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>3</sup>             即0111 1000     （二进制对应位数有1就代表有x的那一次方）</p><blockquote><p>根据老师给的考试要点，仿射变换和m(x)题目会给出，a的逆试试就出来了</p></blockquote><p>:two: 使用仿射变换   （注意要用a的逆而且注意x的顺序从下往上读）</p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9RUSVFNSU5QiVCRSVFNyU4OSU4NzIwMjAwNjE0MjEwNjM5LmpwZw?x-oss-process=image/format,png"  alt="QQ图片20200614210639"></p><p>即(0100 1110)<sub>2</sub>=(4E)<sub>16</sub>                 注意也是从下开始读  因为最下面的是字节高位即最前面的01…</p><p>2.利用DES算法和全0密钥对输入(1000 0001 1960 0000)进行一圈加密的结果 （需要查表P39）</p><p>答：:one: 输入的右半部分是1960 0000 = 0001 1001 0110 0000    0000 0000 0000 0000</p><p>:two: 经E盒扩展后为：000011 110010 101100 000000      000000 000000 000000 000000</p><p>:three: 与全0密钥对异或后为：000011 110010 101100 000000      000000 000000 000000 000000</p><p>:four: 经S盒后变为：15 8 3 7 2 12 4 13 即1111 1000 0011 0111 0010 1100 0100 1101</p><p>:five: 经P盒后变为 1001 1100 1101 1000     1001 1010 1010 1110</p><p>:six: 输出的左半部分即输入的右半部分为1960 0000，输出的右半部分为F函数输出和左半部分输入异或即8cd8 9aaf，最终输出为 1960 0000  8cd8 9aaf</p><blockquote><p>这题主要是加深对DES迭代过程的理解，由于要查表，考试应该不会考</p></blockquote><p>3.在DES的ECB模式中,如果在密文分组中有一个错误,解密后仅相应的明文分组受到影响。然而在CBC模式中，将有错误传播。加密解密图中C1中的一个错误明显地将影响到P1和P2的结果。</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614163017246.png"  alt="image-20200614163017246" style="zoom: 50%;" /><p>(1) P2后的分组是否受到影响?<br>(2)设加密前的明文分组P1中有1比特的错误，问这一错误将在多少个密文分组中传播?<br>对接收者产生什么影响?</p><p>答：:one: CBC的加密: C<sub>i</sub>= E<sub>k</sub>[P<sub>i</sub>⊕C<sub>i-1</sub>]，i≥2           解密:P<sub>i</sub>= D<sub>K</sub>[C<sub>i</sub>]⊕C<sub>i-1</sub>，i≥1</p><p>若C1有错误，P2=D<sub>K</sub>[C<sub>2</sub>]⊕C<sub>1</sub>所以P2也会受影响，但i≥3时，P<sub>i</sub>= D<sub>K</sub>[C<sub>i</sub>]⊕C<sub>i-1</sub>与C1无关因此不会受到影响</p><blockquote><p>本题由于C1错误事实上C2、C3、C4…都会和原来不一样，但即使它是错的经密钥解密后还是可以得到原明文(可理解为是明文的另一种加密结果)，所以说P2后不受影响</p></blockquote><p>:two: 若P1出错，则C1会是错的，由C<sub>i</sub>= E<sub>k</sub>[P<sub>i</sub>⊕C<sub>i-1</sub>]得，C<sub>i≥2</sub>也都是错误的，因此会传递到每一个分组</p><p>由加密解密方式可知，若只是P1出错，解密后得到的还是原来的输入。即接收者解密后的P1和原来输入的一样会有1比特的错误，而其他的可以解密得到正确的明文</p><h1>4.公钥密码</h1><h2 id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616203037349.png"  alt="image-20200616203037349" style="zoom:80%;" /><p>1.==RSA加密解密==      (==必考！==)</p><p>选倆素数p,q       n=p*q      φ(n)=(p-1)*(q-1)            d*e ≡ 1 mod φ(n)</p><p>加密：c ≡ m<sup>e</sup> mod n    （e和n会给出）</p><p>解密：m ≡ c<sup>d</sup> mod n      (一般d要自己求)</p><p>2.可能会用到的公式：a*b (mod q) = a (mod q) * b (mod q)</p><blockquote><p>推测是RSA中m<sup>e</sup>或c<sup>d</sup>可以拆成两个乘积的形式</p></blockquote><h2 id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2><p>1.==RSA加密体制中，接收方的公开钥是(e,n)=(5,35)，接收到的密文是C=10，求明文M== （==必考！==）</p><p>答：（    m ≡ c<sup>d</sup> mod n         所以得先算出d  -----&gt; d*e ≡ 1 mod φ(n)  ）</p><p>n=35             所以 p=5，q=7</p><p>φ(35) = (p-1)*(q-1) =4*6=24</p><p>因为 d*e ≡ 1 mod φ(n)   所以d=5      （这个到时候一个一个试就行）</p><p>m ≡ c<sup>d</sup> mod n ≡ 10<sup>5</sup> mod 35 ≡ 5          （注意不是等号）</p><p>2.==假设明文m=5，e=7，p=11，q=13，给出RSA的加密解密过程==     （==必考！==）</p><p>答：n=p*q=11*13=143           φ(143) = (p-1)*(q-1) = 10*12=120</p><p>因为d*e ≡ 1 mod φ(n)  即d*7 ≡ 1 mod 120   所以 d=103</p><p>加密：c ≡ m<sup>e</sup> mod n  ≡ 5<sup>7</sup> ≡ 47 mod 143</p><p>解密：m ≡ c<sup>d</sup> mod n  ≡ 47<sup>103</sup> ≡ 5 mod 143</p><h1>5.数字签名</h1><h2 id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616210115666.png"  alt="image-20200616210115744" style="zoom:80%;" /><p>1.==ElGamal签名体制：==                       （==必考！==）</p><p>用户A的公钥：y ≡ g<sup>x</sup>  (mod p)          x为用户A的私钥</p><p>签名的产生过程：</p><ul><li>计算 r ≡ g<sup>k</sup>  (mod p)</li><li>计算 s ≡ (H(m)-xr)k<sup>-1</sup> (mod p-1)           H(m)为m的哈希值，计算取H(m)=m，注意是p-1</li><li>(r,s)即为签名</li></ul><p>签名的验证过程</p><ul><li>计算y<sup>r</sup>r<sup>s</sup> ≡ g<sup>H(m)</sup> (mod p)</li><li>就是验证 y<sup>r</sup>r<sup>s</sup>（mod p）是不是等于 g<sup>H(m)</sup> (mod p)</li></ul><h2 id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2><p>1.ElGamal签名体制中，假设p=19，g=13。签名者A的私钥为x = 10，试计算公钥。设消息M=15，k=11，求签名过程并验证。  (==必考！==)</p><p>答：公钥：y ≡ g<sup>x</sup> mod p ≡ 13<sup>10</sup> mod 19 = 6</p><p>签名：r ≡ g<sup>k</sup>  (mod p) ≡ 13<sup>11</sup> mod 19 =2</p><p>s ≡ (H(m)-xr)k<sup>-1</sup> (mod p-1) ≡ (m-xr)k<sup>-1</sup> (mod p-1) ≡ (15-10*2)*11<sup>-1</sup> mod 18 = 11</p><p>所以(r,s)=(2,11)</p><p>验证：y<sup>r</sup>r<sup>s</sup> ≡ 6<sup>2</sup>*2<sup>11</sup> mod 19 ≡ 8 ≡ g<sup>m</sup> (mod p) ≡ 13<sup>15</sup> ≡ 8 mod 19</p><blockquote><p>根据老师的重点中给出的a*b (mod q) = a (mod q) * b (mod q)应该是用在比如这题求6<sup>2</sup>*2<sup>11</sup> mod 19就等同于求6<sup>2</sup> mod 19 * 2<sup>11</sup> mod 19 ≡ 17 *15 ≡ 8 mod 19</p></blockquote><h1>6.哈希函数</h1><h2 id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIxNTY1MjE5Ny5wbmc?x-oss-process=image/format,png"  alt="image-20200616215652197"></p><p>1.单向函数：已知h，求使得H(x)=h的x在计算上是不可行的。</p><p>2.==弱单向哈希函数和强单向哈希函数==            （==必考！==）</p><p>已知x，找出y (y≠x) 使得H(y)=H(x)在计算上是不可行的，若单向函数满足这种性质则称其为弱单向哈希函数         （==必须会背！==）</p><p>找出任意两个不同的输入x、y，使得H(x)=H(y)在计算上是不可行的，若单向函数满足这种性质则称其为强单向哈希函数                  （==必须会背！==）</p><blockquote><p>已知一个另找一个使得H函数相等是弱单向，任意给倆使其H函数相等是强单向（看谁单的很）</p></blockquote><p>3.如果哈希函数对不同的输入可产生相同的输出，则称该函数具有碰撞性。</p><p>4.抗弱碰撞哈希函数：对于任意给定的x，找到满组足y≠x且H(x)=H(y)的y在计算上是不可行的</p><p>抗强碰撞哈希函数：找到任何满足H(x)=H(y)的x,y在计算上是不可行的</p><h1>7.认证技术</h1><h2 id="知识点-v7"><a class="header-anchor" href="#知识点-v7">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIyMTg1MTE5Ny5wbmc?x-oss-process=image/format,png"  alt="image-20200616221851197"></p><p>1.消息认证是一个过程，用于验证接收消息的真实性(确实是它声称的实体发来的)和完整性(未被篡改、插入、删除)，同时还用于验证消息的顺序性和时间性(未重排、重放、延迟)以及消息的不可否认性。</p><h1>8.密钥分配与密钥管理</h1><h2 id="知识点-v8"><a class="header-anchor" href="#知识点-v8">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIyMjUxMDAxMi5wbmc?x-oss-process=image/format,png"  alt="image-20200616222510012"></p><p>1.Diffie-Hellman密钥交换简称D-H密钥交换的目的是使得两个用户能够安全的交换密钥，得到一个共享的会话密钥，算法本身不能用于加密解密。</p><p>2.==D-H密钥交换协议==：                            （==必考！==）</p><p>已知私钥为X，公钥为Y，p是一大素数，a是p的本原根，a和p公开，K为共享密钥</p><p>用户A：计算Y<sub>A</sub>=a<sup>XA</sup> mod p发送给B         共享密钥K=Y<sub>B</sub><sup>XA</sup> mod p</p><p>用户B：计算Y<sub>B</sub>=a<sup>XB</sup> mod p发送给A         共享密钥K=Y<sub>A</sub><sup>XB</sup> mod p</p><blockquote><p>通过上述操作求得的两个K值相等，这样就安全的求得了一个公共的密钥</p></blockquote><h2 id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2><p>1.在Diffie- Hellman密钥交换过程中，设大素数p=11,a=2是p的本原根。  （==必考！==）<br>(1) 用户A的公开钥Y<sub>A</sub>=9,求其秘密钥XA。<br>(2)设用户B的公开钥Y<sub>B</sub>=3,求A和B的共享密钥K。</p><p>答：:one: Y<sub>A</sub>=a<sup>XA</sup> mod p = a<sup>XA</sup> mod p 即 9=2<sup>XA</sup> mod 11   所以 X<sub>A</sub>=6  (考试时一个一个试就行)</p><p>:two: K=Y<sub>B</sub><sup>XA</sup> mod p = 3<sup>6</sup> mod 11 =3</p><h1>9.密码协议</h1><h2 id="知识点-v9"><a class="header-anchor" href="#知识点-v9">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIzMDY1NTM1OS5wbmc?x-oss-process=image/format,png"  alt="image-20200616230655359"></p><p>1.密码协议是指利用密码工具实现与安全相关的协议或函数的计算</p><h1>10.可证明安全</h1><h2 id="知识点-v10"><a class="header-anchor" href="#知识点-v10">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIzMTMzMzY2OC5wbmc?x-oss-process=image/format,png"  alt="image-20200616231333668"></p><p>1.可证明安全性：将密码系统的安全性归结为某个经过深入研究的数学难题（如大整数素因子分解、计算离散对数等），数学难题被证明求解困难。这种评估方法存在的问题是它只说明了这个密码方法的安全性与某个困难问题相关，没有完全证明问题本身的安全性。</p><h1>11.密码学新方向</h1><h2 id="知识点-v11"><a class="header-anchor" href="#知识点-v11">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDYxNjIzMTc0MTAzMC5wbmc?x-oss-process=image/format,png"  alt="image-20200616231741030"></p><p>1.写出5中密码学新方向或新技术       （==必考！==）</p><p>答：身份基加密(IBE)、属性基加密(ABE)、全同态加密、动态加密</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;所用教材：杨波的现代密码学第四版&lt;br&gt;
由于老师后来给画了重点，本篇博客后半部分主要记录的是老师画的重点。个人复习使用，仅供参考&lt;br&gt;
对于河南大学的学弟学妹们，如果你们任课老师是袁老师的话，他会给复习要点，跟着复习要点有针对性的复习就行。&lt;</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统思维导图</title>
    <link href="https://zss192.github.io/2022/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>https://zss192.github.io/2022/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</id>
    <published>2022-11-14T09:36:00.000Z</published>
    <updated>2022-11-14T09:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>作者：夏日</p><p>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><p>操作系统详细知识点和习题见我这篇博客：<a href="https://blog.csdn.net/zss192/article/details/112388335">操作系统期末总结</a></p><h1>第一章</h1><h2 id="1-1操作系统的概念、功能"><a class="header-anchor" href="#1-1操作系统的概念、功能">¶</a>1.1操作系统的概念、功能</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130153634224.png"  alt="image-20201130153634224"></p><h2 id="1-2操作系统的特征"><a class="header-anchor" href="#1-2操作系统的特征">¶</a>1.2操作系统的特征</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130153926453.png"  alt="image-20201130153926453"></p><h2 id="1-3操作系统的发展与分类"><a class="header-anchor" href="#1-3操作系统的发展与分类">¶</a>1.3操作系统的发展与分类</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130153952829.png"  alt="image-20201130153952829"></p><h2 id="1-4操作系统的运行机制"><a class="header-anchor" href="#1-4操作系统的运行机制">¶</a>1.4操作系统的运行机制</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130154019038.png"  alt="image-20201130154019038"></p><h2 id="1-5中断和异常"><a class="header-anchor" href="#1-5中断和异常">¶</a>1.5中断和异常</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130154041782.png"  alt="image-20201130154041782"></p><h2 id="1-6系统调用"><a class="header-anchor" href="#1-6系统调用">¶</a>1.6系统调用</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130154108838.png"  alt="image-20201130154108838"></p><h2 id="1-7操作系统的体系结构"><a class="header-anchor" href="#1-7操作系统的体系结构">¶</a>1.7操作系统的体系结构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130154129625.png"  alt="image-20201130154129625"></p><h1>第二章</h1><h2 id="2-1-1-进程的概念、组成、特征"><a class="header-anchor" href="#2-1-1-进程的概念、组成、特征">¶</a>2.1.1.进程的概念、组成、特征</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130155451750.png"  alt="image-20201130155451750"></p><h2 id="2-1-2-进程的状态与转换、进程的组织"><a class="header-anchor" href="#2-1-2-进程的状态与转换、进程的组织">¶</a>2.1.2.进程的状态与转换、进程的组织</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130155431949.png"  alt="image-20201130155431949"></p><h2 id="2-1-3-进程控制"><a class="header-anchor" href="#2-1-3-进程控制">¶</a>2.1.3.进程控制</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130155518089.png"  alt="image-20201130155518089"></p><h2 id="2-1-4-进程通信"><a class="header-anchor" href="#2-1-4-进程通信">¶</a>2.1.4.进程通信</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130155546050.png"  alt="image-20201130155546050"></p><h2 id="2-1-5-线程的概念与特点"><a class="header-anchor" href="#2-1-5-线程的概念与特点">¶</a>2.1.5.线程的概念与特点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130155854845.png"  alt="image-20201130155854845"></p><h2 id="2-1-6-线程的实现方式和多线程模型"><a class="header-anchor" href="#2-1-6-线程的实现方式和多线程模型">¶</a>2.1.6.线程的实现方式和多线程模型</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201215090908409.png"  alt="image-20201215090908409"></p><h2 id="2-2-1-调度的概念、层次"><a class="header-anchor" href="#2-2-1-调度的概念、层次">¶</a>2.2.1.调度的概念、层次</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130155951610.png"  alt="image-20201130155951610"></p><h2 id="2-2-2-进程调度的时机、切换与过程、方式"><a class="header-anchor" href="#2-2-2-进程调度的时机、切换与过程、方式">¶</a>2.2.2.进程调度的时机、切换与过程、方式</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160023943.png"  alt="image-20201130160023943"></p><h2 id="2-2-3-调度算法的评价指标"><a class="header-anchor" href="#2-2-3-调度算法的评价指标">¶</a>2.2.3.调度算法的评价指标</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160055189.png"  alt="image-20201130160055189"></p><h2 id="2-2-4-调度算法：先来先服务、最短作业优先、最高响应比优先"><a class="header-anchor" href="#2-2-4-调度算法：先来先服务、最短作业优先、最高响应比优先">¶</a>2.2.4.调度算法：先来先服务、最短作业优先、最高响应比优先</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160128395.png"  alt="image-20201130160128395"></p><h2 id="2-2-5-调度算法：时间片轮转、优先级、多级反馈队列"><a class="header-anchor" href="#2-2-5-调度算法：时间片轮转、优先级、多级反馈队列">¶</a>2.2.5.调度算法：时间片轮转、优先级、多级反馈队列</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160153367.png"  alt="image-20201130160153367"></p><h2 id="2-3-1-什么是进程同步、进程互斥"><a class="header-anchor" href="#2-3-1-什么是进程同步、进程互斥">¶</a>2.3.1.什么是进程同步、进程互斥</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160240210.png"  alt="image-20201130160240210"></p><h2 id="2-3-2-进程互斥的软件实现方法"><a class="header-anchor" href="#2-3-2-进程互斥的软件实现方法">¶</a>2.3.2.进程互斥的软件实现方法</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160302185.png"  alt="image-20201130160302185"></p><h2 id="2-3-3-进程互斥的硬件实现方法"><a class="header-anchor" href="#2-3-3-进程互斥的硬件实现方法">¶</a>2.3.3.进程互斥的硬件实现方法</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160325806.png"  alt="image-20201130160325806"></p><h2 id="2-3-4-信号量机制"><a class="header-anchor" href="#2-3-4-信号量机制">¶</a>2.3.4.信号量机制</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160348927.png"  alt="image-20201130160348927"></p><h2 id="2-3-5-用信号量实现进程互斥、同步、前驱关系"><a class="header-anchor" href="#2-3-5-用信号量实现进程互斥、同步、前驱关系">¶</a>2.3.5.用信号量实现进程互斥、同步、前驱关系</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160413883.png"  alt="image-20201130160413883"></p><h2 id="2-3-6-生产者-消费者问题"><a class="header-anchor" href="#2-3-6-生产者-消费者问题">¶</a>2.3.6.生产者-消费者问题</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160527320.png"  alt="image-20201130160527320"></p><h2 id="2-3-7-多生产者-多消费者"><a class="header-anchor" href="#2-3-7-多生产者-多消费者">¶</a>2.3.7.多生产者-多消费者</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160545385.png"  alt="image-20201130160545385"></p><h2 id="2-3-8-吸烟者问题"><a class="header-anchor" href="#2-3-8-吸烟者问题">¶</a>2.3.8.吸烟者问题</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160602530.png"  alt="image-20201130160602530"></p><h2 id="2-3-9-读者-写者问题"><a class="header-anchor" href="#2-3-9-读者-写者问题">¶</a>2.3.9.读者-写者问题</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160621147.png"  alt="image-20201130160621147"></p><h2 id="2-3-10-哲学家进餐问题"><a class="header-anchor" href="#2-3-10-哲学家进餐问题">¶</a>2.3.10.哲学家进餐问题</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160637088.png"  alt="image-20201130160637088"></p><h2 id="2-3-11-管程"><a class="header-anchor" href="#2-3-11-管程">¶</a>2.3.11.管程</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160652836.png"  alt="image-20201130160652836"></p><h2 id="2-4-1-死锁的概念"><a class="header-anchor" href="#2-4-1-死锁的概念">¶</a>2.4.1.死锁的概念</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160718910.png"  alt="image-20201130160718910"></p><h2 id="2-4-2-死锁的处理策略—预防死锁"><a class="header-anchor" href="#2-4-2-死锁的处理策略—预防死锁">¶</a>2.4.2.死锁的处理策略—预防死锁</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160741688.png"  alt="image-20201130160741688"></p><h2 id="2-4-3-死锁的处理策略—避免死锁"><a class="header-anchor" href="#2-4-3-死锁的处理策略—避免死锁">¶</a>2.4.3.死锁的处理策略—避免死锁</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160807954.png"  alt="image-20201130160807954"></p><h2 id="2-4-4-死锁的处理策略—死锁的检测与解除"><a class="header-anchor" href="#2-4-4-死锁的处理策略—死锁的检测与解除">¶</a>2.4.4.死锁的处理策略—死锁的检测与解除</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201130160832482.png"  alt="image-20201130160832482"></p><h1>第三章</h1><h2 id="3-1-1-内存的基础知识"><a class="header-anchor" href="#3-1-1-内存的基础知识">¶</a>3.1_1_内存的基础知识</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223184850554.png"  alt="image-20201223184850554"></p><h2 id="3-1-2-内存管理的概念"><a class="header-anchor" href="#3-1-2-内存管理的概念">¶</a>3.1_2_内存管理的概念</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223184920556.png"  alt="image-20201223184920556"></p><h2 id="3-1-3-覆盖与交换"><a class="header-anchor" href="#3-1-3-覆盖与交换">¶</a>3.1_3_覆盖与交换</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223184943962.png"  alt="image-20201223184943962"></p><h2 id="3-1-4-连续分配管理方式"><a class="header-anchor" href="#3-1-4-连续分配管理方式">¶</a>3.1_4_连续分配管理方式</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185011753.png"  alt="image-20201223185011753"></p><h2 id="3-1-5-动态分区分配算法"><a class="header-anchor" href="#3-1-5-动态分区分配算法">¶</a>3.1_5_动态分区分配算法</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185037811.png"  alt="image-20201223185037811"></p><h2 id="3-1-6-基本分页存储管理的基本概念"><a class="header-anchor" href="#3-1-6-基本分页存储管理的基本概念">¶</a>3.1_6_基本分页存储管理的基本概念</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185108844.png"  alt="image-20201223185108844"></p><h2 id="3-1-7-基本地址变换机构"><a class="header-anchor" href="#3-1-7-基本地址变换机构">¶</a>3.1_7_基本地址变换机构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185134717.png"  alt="image-20201223185134717"></p><h2 id="3-1-8-具有快表的地址变换机构"><a class="header-anchor" href="#3-1-8-具有快表的地址变换机构">¶</a>3.1_8_具有快表的地址变换机构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185157788.png"  alt="image-20201223185157788"></p><h2 id="3-1-9-两级页表"><a class="header-anchor" href="#3-1-9-两级页表">¶</a>3.1_9_两级页表</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185228648.png"  alt="image-20201223185228648"></p><h2 id="3-1-10-基本分段存储管理方式"><a class="header-anchor" href="#3-1-10-基本分段存储管理方式">¶</a>3.1_10_基本分段存储管理方式</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185256398.png"  alt="image-20201223185256398"></p><h2 id="3-1-11-段页式管理方式"><a class="header-anchor" href="#3-1-11-段页式管理方式">¶</a>3.1_11_段页式管理方式</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185319810.png"  alt="image-20201223185319810"></p><h2 id="3-2-1-虚拟内存的基本概念"><a class="header-anchor" href="#3-2-1-虚拟内存的基本概念">¶</a>3.2_1_虚拟内存的基本概念</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185342059.png"  alt="image-20201223185342059"></p><h2 id="3-2-2-请求分页管理方式"><a class="header-anchor" href="#3-2-2-请求分页管理方式">¶</a>3.2_2_请求分页管理方式</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185405783.png"  alt="image-20201223185405783"></p><h2 id="3-2-3-页面置换算法"><a class="header-anchor" href="#3-2-3-页面置换算法">¶</a>3.2_3_页面置换算法</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185453974.png"  alt="image-20201223185453974"></p><h2 id="3-2-4-页面分配策略"><a class="header-anchor" href="#3-2-4-页面分配策略">¶</a>3.2_4_页面分配策略</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185527203.png"  alt="image-20201223185527203"></p><h1>第四章</h1><h2 id="4-1-1-初识文件管理"><a class="header-anchor" href="#4-1-1-初识文件管理">¶</a>4.1_1_初识文件管理</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185745194.png"  alt="image-20201223185745194"></p><h2 id="4-1-2-文件的逻辑结构"><a class="header-anchor" href="#4-1-2-文件的逻辑结构">¶</a>4.1_2_文件的逻辑结构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185805827.png"  alt="image-20201223185805827"></p><h2 id="4-1-3-文件目录"><a class="header-anchor" href="#4-1-3-文件目录">¶</a>4.1_3_文件目录</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185833590.png"  alt="image-20201223185833590"></p><h2 id="4-1-4-4-1-5-文件的物理结构"><a class="header-anchor" href="#4-1-4-4-1-5-文件的物理结构">¶</a>4.1_4+4.1_5_文件的物理结构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223185947141.png"  alt="image-20201223185947141"></p><h2 id="4-1-6-逻辑结构VS物理结构"><a class="header-anchor" href="#4-1-6-逻辑结构VS物理结构">¶</a>4.1_6_逻辑结构VS物理结构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190025398.png"  alt="image-20201223190025398"></p><h2 id="4-1-7-文件的基本操作"><a class="header-anchor" href="#4-1-7-文件的基本操作">¶</a>4.1_7_文件的基本操作</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190048001.png"  alt="image-20201223190048001"></p><h2 id="4-1-8-文件存储空间管理"><a class="header-anchor" href="#4-1-8-文件存储空间管理">¶</a>4.1_8_文件存储空间管理</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190109432.png"  alt="image-20201223190109432"></p><h2 id="4-1-9-文件共享"><a class="header-anchor" href="#4-1-9-文件共享">¶</a>4.1_9_文件共享</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190132632.png"  alt="image-20201223190132632"></p><h2 id="4-1-10-文件保护"><a class="header-anchor" href="#4-1-10-文件保护">¶</a>4.1_10_文件保护</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190152059.png"  alt="image-20201223190152059"></p><h2 id="4-1-11-文件系统的层次结构"><a class="header-anchor" href="#4-1-11-文件系统的层次结构">¶</a>4.1_11_文件系统的层次结构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190209262.png"  alt="image-20201223190209262"></p><h2 id="4-2-1-磁盘的结构"><a class="header-anchor" href="#4-2-1-磁盘的结构">¶</a>4.2_1_磁盘的结构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190227916.png"  alt="image-20201223190227916"></p><h2 id="4-2-2-磁盘调度算法"><a class="header-anchor" href="#4-2-2-磁盘调度算法">¶</a>4.2_2_磁盘调度算法</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190247897.png"  alt="image-20201223190247897"></p><h2 id="4-2-3-减少磁盘延迟时间的方法"><a class="header-anchor" href="#4-2-3-减少磁盘延迟时间的方法">¶</a>4.2_3_减少磁盘延迟时间的方法</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190304207.png"  alt="image-20201223190304207"></p><h2 id="4-2-4-磁盘的管理"><a class="header-anchor" href="#4-2-4-磁盘的管理">¶</a>4.2_4_磁盘的管理</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190326242.png"  alt="image-20201223190326242"></p><h1>第五章</h1><h2 id="5-1-1-IO设备的基本概念和分类"><a class="header-anchor" href="#5-1-1-IO设备的基本概念和分类">¶</a>5.1_1_IO设备的基本概念和分类</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190533269.png"  alt="image-20201223190533269"></p><h2 id="5-1-2-IO控制器"><a class="header-anchor" href="#5-1-2-IO控制器">¶</a>5.1_2_IO控制器</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190552226.png"  alt="image-20201223190552226"></p><h2 id="5-1-3-IO控制方式"><a class="header-anchor" href="#5-1-3-IO控制方式">¶</a>5.1_3_IO控制方式</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190614810.png"  alt="image-20201223190614810"></p><h2 id="5-1-4-IO软件层次结构"><a class="header-anchor" href="#5-1-4-IO软件层次结构">¶</a>5.1_4_IO软件层次结构</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190722845.png"  alt="image-20201223190722845"></p><h2 id="5-1-5-IO核心子系统"><a class="header-anchor" href="#5-1-5-IO核心子系统">¶</a>5.1_5_IO核心子系统</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201230122551398.png"  alt="image-20201230122551398"></p><h2 id="5-1-6-假脱机技术"><a class="header-anchor" href="#5-1-6-假脱机技术">¶</a>5.1_6_假脱机技术</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190854252.png"  alt="image-20201223190854252"></p><h2 id="5-1-7-设备的分配与回收"><a class="header-anchor" href="#5-1-7-设备的分配与回收">¶</a>5.1_7_设备的分配与回收</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190916528.png"  alt="image-20201223190916528"></p><h2 id="5-1-8-缓冲区管理"><a class="header-anchor" href="#5-1-8-缓冲区管理">¶</a>5.1_8_缓冲区管理</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201223190945058.png"  alt="image-20201223190945058"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;作者：夏日&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作系统详细知识点和习题见我这篇博客：&lt;a href</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>软件工程期末总结</title>
    <link href="https://zss192.github.io/2021/07/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>https://zss192.github.io/2021/07/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</id>
    <published>2021-07-05T08:41:56.000Z</published>
    <updated>2021-07-05T08:41:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>作者：夏日<br>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><p>文章主要对结构化分析和面向对象分析画图做了下总结并预测了几个简答题。</p><p>画图建议：由于画图题基本没有标准答案，一定要看着像那么回事，无明显错误</p><p>可结合这位不愿透漏姓名的大佬的总结：<a href="https://blog.csdn.net/weixin_43790779/article/details/112373776">软件工程期末概念复习</a></p><h1>结构化分析(面向过程分析)</h1><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102230911315.png"  alt="image-20210102230911315"></p><h2 id="数据流图"><a class="header-anchor" href="#数据流图">¶</a>数据流图</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102230702494.png"  alt="image-20210102230702494"></p><p>画数据流图步骤</p><ul><li>第一步：画系统的输入和输出（画出顶层图）</li><li>第二步：画系统内部（0层图）</li><li>第三步：画加工内部</li><li>第四步：重复第3步，直至每个尚未分解的加工都足<br>够简单(即不必再分解)</li></ul><p><strong>例题1</strong></p><p>资格和水平考试的考务处理系统—功能需求</p><p>1．对考生送来的报名单进行检查</p><p>2．对合格的报名单编好准考证号后将准考证送给考生，并将汇总后的考生名单送给阅卷站</p><p>3．对阅卷站送来的成绩清单进行检查，并根据考试中心制订的合格标准审定合格者</p><p>4．制作考生通知单送给考生</p><p>5．进行成绩分类统计(按地区、年龄、文化程度、职业、考试级别等分类)和试题难度分析，产生统计分析表</p><h3 id="画顶层图"><a class="header-anchor" href="#画顶层图">¶</a>画顶层图</h3><ul><li>顶层图唯一的加工：软件系统(考务处理系统)<ul><li>用圆圈表示</li></ul></li><li>确定源或宿：考生、阅卷站和考试中心<ul><li>用方框表示</li></ul></li><li>确定数据流：系统的输入/输出信息<ul><li>用箭头表示</li></ul></li></ul><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102231038003.png"  alt="image-20210102231038003" style="zoom: 67%;" /><p>由此可得出顶层图</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102231136410.png"  alt="image-20210102231136410" style="zoom:67%;" /><h3 id="画0层图"><a class="header-anchor" href="#画0层图">¶</a>画0层图</h3><ul><li>确定加工(主要看动词，大概有什么功能)</li><li>确定数据流</li><li>确定文件</li><li>确定源和宿（可画可不画，统一下考试不画源和宿）</li></ul><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102231657785.png"  alt="image-20210102231657785" style="zoom:67%;" /><blockquote><p>注意对子系统标序号，注意要有文件</p></blockquote><h3 id="画1层图"><a class="header-anchor" href="#画1层图">¶</a>画1层图</h3><blockquote><p>关注题目描述中的具体动词，结合0层图的输入输出，看看具体是怎么实现0层图的功能的</p></blockquote><p>考试报名1层图</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102232351962.png"  alt="image-20210102232351962" style="zoom:67%;" /><p>统计成绩1层图</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102232426342.png"  alt="image-20210102232426342" style="zoom:67%;" /><h2 id="系统结构图"><a class="header-anchor" href="#系统结构图">¶</a>系统结构图</h2><p>概要设计：将数据流图映射为软件系统结构图。说明系统结构图要根据数据流图来画。</p><p>下面是教材P168的两个例子</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/341162393.jpg"  alt="341162393"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/webwxgetmsgimg.jpg"  alt="webwxgetmsgimg"></p><p>实验中例子</p><blockquote><p>助记：方框带圈箭头画结构</p><p>左输入、右输出、中间做处理</p><p>方框箭头从上到下，数据流从最左到最右，中间既可上也可下</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/wps4DOEEO.png"  alt="img"></p><h1>面向对象分析</h1><h2 id="用例描述"><a class="header-anchor" href="#用例描述">¶</a>用例描述</h2><p>PPT模板</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/rg31.PNG"  alt="img"></p><p>实验中分配宿舍用例</p><blockquote><p>助记：即这个用例：叫什么(用例名)、是什么(用例描述)</p><p>谁来参与(参与者)、怎么参与(基本路径)、参与前要怎么样(前置条件)、参与后又会怎么样(后置条件)</p><p>出错了怎么办(其它路径)</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210103000955626.png"  alt="image-20210103000955626"></p><h2 id="用例图"><a class="header-anchor" href="#用例图">¶</a>用例图</h2><blockquote><p>助记：包含拓展用英语，特例小三角箭头</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210108152957239.png"  alt="image-20210108152957239"></p><p>1.PPT用例图(第八九讲-P32) 92页还有个例子</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210103001120881.png"  alt="image-20210103001120881"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107005740882.png"  alt="image-20210107005740882"></p><p>2.实验用例图</p><blockquote><p>助记：几个小人一个框，圆圈里面放动作</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/wpsaM9XTz.png"  alt="img"></p><h2 id="类图"><a class="header-anchor" href="#类图">¶</a>类图</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107075837195.png"  alt="image-20210107075837195"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107075947296.png"  alt="image-20210107075947296"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107080154033.png"  alt="image-20210107080154033"></p><p>1.实验中分配宿舍类图</p><blockquote><p>抓住三个方面：界面是什么？方法是什么？用到了哪些数据？</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/wpsziar40.png"  alt="img"></p><p>2.PPT中开户类图(第八九讲P86)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210103000619089.png"  alt="image-20210103000619089"></p><h2 id="顺序图"><a class="header-anchor" href="#顺序图">¶</a>顺序图</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107080154033.png"  alt="image-20210107080154033"></p><blockquote><p>助记：界面要倒&quot;T&quot;，数据要落地，转着圈的做动作</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107005125795.png"  alt="image-20210107005125795"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107010427599.png"  alt="image-20210107010427599"></p><p>分配宿舍顺序图</p><blockquote><p>助记：从左到右转个圈，一步一序号，一步一动作</p><p>左人物、右界面、动作数据&quot;乱序&quot;放。去时实线来时虚</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/wpsoWuNs3.png"  alt="img"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107010052052.png"  alt="image-20210107010052052"></p><h1>知识点</h1><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107002007713.png"  alt="image-20210107002007712"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210107003941914.png"  alt="image-20210107003941912"></p><h1>预测简答题</h1><p>1.什么是软件？什么是软件危机？</p><p>答：软件：软件=程序+文档+数据</p><ul><li>程序是按事先设计的功能和性能要求执行的指令序列<br>程序=算法+数据结构</li><li>数据是指程序初始化数据、测试数据、以及研发数据、维护数据等</li><li>文档是与程序开发、维护和使用有关的图文材料</li></ul><p>软件危机：指在软件的<strong>开发和维护</strong>过程中所遇到的一系列严重问题。典型表现是开发<strong>成本</strong>高，<strong>周期</strong>长，<strong>质量</strong>差，满足不了<strong>市场需求</strong></p><p>2.什么是软件工程？什么是软件过程？</p><p>答：软件工程：软件工程是将<strong>系统化</strong>、<strong>规范化</strong>、<strong>可度量</strong>的方法应用于软件开发、运行和维护过程，即将工程化应用于软件中的方法的研究。是将计算机科学、管理科学等理论运用于指导软件开发与维护的一门交叉学科。</p><p>软件过程：是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</p><p>3.软件生命周期主要包括哪些阶段？请简要说明各阶段的主要任务</p><p>答：<br>1、问题定义：要解决的问题是什么</p><p>2、可行性分析：对于上一阶段的问题有行得通的解决办法吗</p><p>3、需求分析：目标系统必须做什么</p><p>4、概要设计：概括的说应该怎么实现这个系统，确定系统功能及模块结构</p><p>5、详细设计：具体怎么实现这个系统，确定每个模块的算法和使用结构</p><p>6、编码和单元测试：在前面阶段的基础上写出正确的代码并对每个模块进行测试</p><p>7、综合测试：通过各种测试和调试，发现系统可能存在的缺陷</p><p>8、运行维护：保证软件正常运行</p><blockquote><p>软件生命周期：软件产品从<strong>考虑其概念</strong>开始到<strong>交付使用</strong>，直至最终<strong>退役</strong>为止的整个过程</p><p>分三类则为：</p><ul><li><p>软件定义：确定待开发的软件系统要做什么，又称为系统分析。可进一步划分为问题定义，可行性研究，需求分析3个阶段</p></li><li><p>软件开发：具体设计和实现软件。分为概要设计，详细设计，编码和单元测试、综合测试4个阶段，前两个统称为系统设计，后两个统称为系统实现</p></li><li><p>运行维护：是根据软件运行中的问题，对其进行修改，使系统能持久的满足用户需求</p></li></ul></blockquote><p>4.比较面向对象开发方法与结构化开发方法的异同？</p><p>答：结构化方法的最大特点是<strong>面向功能分解</strong>问题。但由于处理与数据是分离的，并且在设计阶段与分析阶段采用不同的模型。</p><ul><li><p>优点是：<strong>简单、实用</strong>，适合于瀑布模型，易于为开发者掌握，特别适合于数据处理领域中的应用。</p></li><li><p>缺点是：对于规模大、复杂的项目不太适应；难以解决软件重用，难于适应需求变化，难以解决维护问题。</p></li></ul><p>面向对象方法以最稳定的对象与类系统作为考虑问题的出发点，通过不断反复、累增，逐步改进系统，从而更易获得符合用户需求、简单可靠、适应性强的系统。面向对象方法<strong>强调对象结构</strong>，而不是程序结构，从而解决了抽象和重用问题，成为当今的主流模式。</p><p>5.什么是黑盒测试？什么是白盒测试？</p><p>答：<strong>黑盒测试：<strong>完全</strong>不考虑</strong>程序的<strong>内部结构和处理过程</strong>，只知道软件产品应该具有的功能，通过测试检验每个功能是否都能正常使用。又称为功能性测试或行为测试。<br><strong>白盒测试：<strong>有时称为透明盒测试，已知产品内部工作过程，通过</strong>测试</strong>检验产品<strong>内部动作</strong>是否按照产品规格说明的规定<strong>正常进行</strong>。</p><blockquote><p>**静态测试：**是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。<br>**动态测试：**是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率和健壮性等性能。</p></blockquote><p>6.说明软件测试和调试的目的有何区别？<br>答：测试的目的是<strong>判断和发现</strong>软件是否有错误</p><p>调试的目的是<strong>定位</strong>软件错误<strong>并纠正</strong>错误</p><p>7.分析软件危机产生的主要原因有哪些？</p><p>答：（1）软件日益复杂和庞大 （2）软件开发管理困难和复杂  （3）软件开发技术落后</p><p>（4）开发工具落后  （5）生产方式落后 （6）软件开发费用不断增加</p><blockquote><p>助记：一个增加、俩复杂、仨落后</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;作者：夏日&lt;br&gt;
博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章主要对结构化分析和面向对象分析画图做了下总结并预测了几</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>软件安全期末总结</title>
    <link href="https://zss192.github.io/2021/07/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    <id>https://zss192.github.io/2021/07/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/</id>
    <published>2021-07-05T08:41:56.000Z</published>
    <updated>2021-07-05T08:41:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>所用教材：彭国军等人编著的第一版</p><p>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><p>说明：博客为根据老师所画重点有针对性的总结，供个人复习使用，仅供参考</p><h1>第一章 软件安全概述</h1><h3 id="1-软件安全包括三个方面：（P5）"><a class="header-anchor" href="#1-软件安全包括三个方面：（P5）">¶</a>1.软件安全包括三个方面：（P5）</h3><ul><li>软件自身安全(软件缺陷与漏洞)、恶意软件攻击与检测、软件逆向分析(软件破解)与防护</li></ul><h3 id="2-软件缺陷或漏洞被触发后典型的威胁有：（P6）"><a class="header-anchor" href="#2-软件缺陷或漏洞被触发后典型的威胁有：（P6）">¶</a>2.软件缺陷或漏洞被触发后典型的威胁有：（P6）</h3><ul><li>软件正常功能被破坏、系统被恶意控制</li></ul><h3 id="3-恶意软件对软件及信息系统的威胁有：（P6）"><a class="header-anchor" href="#3-恶意软件对软件及信息系统的威胁有：（P6）">¶</a>3.恶意软件对软件及信息系统的威胁有：（P6）</h3><ul><li>已有软件的功能被修改或破坏</li><li>目标系统中的重要数据被窃取</li><li>目标系统中的用户行为被监视</li><li>目标系统被控制</li></ul><h3 id="4-微软的SDL开发模式（P9）"><a class="header-anchor" href="#4-微软的SDL开发模式（P9）">¶</a>4.微软的SDL开发模式（P9）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210625144914501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="5-可信计算的基本思想（P10简答）"><a class="header-anchor" href="#5-可信计算的基本思想（P10简答）">¶</a>5.可信计算的基本思想（P10简答）</h3><p>首先建立一个信任根，信任根的可信性由物理安全和管理安全确保(目前以TPM作为信任根)，再建立一条信任链,从信任根开始到硬件平台、到操作系统、再到应用，一级认证一级，一级信任一级，从而把这种信任边界扩展到整个计算机系统。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210625145003905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1>第二章 软件安全基础</h1><h3 id="1-磁盘的三个基本参数-CHS参数-P13计算"><a class="header-anchor" href="#1-磁盘的三个基本参数-CHS参数-P13计算">¶</a>1.磁盘的三个基本参数(CHS参数) (P13计算)</h3><ul><li>磁头数：有多少个盘片，最大为255(0-255)</li><li>柱面数：一个盘片有多少圈，最大为1023(0-1023)</li><li>扇区数：一圈有多少个扇区，最大为63(1-63)（每个扇区一般为512B）</li><li>最大容量 = (255x1023x63x512)/1048576=8024MB（1MB=2<sup>20</sup>B=1048576B）</li></ul><blockquote><p>最大容量=磁头数x柱面数x扇区数x每个扇区的大小<br>硬件厂商一般用1M=1000000计算容量，注意单位换算</p></blockquote><h3 id="2-BIOS-Int13H（P13）"><a class="header-anchor" href="#2-BIOS-Int13H（P13）">¶</a>2.BIOS Int13H（P13）</h3><p>BIOS Int13H调用是BIOS提供的磁盘基本输入输出中断调用，它可以完成磁盘的复位、读写、检验、定位、诊断、格式化等功能，使用CHS寻址方式，最大能识别8GB左右的硬盘。</p><h3 id="3-主引导扇区的组成（P15）"><a class="header-anchor" href="#3-主引导扇区的组成（P15）">¶</a>3.主引导扇区的组成（P15）</h3><p>主引导扇区就是硬盘的第一个扇区(0面0磁道1扇区)，它由以下三部分组成</p><ul><li>主引导记录(MBR)：占用前446字节，存放着系统主引导程序<ul><li>MBR有时也指整个主引导扇区，有时指前446字节的主引导记录</li></ul></li><li>硬盘主分区表(DPT)：占用64字节，记录磁盘的基本分区信息。分为四个分区项，每项16字节，分别记录每个主分区的信息(因此最多可以有4个主分区)</li><li>引导扇区标记：占用两个字节，合法引导区固定等于0xAA55，是判断引导区是否合法的标志</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210626224349.jpg"  alt=""></p><h3 id="4-主分区、扩展分区和逻辑分区的区别（P16）"><a class="header-anchor" href="#4-主分区、扩展分区和逻辑分区的区别（P16）">¶</a>4.主分区、扩展分区和逻辑分区的区别（P16）</h3><ul><li>主分区：也叫引导分区，最多能创建4个，主分区就是引导电脑开机读取文件的一个磁盘分区（数量1-4）</li><li>扩展分区：解决最多只能创建4个分区的问题，主引导分区必须有一个基本扩展分区项，其它扩展分区以链表形式存放。划分主分区后剩余的就是扩展分区。（数量0-1且主分区+扩展分区≤4）</li><li>逻辑分区：扩展分区并不能直接使用，必须再分成逻辑分区才能使用（数量0-n）</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210626224248.jpg"  alt=""></p><blockquote><p>系统中看到的盘都是主分区或者逻辑分区</p><p>助记：正常情况只需要划分主分区，但要想划分4个以上分区就要划分扩展分区，这时会有3个主分区1个扩展分区，但扩展分区不能直接用，我们可以再在其基础上划分成两个逻辑分区，这两个分区就是我们平常看到的盘，至此，当前共有3+2=5个分区可用。如果扩展分区并不全都划分成逻辑分区，那么剩余的磁盘空间还是扩展分区，只不过这部分空间不能使用。</p><p>新硬盘建立分区过程：建立主分区→建立扩展分区→建立逻辑分区→激活主分区→格式化所有分区</p></blockquote><p><img src="/" class="lazyload" data-src="https://pic4.zhimg.com/80/ab32617b085d43ab312d311e9417bc65_720w.jpg?source=1940ef5c"  alt="img"></p><p><img src="/" class="lazyload" data-src="https://pic2.zhimg.com/80/deb2ed8191d13feaac4acd09a5f893bd_720w.jpg?source=1940ef5c"  alt="img"></p><h3 id="5-当前系统流行的引导形式是什么？它与BIOS引导有什么区别？（P15）"><a class="header-anchor" href="#5-当前系统流行的引导形式是什么？它与BIOS引导有什么区别？（P15）">¶</a>5.当前系统流行的引导形式是什么？它与BIOS引导有什么区别？（P15）</h3><p>传统模式：BIOS引导，硬盘分区类型必须是MBR</p><p>当前模式：UEFI引导，硬盘分区类型必须是GPT</p><p>区别如下：</p><p>（1）效率方面：大部分BIOS代码使用汇编语言开发，开发效率低；在UEFI中，绝大部分代码采用C语言编写，效率较高。<br>（2）性能方面：BOIS需要通过中断来完成，开销大，性能低；UEFI舍弃了中断方式，仅仅保留了时钟中断。外部设备的操作采用“事件+异步操作”完成，性能大大提高。<br>（3）扩展性方面：BIOS代码采用静态链接，不提供动态加载设备驱动的方案，功能扩展性差，升级缓慢；UEFI系统的可扩展性体现在两个方面：一是驱动的模块化设计；二是软硬件升级的兼容性，使得系统升级过程更加简单、平滑。<br>（4）安全方面：BIOS运行过程中对可执行代码没有安全方面的考虑；当系统的安全启动功能被打开后，UEFI在执行应用程序和驱动前会先检测程序和驱动的证书，仅当证书被信任时才会执行这个应用程序或驱动。</p><h3 id="6-文件系统（P16）"><a class="header-anchor" href="#6-文件系统（P16）">¶</a>6.文件系统（P16）</h3><ul><li>Windows系统：FAT12、FAT16、FAT32(单个文件最大4G)、NTFS、WINFS等</li><li>Linux系统：Ext2、Ext3、Ext4、Minix、NTFS等</li></ul><h3 id="7-80X86处理器支持三种工作模式（P20）"><a class="header-anchor" href="#7-80X86处理器支持三种工作模式（P20）">¶</a>7.80X86处理器支持三种工作模式（P20）</h3><ul><li>实模式：复位或加电以实模式启动<ul><li>32位地址线只用了低20位</li><li>不能分页，指令寻址的地址就是实际物理地址</li><li>不支持优先级，所有指令工作在特权级别(优先级0)</li></ul></li><li>保护模式：80X86的一般工作模式<ul><li>32位地址都用来寻址</li><li>支持内存分页</li><li>支持虚拟内存</li><li>支持优先级机制，操作系统运行在内核模式Ring0(最高优先级)，应用程序运行在用户模式Ring3</li></ul></li><li>虚拟8086模式：在保护模式下兼容8086而设置的</li></ul><blockquote><p>DOS运行在实模式下，Windows运行在保护模式下</p></blockquote><h3 id="8-（P23）"><a class="header-anchor" href="#8-（P23）">¶</a>8.（P23）</h3><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210626225930.jpg"  width="500" /><p>用户空间：0000 0000H ~ 7FFF FFFFH</p><p>系统空间：8000 0000H ~ FFFF FFFFH</p><blockquote><p>推测给地址问在哪个空间下，只需看第一位是0-7还是8-F即可判断出来</p></blockquote><h3 id="9-内存分配与管理函数（P26）"><a class="header-anchor" href="#9-内存分配与管理函数（P26）">¶</a>9.内存分配与管理函数（P26）</h3><ul><li>分配/保留虚拟内存：VirtualAlloc(lpMem,Size,Type,Access)<ul><li>lpMem：要分配/保留的内存地址，可以为NULL</li><li>Size：要分配的内存大小，字节为单位</li><li>Type：分配的类型，如MEM_COMMINT(提交内存)</li><li>Access：保护标志，如PAGE_READONLY、PAGE_READ-WRITE(分配的内存可读可写)</li></ul></li><li>释放虚拟内存：VirtualFree(LpMem,Size,Type)<ul><li>lpMem：要释放的内存基地址</li><li>Size：要分配的内存大小，字节为单位</li><li>Type：释放的类型，如MEM_DECOMMINT(取消提交内存)、MEM_RELEASE(释放)</li></ul></li></ul><h3 id="10-请你大致写出计算机的启动过程（P28简答）"><a class="header-anchor" href="#10-请你大致写出计算机的启动过程（P28简答）">¶</a>10.请你大致写出计算机的启动过程（P28简答）</h3><p>主要可分为四个阶段</p><ul><li>（1）BIOS：首先进行硬件自检(POST)，若有故障会发出蜂鸣声，然后按照启动顺序选择从哪个设备启动</li><li>（2）主引导记录(MBR)：读取设备的前512字节，判断设备能否启动，若不能则按启动顺序尝试启动下一个设备。然后BIOS会依次遍历主分区找到激活分区</li><li>（3）硬盘启动：计算机会读取激活分区的第一个扇区即卷引导记录(VBR），VBR告诉计算机操作系统位于该分区的哪个位置，然后计算机就可以加载操作系统了</li><li>（4）操作系统：首先载入操作系统的内核。例如Linux，先载入/boot下的kernel，然后产生init进程，init进程会加载各个模块，等待用户输入用户名和密码。至此，全部启动过程完成。</li></ul><h3 id="11-PE文件格式（P34）"><a class="header-anchor" href="#11-PE文件格式（P34）">¶</a>11.PE文件格式（P34）</h3><p>PE(Portable Executable,可移植的执行体)是Win32环境自身所带的可执行文件格式。它的一些特性继承自UNIX的COFF(Common Object File Format)文件格式。</p><p>可移植的执行体意味着此文件格式是跨Win32平台的,即使 Windows运行在非 Intel的CPU上，任何Win32平台的PE装载器都能识别和使用该文件格式。</p><p>当然，移植到不同的CPU上PE执行体必然得有一些改变。除VxD和16位的DLL外，所有Win32执行文件都使用PE文件格式。因此,研究PE文件格式是我们洞悉 Windows结构的良机。</p><h3 id="12-一般来说，Win32病毒是怎样被运行的（P35简答）"><a class="header-anchor" href="#12-一般来说，Win32病毒是怎样被运行的（P35简答）">¶</a>12.一般来说，Win32病毒是怎样被运行的（P35简答）</h3><ul><li>用户点击(或者系统自动运行)HOST程序</li><li>装载HOST程序到内存中</li><li>通过PE文件中的ImageBase(优先装载地址即基地址)和AddressOfEntryPoint(代码入口的RVA(偏移)地址)之和定位第一条语句的位置<ul><li>如imagebase：0x40 0000，AddressOfEntryPoint：0x00 12C0，即0x4012c0</li></ul></li><li>从第一条语句开始执行(病毒代码可能在此时，也可能在HOST代码运行过程中获得控制权)</li><li>病毒主体代码执行完毕，将控制权交还给HOST程序</li><li>HOST程序继续执行</li></ul><h3 id="13-PE文件结构（P35）"><a class="header-anchor" href="#13-PE文件结构（P35）">¶</a>13.PE文件结构（P35）</h3><p><img src="/" class="lazyload" data-src="https://www.pianshen.com/images/32/e54937033581df036b0228ad9de2a310.png"  alt="img"></p><h3 id="14-病毒如何判断一个文件是不是PE文件（P37）"><a class="header-anchor" href="#14-病毒如何判断一个文件是不是PE文件（P37）">¶</a>14.病毒如何判断一个文件是不是PE文件（P37）</h3><p>看文件的前两个字节是不是4D5A(MZ)，若不是则说明不是PE文件</p><p>若是，在DOS程序头中的偏移3CH处的四个字节找到PE字串的偏移位置，查看该偏移位置的四个字节是不是50 45 00 00(PE…)，若不是则不是PE文件，若是则认为它是一个PE文件</p><h3 id="15-导出表结构（P43）"><a class="header-anchor" href="#15-导出表结构（P43）">¶</a>15.导出表结构（P43）</h3><blockquote><p>导出表：表明自己可以提供哪些函数供别的程序调用，类似于餐厅的菜单</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210627002618.jpg"  alt=""></p><p>其中AddressOfNameOridinals指向的数组的项目与文件名地址表的项目一一对应，项目的值代表函数入口地址表的索引，这样函数名称就和函数入口地址关联起来了</p><h3 id="16-导入表结构（P44）"><a class="header-anchor" href="#16-导入表结构（P44）">¶</a>16.导入表结构（P44）</h3><blockquote><p>导入表：记录了一个exe或者一个dll所用到的其他模块导出的函数，类似于自己点的菜的清单</p></blockquote><p>结构中比较重要的为Name：DLL名字的指针如指向user32.dll</p><h1>第三章 软件缺陷与漏洞机理概述</h1><h3 id="1-漏洞的分类（P53选择）"><a class="header-anchor" href="#1-漏洞的分类（P53选择）">¶</a>1.漏洞的分类（P53选择）</h3><ul><li>按漏洞可能对系统造成的直接威胁划分<ul><li>获取访问权限漏洞、权限提升漏洞、拒绝服务攻击漏洞、恶意软件植入漏洞、数据丢失或泄露漏洞等</li></ul></li><li>按漏洞的成因划分<ul><li>输入验证错误、访问验证错误、竞争条件错误、意外情况处理错误、设计错误、配置错误、环境错误等</li></ul></li><li>按漏洞的严重等级划分可分为高、中、低三个级别<ul><li>远程和本地管理员对应为高，普通用户权限、权限提升、读取受限文件</li><li>远程和本地拒绝服务对应为中，远程非授权文件存取、口令恢复、欺骗</li><li>服务器信息泄露对应低级</li><li>上面只是通常的情况，具体情况要具体分析，如一个广泛使用软件的口令恢复漏洞应该是中或高级</li></ul></li><li>按对漏洞被利用的方式划分<ul><li>本地攻击、远程主动攻击、远程被动攻击等</li></ul></li></ul><h3 id="2-CVE、CNVD、CNNVD（P54）"><a class="header-anchor" href="#2-CVE、CNVD、CNNVD（P54）">¶</a>2.CVE、CNVD、CNNVD（P54）</h3><ul><li>CVE：MITRE公司建立的通用漏洞列表，将众所周知的安全漏洞的名称标准化，世界最权威的漏洞库。如CVE-2019-0708</li><li>CNVD：国家信息安全漏洞共享平台，类似于补天，厂商和白帽子可以提交漏洞并获得报酬</li><li>CNNVD：中国国家信息安全漏洞库，可以看成中国版的CVE，如CNNVD-202106-1647</li></ul><h3 id="3-请列举近3年来和软件缺陷、漏洞相关的重大安全事件（P64）"><a class="header-anchor" href="#3-请列举近3年来和软件缺陷、漏洞相关的重大安全事件（P64）">¶</a>3.请列举近3年来和软件缺陷、漏洞相关的重大安全事件（P64）</h3><ul><li><p>2019年，PHP7的PHP-FPM存在远程代码执行漏洞，导致攻击者可以控制服务器</p></li><li><p>2020年，微软修复了一个有关ECC证书检测绕过的漏洞，攻击者可以伪造签名，影响全球数十亿用户</p></li><li><p>2021年，高通芯片存在缓冲区溢出漏洞，攻击者可以利用该漏洞获取手机用户的短信、通话记录、监听对话等，且无法被常规系统安全功能检测到，影响全球40%的手机</p></li></ul><h1>第四章 典型软件漏洞机理分析</h1><h3 id="1-缓冲区溢出漏洞（P65）"><a class="header-anchor" href="#1-缓冲区溢出漏洞（P65）">¶</a>1.缓冲区溢出漏洞（P65）</h3><ul><li>缓冲区：指内存空间中用来存储程序运行时临时数据的一片大小有限且连续的内存区域，一般可分为栈和堆，C语言中的数组就是栈缓冲区</li><li>原理：程序在处理用户数据时，未对其大小做适当的限制，或者在拷贝、填充时没限定边界，导致实际操作的数据大小超过了目标缓冲区的大小，使得一些关键数据被覆盖，从而引发安全问题</li><li>利用该漏洞，攻击者可植入并执行攻击代码，获得一定的系统权限，从而得到被攻击主机的控制权</li></ul><h3 id="2-内存根据进程使用的内存区域的预定功能划分（P66）"><a class="header-anchor" href="#2-内存根据进程使用的内存区域的预定功能划分（P66）">¶</a>2.内存根据进程使用的内存区域的预定功能划分（P66）</h3><ul><li>代码区：存储被装入执行的二进制机器代码，通常只读不可修改</li><li>静态数据区：存储全局变量，可划分为初始化的数据区和未初始化的数据区</li><li>动态数据区<ul><li>栈区：存储函数之间的调用关系以及函数内部的变量，保证被调用函数返回时回到父函数中继续执行</li><li>堆区：程序运行时向系统动态申请的内存空间位于堆区，用完之后需主动释放，如C/C++中的malloc/new</li></ul></li></ul><h3 id="3-系统栈（P67）"><a class="header-anchor" href="#3-系统栈（P67）">¶</a>3.系统栈（P67）</h3><ul><li>定义：OS为进程中的每个函数调用都划分了一个栈帧空间，系统栈则是这些函数调用栈帧的集合</li><li>函数返回地址：函数调用语句的后面一条指令的地址，以便返回时能恢复到被调用前的代码区中继续执行</li><li>ESP：栈指针寄存器，存放的是当前栈帧的栈顶指针</li><li>EBP：基址指针寄存器，存放的是当前栈帧的栈底指针</li><li>EIP：指令寄存器，存放的是下一条等待执行的指令地址<ul><li>当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行</li></ul></li></ul><h3 id="4-栈溢出的利用（P69）"><a class="header-anchor" href="#4-栈溢出的利用（P69）">¶</a>4.栈溢出的利用（P69）</h3><ul><li>修改邻接变量：函数的局部变量依次存放在栈帧中，若其中有数组之类的缓冲区，数组越界后可能破坏相邻变量的值，甚至EBP或返回地址</li><li>修改函数返回地址：可随意更改程序指向并执行攻击者植入的代码，实现&quot;自主&quot;控制<ul><li>方法1：将内存中的shellcode的地址赋给返回地址<ul><li>但由于动态链接库的装入和卸载，shellcode的地址是动态变化的，因此之后会出现跳转异常</li><li>且shellcode的开始位置通常为0X00，进行字符串操作如strcpy可能会被截断</li></ul></li><li>方法2：用系统动态链接库中某条处于高地址且位置固定的跳转指令所在的地址进行覆盖，指向动态变化的shellcode地址</li></ul></li><li>S.E.H结构覆盖：程序出错之后系统关闭程序之前，让程序转去执行一个预先设定的回调函数<ul><li>S.E.H即异常处理结构体，发生异常时(如除零)会用到</li><li>方法：把S.E.H中异常处理函数的入口地址改为shellcode的地址或可以跳转到shellcode的跳转指令的地址</li></ul></li></ul><h3 id="5-什么是SQL注入，举个例子（P83简答）"><a class="header-anchor" href="#5-什么是SQL注入，举个例子（P83简答）">¶</a>5.什么是SQL注入，举个例子（P83简答）</h3><p>攻击者通过把SQL命令插入到Web表单或页面请求的查询字符串，从而欺骗服务器执行恶意的SQL命令，通过提交的参数构造巧妙的SQL语句，从而获取数据库中想要的数据</p><p>如判断登录语句，select * from user where username = ‘用户名’ and password = ‘密码’。</p><p>如果根据查询到的结果数量判断账号密码是否正确，我们可以构造username=admin’#&amp;&amp;password=test</p><p>这样查询语句会变成select * from user where username = ‘admin’#’ and password = ‘test’</p><p>由于我们把admin单引号闭合了且加了一个注释符号#，那其实这条语句实际上为select * from user where username = ‘admin’</p><p>这样肯定能查到数据也就实现了任意密码都能成功登录</p><h3 id="6-什么是跨站脚本-XSS-，举个例子（P87）"><a class="header-anchor" href="#6-什么是跨站脚本-XSS-，举个例子（P87）">¶</a>6.什么是跨站脚本(XSS)，举个例子（P87）</h3><p>攻击者嵌入恶意代码到正常网页中，当用户访问该页面时，可导致恶意代码的执行，从而达到攻击用户的目的</p><p>如在http://www.test.com/test.php?message=test网址中，用户输入的message信息会显示在当前界面信息内，而如果我们构造message参数值为message=<script>alert(‘xss’);</script>，这样请求页面时就会出现内容为xss的弹框。当然对攻击者更有利的是劫持用户的cookie或重定向到其它恶意网站</p><h1>第五章 软件漏洞的利用和发现</h1><h3 id="1-什么是Exploit，分为哪几个部分（P95）"><a class="header-anchor" href="#1-什么是Exploit，分为哪几个部分（P95）">¶</a>1.什么是Exploit，分为哪几个部分（P95）</h3><p>Exploit(漏洞利用程序)是针对某一特定漏洞或一组漏洞而精心编写的漏洞利用程序。其可以触发特定漏洞从而获得系统的控制权。</p><p>分为两个部分：被注入到目标进程触发漏洞获得执行权限的二进制串，以及代表攻击者意图的代码</p><h3 id="2-可供攻击者利用的漏洞主要来源（P95）"><a class="header-anchor" href="#2-可供攻击者利用的漏洞主要来源（P95）">¶</a>2.可供攻击者利用的漏洞主要来源（P95）</h3><ul><li>黑客自己独享，未被公布、未被修复的漏洞称为0 day漏洞</li><li>其他黑客发现并公布，可以重现触发漏洞场景的POC代码(验证性代码)</li><li>安全人员或厂商公布的漏洞补丁或公告，黑客采取补丁对比等技术来定位漏洞，并开发Exploit，主要针对未及时更新补丁的用户，有时也被称为1 day或n day漏洞</li></ul><h3 id="3-Exploit结构（P96）"><a class="header-anchor" href="#3-Exploit结构（P96）">¶</a>3.Exploit结构（P96）</h3><p>把漏洞利用比作导弹发射过程，Exploit类似导弹发射装置，针对目标发射出导弹(Payload)，导弹到达目标后，释放实际危 害的弹头(类似Shellcode)爆炸；导弹除弹头外的其余部分用作定位追踪、引爆等功能对应着Payload的非Shellcode部分。</p><p>总的来说，Shellcode用来实现具体的功能，Payload还要考虑如何触发漏洞并让系统去执行Shellcode。因此shellcode往往是通用的，而Payload则是针对特定的漏洞</p><h3 id="4-漏洞利用的具体技术（P96）"><a class="header-anchor" href="#4-漏洞利用的具体技术（P96）">¶</a>4.漏洞利用的具体技术（P96）</h3><ul><li>修改内存变量</li><li>修改代码逻辑</li><li>修改函数返回地址</li><li>修改函数指针</li><li>攻击异常处理机制</li><li>修改P.E.B中线程同步函数的入口地址</li></ul><h3 id="5-什么是shellcode，干什么用的（P97）"><a class="header-anchor" href="#5-什么是shellcode，干什么用的（P97）">¶</a>5.什么是shellcode，干什么用的（P97）</h3><p>Shellcode是一段利用软件漏洞而执行的代码，用来获取shell</p><h3 id="6-函数入栈出栈（P105）"><a class="header-anchor" href="#6-函数入栈出栈（P105）">¶</a>6.函数入栈出栈（P105）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627104132982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><blockquote><p>上图为书上的原图仅供参考，要搞懂函数入栈出栈的具体流程，具体看综合题</p></blockquote><h3 id="7-常见漏洞挖掘技术的分类（P108）"><a class="header-anchor" href="#7-常见漏洞挖掘技术的分类（P108）">¶</a>7.常见漏洞挖掘技术的分类（P108）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627104225824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1>第六章 Windows系统安全机制及漏洞防护技术</h1><h3 id="1-GS编译选项（120）"><a class="header-anchor" href="#1-GS编译选项（120）">¶</a>1.GS编译选项（120）</h3><p>微软在Visual Studio编译器中加入了/GS编译选项，通过向函数的开头和结尾添加代码来阻止针对典型栈溢出漏洞的利用</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210627152615892.png"  alt="image-20210627152615892"></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191019163806720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyY2hpY2tlbmNoaWNrZW4=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>VC++6.0的编译器的设置 如静态加载</p><p>（1）直接用project&gt;add to project&gt;files的方式将.lib加入工程</p><p>（2）使用#pragma指令，如#pragma comment(lib, “your lib path and name”)</p><p>（3）在project&gt;settings&gt;link&gt;input的Additional library path中输入.lib文件所在路径</p><p><img src="/" class="lazyload" data-src="https://images2015.cnblogs.com/blog/745381/201510/745381-20151027161856013-86617546.png"  alt="img"></p><p>（4）在project-&gt;settting与Tools-&gt;Options-&gt;Directories指定路径</p><p><img src="/" class="lazyload" data-src="https://images2015.cnblogs.com/blog/745381/201510/745381-20151027162223263-831616859.png"  alt="img"></p><blockquote><p>考试出选择，会放一个设置里的图片让选</p></blockquote><h1>第八章 恶意代码及其分类</h1><h3 id="1-Rootkit（P156）"><a class="header-anchor" href="#1-Rootkit（P156）">¶</a>1.Rootkit（P156）</h3><ul><li>定义：是攻击者用来隐藏自己的踪迹和保留root访问权限的工具。Rootkit一般都和木马、后门等其他恶意程序结合使用（为统一，此处为恶意代码教材的定义）</li></ul><h3 id="2-流氓软件也称灰色软件，特点如下（P156）"><a class="header-anchor" href="#2-流氓软件也称灰色软件，特点如下（P156）">¶</a>2.流氓软件也称灰色软件，特点如下（P156）</h3><p>强制安装、难以卸载、浏览器劫持、广告弹出、恶意收集用户信息、恶意卸载、恶意捆绑</p><h3 id="3-僵尸程序（P126）"><a class="header-anchor" href="#3-僵尸程序（P126）">¶</a>3.僵尸程序（P126）</h3><p>僵尸(bot)程序是指实现恶意控制功能的程序代码。</p><p>僵尸网络：指采用一种或多种传播手段，将大量主机感染僵尸程序，从而在控制者和被感染主机之间形成一对多的控制的网络。攻击者可利用此发起DDOS攻击或发送垃圾邮件</p><h3 id="4-Exploit（P158）"><a class="header-anchor" href="#4-Exploit（P158）">¶</a>4.Exploit（P158）</h3><p>Exploit(漏洞利用程序)是针对某一特定漏洞或一组漏洞而精心编写的漏洞利用程序。其可以触发特定漏洞从而获得系统的控制权。可分为主机系统漏洞Exploit、文档类漏洞Exploit、网页挂马类Exploit</p><h1>第九章恶意代码机理分析</h1><h3 id="1-计算机病毒的特点与分类-（P161背）"><a class="header-anchor" href="#1-计算机病毒的特点与分类-（P161背）">¶</a>1.计算机病毒的特点与分类 （P161背）</h3><ul><li>传播性</li><li>非授权性</li><li>隐蔽性</li><li>潜伏性</li><li>破坏性</li><li>不可预见性</li><li>可触发性</li></ul><h3 id="2-Windows-PE病毒的感染技术（P170）"><a class="header-anchor" href="#2-Windows-PE病毒的感染技术（P170）">¶</a>2.Windows PE病毒的感染技术（P170）</h3><ul><li>病毒感染重定位：病毒随着不同HOST程序载入内存后，病毒的各个变量在内存中的位置会随着HOST程序的大小不同而发生变化，因此病毒必须对病毒代码中的变量进行重定位</li><li>获取API函数地址：病毒代码没有引入函数机制的支持，所以病毒必须自己获取API函数的地址。首先获得Kernel32的基地址，再从Kernel32中得到API函数的地址</li><li>添加新节感染：常见感染文件方式是在文件中添加一个新节，然后往新节中添加病毒代码和病毒执行返回HOST程序的代码，并修改文件中代码开始执行位置(AddressOfEntryPoint)指向新添加的病毒节的代码入口，使程序运行后先执行病毒代码</li></ul><h3 id="3-Rootkit常用技术（P221）"><a class="header-anchor" href="#3-Rootkit常用技术（P221）">¶</a>3.Rootkit常用技术（P221）</h3><ul><li>用户态HOOK：主要钩挂一些用户态的API函数<ul><li>IAT(导入地址表)钩子：IAT的每个表项存储着程序所引用的其它动态链接库文件中函数的地址，改变IAT表项的值使其指向我们的HOOK函数，即可完成钩挂操作。<ul><li>若程序采用LoadLibrary和GetProcAddress来代码动态定位函数地址，IAT钩子将会失效</li><li><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210627163111055.png"  alt="image-20210627163111055"></li></ul></li><li>内联钩子：重写目标函数(如DLL模块中的目标函数)的代码字节，因此无论是函数正常引用机制还是通过代码动态定位函数地址，都能成功</li></ul></li><li>内核态HOOK：内核钩子是全局的且和防护软件一样都处于Ring0级更难被检测<ul><li>IDT(中断描述符表)钩子：IDT指明了每个中断处理进程的地址，通过修改这个表可在发生中断调用时改变正常执行路径</li><li>SSDT(系统服务调度表)钩子：在系统服务调用过程中，会在内核态查找此表来找到系统服务函数的地址，通过修改此表便可钩挂系统服务函数<ul><li><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210627163519450.png"  alt="image-20210627163519450"></li></ul></li><li>过滤驱动程序：几乎所有硬件都存在驱动程序链，将Rootkit驱动程序挂接到原有的驱动程序链中，即可截获传送的数据，并对其进行修改<ul><li><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210627164515.png"  alt=""></li></ul></li><li>驱动程序钩子：每个设备驱动程序中包含一个用于处理IRP(I/O请求包)请求的函数指针表，修改这个表使其指向Rootkit函数，即可完成钩挂<ul><li><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210627170319.png"  alt=""></li></ul></li></ul></li><li>直接内核对象操作(DKOM)：直接修改内核记账和报告所用的一些对象。DKOM很难被检测但并不能实现Rootkit的所有功能，只能对内存中用于记账的内核对象进行操作</li></ul><h3 id="4-进程隐藏技术（P224简答）"><a class="header-anchor" href="#4-进程隐藏技术（P224简答）">¶</a>4.进程隐藏技术（P224简答）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627110343743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>进程隐藏思路(如隐藏my.exe)：在用户态下，两个位置可以可用来隐藏进程，一个是psapi.dll中的EnumProcess函数，另一个为ntdll.dll中的原生API函数ZwQuerySystemInformation，钩挂这两个函数既可以用IAT钩子的方法，也可使用内联钩子的方法。</p><p>在核心态下用来隐藏的位置也有两个：修改系统服务表(SSDT)中ZwQuerySystemInformation的表项和直接修改内核中记录进程信息的结构</p><h3 id="5-文件隐藏技术（P227）"><a class="header-anchor" href="#5-文件隐藏技术（P227）">¶</a>5.文件隐藏技术（P227）</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210627172730.png"  alt=""></p><p>文件隐藏思路(如隐藏my.txt)：用户态下可通过FindFirstFile和FindNextFile来进行文件隐藏。内核态下通过修改系统服务表(SSDT)中ZwQueryDirectoryInformation对应的表项即可完成挂钩。</p><h3 id="6-通信隐藏技术（P229）"><a class="header-anchor" href="#6-通信隐藏技术（P229）">¶</a>6.通信隐藏技术（P229）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627110412504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>通信隐藏思路(如隐藏端口)：SSDT钩挂ZwDeviceIoControlFile：首先调用ZwDeviceIoControlFile，设置Inputbuffer的参数，判断OutputBuffer中每个实体的tae_ConnLocalPort是否是隐藏的端口，若是，则删除此条实体，便实现了端口隐藏。钩挂TCPIP.sys驱动程序：IRP会向诸如netstat.exe等程序返回端口列表，只需对这样的IRP做相应处理即可隐藏端口</p><h3 id="7-注册表隐藏技术（P322）"><a class="header-anchor" href="#7-注册表隐藏技术（P322）">¶</a>7.注册表隐藏技术（P322）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627110440405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>注册表隐藏思路(如隐藏注册表中的U盘)：通过索引查询注册表的函数是ZwEnumerateKey，对注册表键的索引就是改变相对的索引。获取注册表键值信息的函数是ZwEnumerateValueKey，与隐藏注册表键的原理一样</p><h3 id="8-Rootkit检测原理及工具（P236）"><a class="header-anchor" href="#8-Rootkit检测原理及工具（P236）">¶</a>8.Rootkit检测原理及工具（P236）</h3><ul><li>一般通过检测是否存在某种类型的钩子以此判断是否存在Rootkit<ul><li>查找SSDT钩子：查找名称为ntoskrnl.exe，查找超过ntoskrnl.exe范围之外的地址</li><li>查找内联钩子：给一个SSDT的一个函数地址，查找是否存在jmp，解析CPU要跳转的目的地址，检查这个地址是否超过了ntoskrnl.exe的可接受范围</li><li>查找IAT钩子：遍历每个DLL的每个IAT以检查是否存在任何钩子，特别要注意Kernel32.DLL和NTDLL.DLL，因为它们是进入OS的用户空间接口</li></ul></li><li>经典的Rootkit检测工具：IceSword和XueTr</li></ul><h1>第十章 病毒检测技术及检测对抗技术</h1><h3 id="1-特征值检测病毒的思路（P249简答）"><a class="header-anchor" href="#1-特征值检测病毒的思路（P249简答）">¶</a>1.特征值检测病毒的思路（P249简答）</h3><p>（1）采集已知的病毒样本：即使是同一种病毒，感染不同类型的宿主时，一般也需进行不同样本的采集</p><p>（2）从病毒样本提取特征值：特征值应足够特殊且控制在合适长度。可采用把病毒在计算机屏幕上出现的信息作为特征值或将病毒的标识作为特征值</p><p>（3）将特征值纳入病毒特征数据库：使用扫描引擎实现病毒特征的匹配，打开被检测文件，进行二进制检索，检查是否含有病毒特征数据库中的病毒特征值，以此可判断文件是否染毒、染有何种病毒</p><blockquote><p>特征值检测方法的优点：检测准确，可识别病毒的特征，误报率低，并且依据检测结果可做解毒处理</p></blockquote><h1>第十一章 恶意软件样本捕获与分析</h1><h3 id="1-什么是蜜罐，用途是什么，举例说明（P275）"><a class="header-anchor" href="#1-什么是蜜罐，用途是什么，举例说明（P275）">¶</a>1.什么是蜜罐，用途是什么，举例说明（P275）</h3><p>蜜罐通常是指没有采取安全防范措施且主动暴露在网络中的计算机，其内部运行着多种多样的行为记录程序和特殊用途的&quot;自我暴露程序&quot;，相当于一个恶意软件样本收集池。</p><p>利用蜜罐可以监控网络攻击行为、收集攻击工具和恶意代码、分析攻击方法、推测攻击意图和动机，甚至还可能根据蜜罐收集到的蛛丝马迹追踪到攻击者</p><h3 id="2-恶意软件样本捕获方法（P275）"><a class="header-anchor" href="#2-恶意软件样本捕获方法（P275）">¶</a>2.恶意软件样本捕获方法（P275）</h3><ul><li>蜜罐：见上面知识点</li><li>用户上报：个人用户发现恶意软件后主动上报给安全研究人员</li><li>云查杀平台上传：通过分布在全球的大量客户端获取可疑程序的最新信息，并主动上传到服务器，但存在个人隐私问题</li><li>诱饵邮箱：主动注册大量邮箱，定期收取电子邮件，从其中得到部分流行的恶意软件样本</li><li>样本交流：部分反病毒公司之间合作或反病毒人士分享恶意软件样本</li></ul><h3 id="3-恶意软件样本分析（P278）"><a class="header-anchor" href="#3-恶意软件样本分析（P278）">¶</a>3.恶意软件样本分析（P278）</h3><ul><li>虚拟机环境准备</li><li>系统监控：使用systeminternal即可<ul><li>包含进程监控(Process Explorer)、文件监控、注册表监控、网络连接分析、系统自启动项分析、内核监控、完整性检测</li></ul></li></ul><h1>第十三章 软件自我保护技术</h1><h3 id="1-花指令（P305）"><a class="header-anchor" href="#1-花指令（P305）">¶</a>1.花指令（P305）</h3><ul><li><p>定义：软件作者可能会在代码中加入一些特殊数据来扰乱反汇编程序，使其无法正确的转化出真实的反汇编代码，这些特殊的数据被称为花指令。</p></li><li><p>反汇编主要有两种算法</p><ul><li>线性扫描算法：依次逐个将每一条指令都反汇编成汇编指令<ul><li>花指令模式为跳转指令+干扰代码，跳转指令典型的有0FH和0E8H</li></ul></li><li>递归进行算法：模拟CPU的执行过程，根据控制流(代码可能的执行顺序)来反汇编，对每条可能的路径都进行扫描<ul><li>对付线性扫描算法的方法对它没用，需要引导反汇编工具将特定花指令数据当做控制流程中的指令片段进行反汇编，如通过无效跳转进行错误引导</li></ul></li></ul></li></ul><h3 id="2-如何检测调试器是否存在（P312简答）"><a class="header-anchor" href="#2-如何检测调试器是否存在（P312简答）">¶</a>2.如何检测调试器是否存在（P312简答）</h3><p>（1）查找是否有调试器进程</p><p>（2）查找调试器进程或文件的特征码</p><p>（3）查找特定的调试器服务</p><p>（4）查找调试器窗口</p><p>（5）句柄检测</p><p>（6）检测DBGHELP模块</p><p>（7）SeDebugPrivilege方法</p><h1>可能会出的简答汇总</h1><p>1.可信计算的基本思想</p><p>2.请你大致写出计算机的启动过程</p><p>3.一般来说，Win32病毒是怎样被运行的</p><p>4.什么是SQL注入，举个例子</p><p>5.进程隐藏技术</p><p>6.特征值检测病毒的思路</p><p>7.如何检测调试器是否存在</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;所用教材：彭国军等人编著的第一版&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明：博客为根据老师所画重点有</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络期末总结</title>
    <link href="https://zss192.github.io/2021/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://zss192.github.io/2021/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-07-05T08:41:56.000Z</published>
    <updated>2021-07-05T08:41:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>作者：夏日</p><p>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><p>本文结合天勤考研的高分笔记和王道考研的PPT进行总结</p><p>所用到的资料：<a href="https://pan.baidu.com/s/1HIEBuVhFtDIajyPUuYHz_g">传送门</a>  密码: rp2t</p><h1>概述</h1><h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><p>1.计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</p><p>2.计算机网络的组成</p><ul><li>物理组成上看可分为硬件、软件、协议(可理解为一种规则)。</li><li>工作方式上看可分为<strong>边缘部分</strong>(由主机组成)和<strong>核心部分</strong>(由网络和路由器组成,为边缘部分提供服务)。</li><li>逻辑功能上看可分为通信子网(数据通信)和资源子网(数据处理)。<ul><li>通信子网包括物理层、数据链路层和网络层。</li></ul></li></ul><p>3.计算机网络的功能</p><ul><li><strong>数据通信</strong>(最基本和最重要的功能)<ul><li>包括流量控制、路由选择、传输控制</li></ul></li><li>资源共享：可共享硬件(如共享打印机)、软件、数据</li><li>分布式处理：多个主机各自承担同一任务的不同部分，如Hadoop</li><li>信息综合处理：将分散的数据集中处理或分级处理</li><li>负载均衡：将工作任务均衡的分配给网络中各计算机</li><li>提高可靠性：网络中各计算机可通过网络互为替换机</li></ul><p>4.计算机网络的分类</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201207083410816.png"  alt="image-20201207083410816"></p><p>其中按范围划分</p><table><thead><tr><th>局域网</th><th>几千米内如学校</th></tr></thead><tbody><tr><td>城域网</td><td>一个城市</td></tr><tr><td>广域网</td><td>一个国家或大洲</td></tr></tbody></table><p>5.计算机网络为什么要采用分层结构：各层之间相互独立、灵活性好、易于实现和标准化。</p><blockquote><p>助记：一个公司如果非常大肯定要分部门工作，但要只有两三个人就没必要细分了。</p></blockquote><p>6.协议：一种规则，用来控制<strong>两个对等</strong>(同一层)实体通信。</p><ul><li>语法：数据与控制信息的结构或格式（即怎么讲）</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应（即讲什么）</li><li>同步：事件实现顺序的详细说明</li></ul><p>7.接口：<strong>上层使用下层</strong>服务的入口即服务访问点(SAP)（类似于程序里的接口）</p><p>8.服务：下层为相邻上层提供的功能调用。(协议是水平的而服务是垂直的)</p><blockquote><p>助记：肯定是你(下级)为领导(上级)服务</p></blockquote><ul><li>面向连接的服务和面向无连接的服务<ul><li>连接：通信前先建立连接，比较可靠如TCP；无连接：不连接直接发，速度快但可能丢包如UDP</li></ul></li><li>可靠服务(数据一定准确送达)和不可靠服务(尽力而为)</li><li>有应答服务(收到数据后给发送方说下)和无应答服务</li></ul><p>9.下一层对上一层提供的服务对上一层透明</p><blockquote><p>透明：打游戏你负责玩就行，你不用知道这游戏是咋实现的。即游戏对你透明</p></blockquote><p>10.OSI七层结构</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201207091242863.png"  alt="image-20201207091242863"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201207172709968.png"  alt="image-20201207172709968"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/4039680_1523328974264_E4E1F3318AF5F32719A15808E8D8458B"  alt="image-20201207172709969"></p><p>11.OSI5层结构总结</p><table><thead><tr><th></th><th>应用层</th><th>传输层</th><th>网络层</th><th>数据链路层</th><th>物理层</th></tr></thead><tbody><tr><td></td><td>用户对用户(端到端)</td><td>应用对应用；进程对进程(<strong>端到端</strong>)</td><td>主机对主机(点到点)</td><td>点到点</td><td>点到点</td></tr><tr><td>传输单位</td><td>——</td><td>报文段(TCP)或用户数据报(UDP)</td><td>IP数据报</td><td>帧</td><td>比特</td></tr><tr><td>所实现的硬件</td><td>——</td><td>——</td><td>路由器</td><td>交换机、网桥</td><td>集线器、中继器</td></tr><tr><td>任务</td><td>提供系统与用户的接口(如QQ)</td><td>负责主机中两个进程之间的通信</td><td>1.将传输层传来的报文段封装成分组;2.选择适当的路由使分组能够交付到目的主机</td><td>将网络层传来的IP数据报组装成帧</td><td>透明的传输比特流</td></tr><tr><td>功能</td><td>1.文件传输;2.访问和管理;3.电子邮件服务</td><td>1.可靠传输、不可靠传输;2.流量控制;3.差错控制;4.复用分用</td><td>1.路由选择;2.流量控制;3.差错控制;</td><td>1.成帧(定义开始和结束);2.差错控制;3.流量控制;4.访问控制</td><td>为数据端设备提供传送数据通路</td></tr><tr><td>协议</td><td>FTP、SMTP、POP3、HTTP</td><td>TCP、UDP、ARQ</td><td>ICMP、ARP、RARP、IP、IGMP</td><td>PPP、HDLC</td><td>——</td></tr></tbody></table><p>12.OSI参考模型和TCP/IP模型对比</p><table><thead><tr><th>OSI参考模型</th><th>TCP/IP模型</th></tr></thead><tbody><tr><td>3个主要概念：服务、接口、类型</td><td>没有明确区分服务、接口、类型</td></tr><tr><td>产生在协议发明之前</td><td>产生在协议发明之后</td></tr><tr><td>共有7层</td><td>一定是<strong>4层</strong>(一般教材为了更好的讲解才按5层模型讲解)</td></tr><tr><td>网络层：连接和无连接</td><td>网络层：仅有无连接</td></tr><tr><td>传输层：仅有面向连接</td><td>传输层：面向连接和无连接</td></tr></tbody></table><p>13.计算机网络性能指标</p><ul><li><p>带宽：网络设备可支持的最高速度(b/s)</p></li><li><p>时延：数据从一端传到另一端所需要的时间</p><ul><li>发送时延(<strong>传输</strong>时延)：从<strong>发送数据</strong>第一位到最后一位发送完毕所需时间<ul><li>发送时延 = 数据帧长度(bit)  /  发送速率(bit/s)</li></ul></li><li>传播时延：电磁波在<strong>信道中传播</strong>一定距离所需时间<ul><li>传播时延 = 信道长度(m)  /  电磁波在信道上的传播速度(m/s)</li></ul></li><li>排队时延：在输入和输出队列中<strong>排队等待处理</strong>所需时间</li><li>处理时延：主机或路由器收到分组进行处理所需时间</li><li>总时延 = 发送时延+传播时延+排队时延+处理时延</li></ul></li><li><p>时延带宽积：又称以比特为单位的链路长度即某段链路现有多少比特(容量)</p><ul><li>时延带宽积(bit) = 传播时延(s) x 带宽(bit/s)</li></ul><blockquote><p>助记：时延带宽积：时延和带宽的乘积</p></blockquote></li><li><p>往返时延(RTT)：数据发送后来回跑一趟的时间</p><ul><li>往返时延 ≈ 2x传播时延</li></ul></li><li><p>信道利用率 = 有数据通过时间  /  (有+无)数据通过时间</p></li><li><p>利用率：D<sub>0</sub>表示网络空闲下来时的时延，D表示网络当前时延，U表示利用率</p><ul><li>D<sub>0</sub>=D-D*U（空闲时延=当前时延-利用了的时延）</li></ul></li></ul><p>14.两种通信方式</p><ul><li>C/S(客户-服务器)方式：客户是服务请求方，服务器是服务提供方，指的都是进程不是使用者</li><li>P2P(peer-to-peer)方式：任一主机既可以是客户也同时可以是服务器</li></ul><p>15.OSI参考模型与TCP/IP参考模型</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102153253752.png"  alt="image-20210102153253752"></p><blockquote><p>注意TCP/IP模型是4层模型，把物理层和数据链路层合成一个网络接口层</p></blockquote><h2 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.下列选项中，不属于网络体系结构所描述的内容是（C）</p><p>A.网络的层次B.每一层使用的协议C.协议的内部实现细节D.每一层必须完成的功能</p><p>答：层次、协议、完成的功能教材均有提及，内部细节这是专门的工作人员去实现</p><p>2.下列属于通信子网的是（A）</p><p>I.网桥II.交换机III.计算机软件IV.路由器</p><p>A. I、II、IVB. II、III、IV</p><p>答：通信子网是负责通信的而且只包括物理层、数据链路层、网络层。计算机软件显然不是用于通信的工具也不在那三层里面，它属于资源子网。</p><p>3.局域网和广域网之间的差异是（D）</p><p>A.所使用的传输介质不同B.所覆盖的范围不同</p><p>C.所使用的协议不同D.B和C</p><p>答：我们都知道他俩范围肯定不一样。至于协议不同是因为广域网范围更广，信号可靠度不高就要采取一系列差错控制、流量控制等手段，而局域网信道质量较好主要实现信道复用和提高速度就行。传输介质可能都是光纤。</p><p>4.下列说法错误的是（C）</p><p>I.广播式网络一般只包含3层，即物理层、数据链路层和网络层<br>II. Internet 的核心协议是TCP/IP<br>III.在Internet中，网络层的服务访问点是端口号</p><p>A. I、II、IIIB. IIIC. I、IIID. I、II</p><p>答：广播式网络谁都发不存在路由选择的问题，所以没有网络层</p><p>网络层的服务访问点是IP地址，传输层的服务访问点才是端口号</p><p>5.在n个节点的星型拓扑结构中，有（A）条物理链路</p><p>A.n-1B.nC.nx(n-1)D.nx(n+1)/2</p><p>答：星型拓扑是中间一个点与外边一圈的点相连，所以是n-1</p><p>而在环型拓扑结构中是n条链路</p><p>6.在TCP/IP体系结构中，<strong>直接</strong>为ICMP提供服务的协议是（B）</p><p>A．PPPB．IPC．UDPD．TCP</p><p>答：网际控制报文协议ICMP是TCP/IP体系结构网络层中的一个协议，ICMP报文需要使用IP协议封装为IP数据报，因此可以认为直接为ICMP提供服务的协议是IP协议。</p><p>PPP协议在TCP/IP体系结构中属于最底层协议，也就是网络接口层协议，在OSI体系中属于数据链路层协议，所以PPP协议为网络层提供服务，但并不能认为PPP直接为ICMP提供服务。</p><p>UDP和TCP都属于传输层协议，它们为应用层提供服务。</p><blockquote><p>本题关键字在于&quot;直接&quot;，一般协议都是为上一层提供服务</p></blockquote><p>7.在OSI参考模型中，下列功能需由应用层的相邻层实现的是（B）</p><p>A．对话管理B．数据格式转换</p><p>C．路由选择D．可靠数据传输</p><p>答：应用层的相邻层是表示层。表示层的任务主要是数据字符集的转换、数据格式化、文本压缩、数据加密以及解密等工作。</p><p>选项A中的<strong>对话</strong>管理，是<strong>会话</strong>层实现的功能；</p><p>选项C中的路由选择，是网络层实现的功能；</p><p>选项D中的可靠数据传输，是传输层实现的功能。</p><p>8.在下列情况下，计算传送1000KB文件所需的总时间，即从开始传送时起直到文件的最后一位到达目的地为止的时间。假设往返时间RTT为100ms，一个分组是1KB（即1024B）的数据，在开始传送整个文件数据之前进行的起始握手过程需要2RTT的时间。（类似于谢版P39 1-28）</p><p>（1）带宽是1.5Mb/s，数据分组可连续发送<br>（2）带宽是1.5Mb/s，但在发送完每一个数据分组之后，必须等待一个RTT，才能发送下一个数据分组<br>（3）假设带宽无限大，即发送时间为0，但是在等待每个RTT后可以发送多达20个分组</p><p>(4)假设带宽是无限大的值,在紧接起始握手后可以发送一个分组,此后,在第1次等待RTT后可发送2<sup>1</sup>个分组,在第2次等待RTT后可发送2<sup>2</sup>个分组…在第n次等待RTT后可发送2<sup>n</sup>个分组</p><p>答：(1)：总时延 = 发送时延 + 传播时延 + 握手时延</p><p>发送时延 = 1000KB / 1.5Mb/s = 5.46s（<strong>注意单位换算</strong>）</p><blockquote><p>1000KB = 1000*8Kb = 1000*8*1024bit = 8192000bit</p><p>1.5Mb/s = 1500000bit/s</p></blockquote><p>传播时延 = RTT/2=100ms/2 = 50ms（前面发的传播时延算在了发送时延里，所以只算最后发的那个的传播时延即可）<br>握手时延 = 2*RTT=200ms</p><p>总时延=5.46s+0.05s+0.2s=5.71s</p><blockquote><p>发送时延可想象成豌豆射手吐完所有豌豆所需时间</p><p>传播时延是吐出来的豌豆去打僵尸的路上所花的时间</p></blockquote><p>(2)：发送完一个分组等一个RTT，总共有1000个分组在(1)的基础上加上999RTT即可(发第1000个分组后就发完了不用再等了)。</p><p>总时延=5.71s+999x0.1s=105.61s</p><p>(3)：总时延 = 发送时延 + 传播时延 + 等待时延 + 握手时延</p><p>①发送时延本题为0，而握手时延为固定值2RTT</p><p>一共1000分组，一次能发20分组，需要发50次</p><p>②等待时延：从发第二次到第五十次发送前都要等一个RTT即49RTT</p><p>③传播时延：第一次发后数据需要0.5RTT才能到达目的地，但与此同时这0.5RTT时间内第二次发送也在等待一个RTT。</p><p>由于我们已经计算过等待时延，所以不用额外加上这些传播时延。</p><p>而第五十次发送后由于是最后一次发送所以需要加上0.5RTT的传播时延。</p><blockquote><p>t=0：第一次发送，t=0.5RTT第一次发送的数据到达目的地，t=1RTT，第二次发送数据，…t=49RTT，第五十次发送，t=49.5RTT，第五十次发送的数据到达目的地</p></blockquote><p>所以总时延=2RTT+49RTT+0.5RTT=51.5RTT=5.15s</p><p>(4)：第n次等待RTT后共发了1+2+4+…+2<sup>n</sup>=2<sup>n+1</sup>-1个分组</p><p>2<sup>n+1</sup> &gt; 1000 则n为9，也就是等九次RTT就可以发完所有分组</p><p>但等第九次后虽然把分组发出去了传到目的地还需要0.5RTT</p><p>所以总时延=2RTT(握手时间)+9RTT+0.5RTT=1.15s</p><blockquote><p>总结：记住无论啥情况都要加上传播时延，而且都是只计算最后一次发送的0.5RTT传播时延</p><p>同时注意区分这题和书上习题</p></blockquote><p>9.互联网具有两个重要基本特点是 [连通性] 和 [共享]</p><p>10.因特网由 [边缘部分] 和 [核心部分] 组成</p><p>11.在网络边缘的端系统之间的通信方式通常可划分为两大类: [C/S方式] 和 [P2P方式]</p><p>12.网络中的三种数据交换方式分别是 [电路交换]、[报文交换]、[分组交换]</p><p>13.上网时，感觉网络时快时慢，主要是哪种时延引起的？[排队时延]</p><h1>物理层</h1><h2 id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2><p>1.物理层解决如何在各种传输媒体传输数据比特流，而不是指具体的传输媒体。(记住每个层都不是指具体的实体)</p><p>2.物理层主要任务：确定与传输媒体接口有关的一些特性(定义标准)</p><ul><li>机械特性：规定所采用的规格、接口形状、引脚数量等情况。无对应</li><li>电气特性：规定传输过程中的电压范围、传输速率、距离限制等。对应语法<ul><li>如+10V ~ +15V 表示二进制数据 0 ，电线长度在15m以内</li></ul></li><li>功能特性：描述 电平 的意义 , 接口部件 信号线用途。对应语义<ul><li>如一个接口的引脚处于高电平的含义</li></ul></li><li>过程特性(规程特性)：规定各个物理线路工作规程 , 时序关系。对应同步</li></ul><p>3.基带传输对应数字信号(0和1用电压表示)，宽带传输对应模拟信号(连续变化的)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201212190029799.png"  alt="image-20201212190029799"></p><blockquote><p>助记：基数(基带–数字)</p></blockquote><p>4.数据传输方式</p><ul><li>串行传输：一个信道一个比特一个比特的传输（远距离常用）</li><li>并行传输：多个比特通过多个信道同时传输（近距离常用）</li></ul><p>通信方式</p><ul><li>同步通信：发送端和接收端的时钟频率相等(单位为帧)（技术复杂，效率高，贵）</li><li>异步通信：发送端发完一个发送单位即字节后，可过任意时间发下一个（价格低）</li></ul><blockquote><p>同步传输的帧头和帧尾占很少一部分可近似认为传输效率为100%，而异步传输每8bit就要加一个起始位和终止位，传输效率为80%，可见同步效率比异步效率要高(既然贵，肯定高)</p></blockquote><p>通信模式</p><ul><li>单工(单向)：只有一个方向的通信，需一条信道（如广播）</li><li>半双工(双向交替)：双方都可以发或接，但不能同时发和接，需两条信道（如对讲机）</li><li>全双工(双向同时)：双方可同时发和接，需两条信道（如打电话）</li></ul><p>5.码元：用一个固定时长的信号波形代表不同的离散数值的基本波形，而1码元可携带多个比特的信息</p><blockquote><p>如二进制有两种码元即0和1，而4进制则有00、01、10、11四种码元</p></blockquote><p>6.速率：即传输速率，有两种描述形式</p><ul><li>波特率：也称码元速率，表示每秒可传输多少个码元，单位为波特(B)</li><li>比特率：也称信息传输速率，表示每秒可传输多少个比特，单位为比特每秒(b/s)</li></ul><blockquote><p>关系：若一个码元携带2bit信息，则3B波特率对应比特率为3x2 bit/s</p></blockquote><p>7.带宽：单位时间内所能通过的最高数据率，单位比特每秒(bit/s)（数字信号中）</p><blockquote><p>可理解为大马路有多宽</p><p>模拟信号中的带宽表示允许通过的最高频率减最低频率</p></blockquote><p>8.奈氏准则：理想低通(<strong>无噪声</strong>、带宽受限)条件下，为了避免码间串扰(码元之间失去清晰界限)存在一个极限数据传输率<br>$$<br>Cmax=2<em>W</em>log2N (bit/s)<br>$$</p><blockquote><p>其中W为带宽HZ(模拟信号中)，N为几种码元或每个码元的离散电平的数目(几种状态)</p><p>奈氏准则只给出了码元传输速率的限制并没有给出信息传输速率的限制</p><p>f<sub>采样</sub>≥2f<sub>信号最高频率</sub>，而f<sub>采样</sub>=2*W</p></blockquote><p>9.信号越强，噪声的影响就越小，因此只考虑其中一方是没有意义的，所以求信噪比才有意义<br>$$<br>信噪比(dB)=10*log10(S/N) (dB)<br>$$</p><blockquote><p>其中S为信号的平均功率，N为噪声的平均功率</p></blockquote><p>10.香农定理：在宽带受限且<strong>有噪声</strong>的信道中，为了不产生误差，信息的传输速率有上限值<br>$$<br>Cmax=W*log2(1+S/N) (bit/s)<br>$$</p><blockquote><p>其中W为带宽(Hz)，S/N需要由信噪比推出</p></blockquote><p>通过公式我们可知道</p><ul><li>信道中宽带或信噪比越大，信息的极限传输速率越高</li><li>对于一定的带宽和信噪比，信息的传输速率上限就确定了</li><li>只要信息的传输速率低于极限传输速率，就一定能找到某种方法实现无差错的传输</li><li>实际信道的传输速率要比极限速率低不少</li></ul><p>11.奈氏准则指出了码元传输的速率是受限的(内忧)，而香农定理给出了信息传输速率的极限(外患)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201212201158273.png"  alt="image-20201212201158273"></p><p>12.数据------------&gt;数字信号（编码）</p><p>数据------------&gt;模拟信号  （调制）</p><p>13.数字数据编码为数字信号</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201213141647340.png"  alt="image-20201213141647340"></p><ul><li>非归零编码(NRZ)：低电平为0，高电平为1，但无法判断码元的开始和结束，双方难以同步</li><li>翻转不归零编码(NRZI)：电平遇0翻转，遇1不变</li><li>曼彻斯特编码：每个码元内<strong>前高后低为1</strong>，前低后高为0，所占频带宽度是原始基带宽度的两倍(以太网用这个)</li><li>差分曼彻斯特编码：前半个部分的电平与上一个码元的后半部分电平相同时为1，抗干扰强</li></ul><blockquote><p>后两个都是用每个码元的中间跳变作为收发双发的同步信号</p></blockquote><p>14.数字数据调制为模拟信号</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201213141917786.png"  alt="image-20201213141917786"></p><p>15.模拟数据编码为数字信号：抽样、量化、编码</p><p>16.模拟数据调制为模拟信号：为了实现传输的有效性，有时需要较高的频率</p><p>17.数据传输(交换)方式</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201213142711040.png"  alt="image-20201213142711040"></p><ul><li>电路交换：双方需建立一条被双方独占的物理通路<ul><li>优点：通信时延小、实时性强、有序传输、适用范围广、控制简单、避免冲突</li><li>缺点：建立连接时间长、通信利用率低、缺乏统一标准、灵活性差</li><li>适用于传输数据量大且传送时间远大于呼叫时间</li></ul></li><li>报文交换：无需建立专有线路，传输单位为报文，采用存储转发方式<ul><li>优点：无需建立连接、动态分配线路、提高可靠性、提高线路利用率、提供多目标服务</li><li>缺点：存储转发会产生时延、只适用数字信号、报文大小没限制需节点有较大存储缓存空间</li></ul></li><li>分组交换：仍采用存储转发但一个长报文分割成若干分组即限制所传输单位长度<ul><li>优点：加速传输、简化存储管理、减少出错概率和重发数据量</li><li>缺点：仍存在存储转发时延、若采用数据报服务要进行编号排序若采用虚电路需有呼叫连接等过程</li><li>适用于端到端的通路由很多段的链路组成</li></ul></li></ul><blockquote><p>从信道利用率看，报文和分组交换优于电路交换，分组交换时延小，尤其适用于突发式的数据通信</p></blockquote><p>18.分组交换可采用的两种方式</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102174401148.png"  alt="image-20210102174401148"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102174442580.png"  alt="image-20210102174442580"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201213175034810.png"  alt="image-20201213175034810"></p><p>19.无连接和连接服务</p><p>无连接服务：不事先为分组的传输确定传输路径,每个分组独立确定传输路径,不同分组传输路径可能不同。</p><p>连接服务：首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组,系列分组传输路径相同,传输结束后拆除连接。</p><p>20.传输介质：数据传输系统中双方之间的物理通路，在物理层下面，可称为0层。</p><ul><li><p>导向性传输介质：沿着实实在在的线传播</p><ul><li><p>双绞线：由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。价格便宜较常用。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201213180150736.png"  alt="image-20201213180150736"></p></li><li><p>同轴电缆：由于外导体屏蔽层，其比双绞线抗干扰性能好，价格贵</p></li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201213180705742.png"  alt="image-20201213180705742"></p><ul><li>光纤：由纤芯(实心)和包层组成<ul><li><strong>误码率低</strong>，带宽大</li><li>抗雷电和电磁干扰性能较好、不易被窃听和截取数据、体积小重量轻</li><li>单模光纤衰减小适合远距离传输，多模光纤易失真适合近距离传输</li></ul></li></ul></li><li><p>非导向型传输介质：在自由空间中传播，如水、空气等</p></li></ul><p>21.物理层设备</p><ul><li>中继器：对数字信号进行再生和还原，对衰减的信号(传输过程会衰减到一定程度会失真)放大，以增加信号传输的距离。</li><li>集线器(Hub)：可理解为多口中继器，对信号进行再生放大转发，会转发到除输入端口外的所有工作端口，是一个共享式设备。</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201213182206346.png"  alt="image-20201213182206346"></p><p>22.宽带和带宽的关系：如100M的宽带(名词)指这条宽带的带宽(量词指传输速率)为100Mbps,传输速率为12.5MB/s</p><h2 id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.在无噪声的情况下,若某通信链路的带宽为3kHz,采用4个相位,每个相位具有4种振幅的QAM调制技术,则该通信链路的最大数据传输率是多少?</p><p>答：题目中说无噪声所以用奈氏准则求解</p><p>4个相位,每个相位具有4种振幅所以有16种状态即N=16</p><p>C<sub>max</sub>=2*3k*log<sub>2</sub>16=24kb/s（注意公式中带宽的单位为HZ）</p><blockquote><p>也可以理解为带宽为3kHZ，则采样频率为6kHZ即每秒采样6k次，16种状态，则每个码元携带4bit信息，C<sub>max</sub>=每秒采样次数*每码元携带信息</p></blockquote><p>2.电话系统的典型参数是信道带宽为3000Hz,信噪比为30dB,则该系统的最大数据传输率为（C）<br>A. 3kbit/sB. 6kbit/sC. 30kbit/sD. 64kbit/s</p><p>答：电话系统的信道是有噪声的信道，所以用香农定理求解</p><p>香农公式用到了S/N，而我们已知了信噪比，先求S/N</p><p>10log<sub>10</sub>(S/N)=30，所以S/N=1000</p><p>C<sub>max</sub> = 3000*log<sub>2</sub>(1+S/N) = 3000*log<sub>2</sub>(1+1000) ≈ 30kbit/s</p><blockquote><p>注意S/N并不是信噪比，一般题目都是给信噪比我们要先求S/N</p></blockquote><p>3.调制解调技术主要使用在（A）通信方式中。<br>A.模拟信道传输数字数据B.模拟信道传输模拟数据<br>C.数字信道传输数字数据D.数字信道传输模拟数据</p><p>答：调制就是将基带数字信号的频谱变换为适合在模拟信道中传输的频谱(比如数字数据调制为模拟信号)，解调正好与之相反(还原成数字数据)。</p><p>所以，调制解调技术用于模拟信道传输数字数据通信方式，而模拟信道传输模拟数据不需要调制解调技术</p><p>4.一个传输数字信号的模拟信道的信号功率是0.62W,噪声功率是0.02W,频率范围为3.5~3.9MHz,该信道的最高数据传输速率是（B）<br>A. 1Mbit/sB. 2Mbit/sC. 4Mbit/sD. 8Mbit/s</p><p>答：S/N=0.62/0.02=31，带宽W=3.9MHZ-3.5MHZ=0.4MHZ</p><p>W*log2(1+S/N)=0.4MHZ*log2(1+31)=2Mbit/s</p><blockquote><p>注意信噪比、S/N和带宽的含义</p></blockquote><p>5.为了使模拟信号传输得更远,可以采用的设备是（B）<br>A.中继器B.放大器C.交换机D.路由器</p><p>答：要想传的远就要进行放大，而放大信号是物理设备应执行的功能，所以交换机(数据链路层)和路由器(网络层)都可以排除。</p><p>中继器和放大器都可以放大信号，但中继器放大的是数字信号而放大器才能放大模拟信号。</p><p>6.因特网上的数据交换方式是（C）<br>A.电路交换B.报文交换C.分组交换D.光交换</p><p>答：电路交换主要用于电话网，报文交换用于早期电报网，因特网使用的是分组交换。</p><blockquote><p>助记：打电话按分钟(双方独享线路)计费，手机上网按流量(分组-用多少付多少)计费</p></blockquote><p>7.<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201214112513935.png"  alt="image-20201214112513935"></p><p>答：①每个分组大小为1000B，而分组头为20B，则每个分组数据部分为980B。所以980 000B应该被分为1000个分组，每个分组1000B，则一共传送1000 000B信息</p><blockquote><p>一个分组能除去头部能装的有效数据为980B现有980 000B所以要1000分组</p></blockquote><p>②链路传输速率100Mbit/s即100/8=12.5MB/s（1B=8bit）</p><p>③H1发完所有分组需要1000 000B / 12.5MB/s=80ms</p><p>此时刚好最后一个分组刚从H1发出去，最快是从上面直线过经过两次存储转发到达H2</p><p>用时2*1000B / 12.5MB/s=0.16ms</p><blockquote><p>80ms时，所有数据都已发送出去，但可能线路上还有很多没到目的地的分组，而其实我们只需计算最后一个分组到达目的地的时间即可(最后一个要是到了前面的肯定都到了)</p></blockquote><p>综上，总用时为80ms+0.16ms=80.16ms</p><p>8.波特率和比特率之间的转换<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201214121555601.png"  alt="image-20201214121555601"></p><p>答：从图中可以看出有十六种状态，需要用log<sub>2</sub>16=4bit来表示这16种状态，2400Baud即每秒传2400码元，一个码元有4bit，则比特率为2400*4=9600bit/s</p><p>9.10Base-T指的是（B）</p><p>B.10Mbit/s，使用数字信号，使用双绞线</p><p>答：10表示每秒传10Mbit，Base(基础—&gt;基带)表示基带传输即数字信号，T(Twisted-pair)表示用的是双绞线</p><p>10.下列关于单模光纤的描述中,正确的是（D）<br>A.单模光纤的成本比多模光纤的成本低<br>B.单模光纤传输距离比多模光纤短<br>C.光在单模光纤中通过内部反射来传播<br>D.单模光纤的直径一般比多模光纤小</p><p>答：单模在荒郊野外用传的远(贵)，多模在学校用传的近(便宜)</p><p>多模才用到内部反射，单模可理解为一条直线，而多模需要在通道内来回反射的传播所以多模直径更大</p><p>11.主机甲通过1个路由器(存储转发方式)与主机乙互联，两段链路的数据传输速率均为10Mbps，主机甲分别采用报文交换和分组大小为10kb的分组交换向主机乙发送1个大小为8Mb(1M=10<sup>6</sup>)的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为 (D)</p><p>A．800ms、1600ms B．801ms、1600ms</p><p>C．1600ms、800ms D．1600ms、801ms</p><p>答：①当采用报文交换时，只需考虑两次发送时延，一次在主机甲，一次时在路由器，而每次的发送时延都为8Mbit/10Mbit/s=800ms，所以共需1600ms</p><p>②当采用分组交换时，每个分组为10kbit，发送时延为10kbit/10Mbit/s=1ms,共800个分组。</p><p>主机甲发送完所有分组需要800ms,发的最后一个还需经历一个路由器的存储转发所以再加上1ms，即最终结果为800ms+1ms=801ms</p><blockquote><p>800ms时，主机甲发完全部数据，由于忽略传播延迟，甲发的最后一个分组立马到达路由器，然后需要1ms的存储转发，又立马到达主机乙，此时为801ms。</p><p>这种题都是一个套路，发完后最后一个发的到达了目的地，它前面的肯定也都到了，所以只需算一个分组的</p></blockquote><p>12.下列因素中，不会影响信道数据传输速率的是 （D）</p><p>A.信噪比B.频率宽带C.调制速率D.信号传播速度</p><p>答：由香农定理得知信噪比和频率宽带都会对数据传输速率产生影响。</p><p>信道的<strong>传输速率其实就是发送速率</strong>，所以调制速度也会影响数据传输速率。</p><p>信号传播速度是在信道传播的速度，和发送率无关。</p><blockquote><p>发送时延也称为传输时延，而传输速率也指的是发送速率，不是在信道上传输的速率！</p><p>实际上带宽等也都是和发送速率有关，传播速率一般都是固定的(如在光纤上传播)，我们研究的基本都是发送速率。</p></blockquote><p>13.通信系统的一般模型中,以下哪些部分是可有可无的（BD）</p><p>A.信息源B.发送器C.信道</p><p>D.接收器E.受信者</p><p>答：信道肯定要有要不然没法传输信息</p><p>那么要么选信息源和受信者或者选发送器和接收器</p><p>而我们要明白的是信息源才是真正发消息的那个，你把它去了只留下个发送器没人产生消息了还有什么用</p><p>所以发送器和接收器是可有可无的部分，他们仅仅只是起到个中间人的作用</p><h1>数据链路层</h1><h2 id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2><p>1.名词解释</p><ul><li>链路：网络中两个结点之间的物理通路</li><li>数据链路：网络中两个结点之间的逻辑通道，即链路加上控制数据传输协议的硬件和软件</li><li>帧：链路层的协议数据单元，封装网络层数据报</li></ul><p>2.数据链路层的主要功能</p><ul><li>链路管理：用于面向连接的服务即连接的建立、维持、释放</li><li>封装成帧</li><li>差错检测</li><li>透明传输</li></ul><p>3.封装成帧：在一段数据前后加上首部(SOH即start of header)和尾部(EOT)，就成了一个帧。</p><blockquote><p>只有既加头又加尾接收方收到后才能知道哪是开头哪是结尾（MAC帧特殊他不用加尾）</p><p>每一条链路协议都规定了所能传输帧的数据部分长度上限–最大传送单元MTU(maximum transfer unit)</p><p>以太网的MTU(最大数据部分)=1500，如携带的IP数据报最长为1500</p></blockquote><p>4.透明传输：不管数据是什么比特组合都应能在链路上传送，若有部分数据和控制信息冲突就要采取适当措施</p><ul><li>字符填充法：传送非ASCII码的文本时数据部分可能含有帧定界符SOH和EOT在数据部分的他们前面加上ESC(相当于转义’\')</li></ul><p>5.全世界使用最多的数据链路层协议就是点对点协议PPP(<strong>P</strong>oint-to-<strong>P</strong>oint <strong>P</strong>rotocol)，分为三部分</p><ul><li>一个将IP数据报封装到串行链路的方法(成帧方法)</li><li>一个用来建立、配置和测试数据链路连接的链路控制协议LCP</li><li>一套网络控制协议NCP</li></ul><p>各字段的意义为</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201225235804734.png"  alt="image-20201225235804734"></p><p>当信息字段出现和标志字段一样的比特0X7E时要采取措施</p><p>当使用异步传输时采用字节填充法(转义)</p><p>当PPP用在SONET/SDH链路时使用同步传输，采用零比特填充实现透明传输</p><ul><li>零比特填充法：发送端遇到5个连续的1就插入1个0，接收端逆操作遇到连续5个1就删除后面的0</li></ul><p>PPP不需要的功能:纠错(PPP只负责检错)、流量控制(由TCP负责)、序号(PPP是不可靠传输协议,所以不需要对帧进行编号)、多点线路(PPP是点对点的通信方式)、半双工或单工(PPP只支持全双工链路)。</p><p>6.概括来说传输中的差错都是由于噪声引起的，差错可分为以下两种</p><ul><li>位错：1变成0或0变成1</li><li>帧错：帧丢失、重复、失序</li></ul><p>7.差错检测</p><ul><li><p>检错编码</p><ul><li><p>奇偶检验码：奇检验就是加上1位检验位后1的个数为奇数，但只能检验奇数个比特出错。</p></li><li><p><strong>循环冗余码CRC</strong></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201225204746513.png"  alt="image-20201225204746513"></p><blockquote><p>数据链路层仅仅使用CRC做到无差错接收(认为收到的都没出错)并没有向网络层提供可靠传输</p></blockquote></li></ul></li><li><p>纠错编码</p><ul><li>海明码<ul><li>满足2<sup>r</sup>-1 ≥ k+r（r位冗余检验码，k位信息位）</li><li>若想检测d位错误，海明距为d+1</li><li>若想纠正d位错误，海明距为2d+1</li></ul></li></ul></li></ul><p>8.流量控制：较高的发送速度和较低的接收能力不匹配，会造成传输出错，因此要加以控制</p><ul><li>数据链路层流量控制：接收方收不下就不回复确认（点对点）</li><li>传输层流量控制：接收端给发送端一个窗口公告（端到端）</li></ul><blockquote><p>流量控制和可靠传输机制在谢希仁版的第五章，此处采用所选参考资料顺序进行总结</p></blockquote><p>9.流量控制方法</p><ul><li><p>停止等待协议：发送方发完一帧后要等到收到应答信号才能继续发下一帧</p><ul><li>无差错时用1bit编号即可</li><li>出错时：设置超时计时器，其重传时间要比帧传输的RTT更长一些，数据帧和确认帧要编号且要发完一个帧要保留副本</li><li>简单但信道利用率太低</li><li>发送窗口=1，接收窗口=1</li></ul></li><li><p>后退N帧协议(GBN)：发送方发一个数据帧后不用停下等待确认帧而是继续发，如果某个帧出错，接收方<strong>丢弃该帧及其以后的帧</strong></p><ul><li>发送窗口的大小应满足 1≤WT≤2<sup>n</sup>-1，过大会使得接收方无法区别新帧和旧帧（n位比特对帧编号）</li><li>确认序列号最大、按序到达的帧</li><li>因连续发送数据帧提高了信道利用率但重传时必须把已经正确传送的帧重传使得传送效率降低</li><li>帧号大于等于发送窗口+1</li><li>发送窗口&gt;1，接收窗口=1</li></ul></li><li><p>选择重传协议(SR)：若一帧出错，则其后续帧先存入接收方的缓冲区中，同时要求发送方重传出错帧，一旦收到重传帧，就和原先存在缓冲区的其余帧一起按顺序送至主机</p><ul><li>收到一个确定一个</li><li>只传送出错帧</li><li>最大发送窗口和最大接收窗口=2<sup>n-1</sup>（n位比特对帧编号）</li><li>发送窗口&gt;1，接收窗口&gt;1</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201225213859717.png"  alt="image-20201225213859717"></p></li></ul><blockquote><p>接收窗口为1时一定可保证帧按序接收</p></blockquote><p>10.复用和分用</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201225215702847.png"  alt="image-20201225215702847"></p><p>11.介质访问控制：采取一定的措施，使得两对节点之间的通信不会互相干扰</p><ul><li><p>信道划分介质访问控制（静态划分信道）</p><ul><li>频分多路复用FDM：用户在同一时间始终占用不同频率的带宽（并行）<ul><li>充分利用带宽效率高实现容易</li></ul></li><li>时分多路复用TDM(同步)：用户使用各自对应的时间间隙轮流使用信道（并发）<ul><li>可能导致线路资源的浪费</li></ul></li><li>统计时分复用STDM(异步)：改进版的TDM，不是固定分配时隙而是按需分配</li><li>波分多路复用WDM：就是光的频分复用（如光纤中传输不同波长(频率)的光）</li><li><strong>码分多路复用CDMA</strong>：又称码分多址,既共享频率又共享时间（习题讲解具体步骤）<ul><li>每个站点对应一个m位的芯片序列。发送1时发送芯片序列，发0时发送序列反码</li><li>任意两个站点芯片序列正交，规格化内积为0</li><li>任一站点与自身规格化内积为1，与自身反码规格化内积为-1</li><li>优点：抗干扰强、保密性强、语音质量好、减少成本</li></ul></li></ul></li><li><p>轮询访问介质控制（动态划分信道）</p><ul><li>典型的是令牌传递协议，令牌按环形传递，只有拿到令牌的才能发送数据</li></ul></li><li><p>随机访问介质控制（动态划分信道）</p><ul><li><p><strong>CSMA/CD协议</strong>：全称为带冲突检测的载波监听多路访问协议，广泛应用于局域网中（<strong>重点</strong>）</p><ul><li><p>工作过程：先听后发，边听边发，冲突停止，随机重发</p></li><li><p>争用期：两倍的端到端的往返时延2τ，若这段时间没检测到冲突那么这次发送肯定没有冲突</p><ul><li>2τ = RTT(一个往返时延)</li></ul></li><li><p>最短帧长：以太网取51.2us为争用期的长度，10Mbit/s的以太网争用期内可发512bit即64B，所以<strong>以太网规定最短帧长为64B</strong>，若小于这个长度一定是由于冲突而异常终止的帧</p><ul><li><strong>最短帧长=数据发送速率*往返时延</strong></li></ul><blockquote><p>注意和MTU的区别，MTU是最大有效数据部分，不包括帧的首部和尾部</p></blockquote></li><li><p>当重传16次仍然不成功说明网络太拥挤，则认为永远无法正确发出，抛弃此帧向高层报告</p></li></ul></li><li><p>纯ALOHA协议：不监听信道、不按时间槽发送、随机重发也就是想发就发（不听就发）（了解）</p><ul><li>若发生冲突接收方不予确认，发送方一段时间收不到就判断发生冲突</li><li>发生冲突后等一随机时间重传</li><li>信道利用率低</li></ul></li><li><p>时隙ALOHA协议：划分若干时间片，必须在时间片开始时才可发送数据（不听就发）（了解）</p><ul><li>比纯ALOHA协议吞吐量大效率高</li></ul></li><li><p>CSMA协议：即载波监听多路访问协议发送前先检测下是否有其它计算机在发数据（先听后发，边听边发）（了解）</p><ul><li>1-坚持CSMA：监听到信道空闲立即发送，否则一直监听</li><li>非坚持CSMA：监听到信道空闲立即发送，否则等一个随机时间再监听</li><li>p-坚持CSMA：监听到信道空闲时，以概率p发送数据，以概率(1-p)延迟一段时间再监听</li></ul></li></ul></li></ul><p>12.局域网(Local Area Network)：简称LAN，指某一区域内有多台计算机互联组成的计算机组，使用广播信道</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201225233129778.png"  alt="image-20201225233129778"></p><p>13.以太网(Ethernet)：当今局域网采用的最通用的通信协议标准，采用CSMA/CD技术，无连接不可靠</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201225233636424.png"  alt="image-20201225233636424"></p><ul><li>前导码：可分为前同步码(使接收端和发送端时钟同步)和帧开始定界符<ul><li>由硬件生成插入到MAC帧前进行传输(不属于MAC帧的一部分)</li><li>使用SONET/SDH进行同步传输时不需要前同步码</li></ul></li><li>源地址最后一位恒为0</li><li>类型：表明上层使用的协议，如0x0800代表上层使用的是IP数据报</li><li>FCS：即检验码，采用CRC，不检验前导码其他均检验</li><li>除数据部分长度为18字节(IP首部长度为20字节)</li></ul><blockquote><p>由于以太网传送帧时，各帧之间必须要有一定的间隙，所以接收端只要找到帧开始定界符即可确定一个连续的帧，因此MAC帧没有帧结束符</p><p>除上图中的标准还有一种IEEE802.3标准</p></blockquote><p>14.MAC地址实际上就是适配器地址，适配器(网卡)插入到计算机其标识符就成了MAC地址，而适配器有过滤功能</p><ul><li>单播帧(一对一)：收到的帧的MAC地址与本站的硬件地址相同</li><li>广播帧(一对全体)：发送给本局域网上所有站点的帧(全1地址)</li><li>多播帧(一对多)：发送给本局域网上一部分站点的帧</li></ul><blockquote><p>以太网的适配器有种混杂模式，其可收下监听到的所有帧</p></blockquote><p>15.虚拟局域网VLAN是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong></p><ul><li>使用VLAN，交换机可将一个广播域划分，使得网络不会因传播过多广播信息(广播风暴)而引起性能恶化</li></ul><p>16.网桥：根据MAC帧的目的地址进行转发和过滤</p><ul><li>透明网桥：以太网上的站点并不知道所发送的帧将经过哪几个网桥，即插即用自学习</li><li>源路由网桥：发送帧时，将详细的最佳路由信息放到帧的首部</li></ul><p>17.交换机：实质上是多端口网桥，一般全双工工作，<strong>主机不会平分带宽</strong>(集线器会)</p><ul><li>每个端口都直接和一个主机或另一个集线器相连避免了碰撞，且都是一个冲突域</li><li>根据MAC地址转发</li></ul><p>18.冲突域和广播域</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201226002509072.png"  alt="image-20201226002509072"></p><table><thead><tr><th>设备</th><th>区别</th></tr></thead><tbody><tr><td>路由器</td><td>可以互联两个不同网络层协议的网段</td></tr><tr><td>交换机</td><td>可以互联两个物理层和链路层不同的网段</td></tr><tr><td>集线器</td><td>不能互联两个物理层不同的网段</td></tr></tbody></table><p>19.理想条件下，信道利用率=发一帧时间/(发一帧时间+一个端到端时延)</p><h2 id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2><p>1.某个CDMA站接收方收到一条碎片系列:(-1+1-3+1-1-3+1+1)<br>假设各个站点的码片向量如下:<br>站点A:(-1-1-1+1+1-1+1+1)站点B:(-1-1+1-1+1+1+1-1)<br>站点C:(-1+1-1+1+1+1-1-1)站点D:(-1+1-1-1-1-1+1-1<br>问哪些站点发送了数据?分别发送了什么数据?</p><p>答:只需将接收到的碎片序列分别与站点A、B、C、D的码片向量进行规格化内积即可。</p><p>内积为1表示发送了比特1,内积为-1表示发送了比特0，内积为0表示没有发送数据<br>站点A:(-1+1-3+1-1-3+1+1)·(-1-1-1+1+1-1+1+1)/8=1。<br>站点B:(-1+1-3+1-1-3+1+1)·(-1-1+1-1+1+1+1-1)/8=-1。<br>站点C:(-1+1-3+1-1-3+1+1)·(-1+1-1+1+1+1-1-1)/8=0<br>站点D:(-1+1-3+1-1-3+1+1)·(-1+1-1-1-1-1+1-1)/8=1。<br>因此,站点A和站点D发送了比特1,站点B发送了比特0,站点C没有发送数据。</p><p>2.某以太网交换机具有24个100Mbit/s的全双工端口与2个1000 Mbit/s的全双工端口,其总带宽最大可以达到(D)<br>A. 0.44Gbit/s B. 4.4Gbit/s<br>C. 0.88Gbit/s D. 8.8Gbit/s<br>解析:因为是全双工,总带宽=24×100Mbit/s×2+2×1000Mbit/sx2=8800Mbit/s=8.8Gbit/s。</p><p>若此题改为半双工,则答案为B。<br>交换机最大的优点是不仅其每个端口节点所占用的带宽不会因为端口节点数量的增加而减少,而且整个交换机的总带宽会随着端口节点的增加而增加。</p><p>3.在OSI参考模型中,下面哪些是数据链路层的功能?(A)<br>Ⅰ.帧同步II.差错控制Ⅲ.流量控制Ⅳ.拥塞控制<br>A.I、Ⅱ和ⅢB.I、Ⅱ和Ⅳ<br>C.I、Ⅲ和ⅣD.Ⅱ、Ⅲ和Ⅳ</p><p>答：在OSI模型中数据链路层有流量控制和差错控制的功能，而在TCP/IP模型中这两个功能交给了传输层。而无论哪一个模型，帧同步都是数据链路层的，拥塞控制都是传输层的。</p><p>4.发送方准备发送的信息位为1101011011,采用CRC校验算法,生成多项式为G(x)=x<sup>4</sup>+x+1,那么发出的校验位应该为（D）<br>A.0110B.1010C.1001D.1110</p><p>答：生成多项式为x<sup>4</sup>+x+1，即10011</p><p>1101 0110 11 0000 % 10011 =1110</p><blockquote><p>第一步先加0，x最高4次方那就加4个0</p></blockquote><p>5.假设数据链路层采用后退N帧协议进行流量控制,发送方已经发送了编号为0~6号的帧。当计时器超时时,2号帧的确认还没有返回,则发送方需要重发的帧数是(B)<br>A.1B.5C.6D.7</p><p>答：因为2号帧没返回确认所以要将2号及以后的所有帧均重发，23456即5个</p><p>后退N帧协议没收到一个就要把它和它之后的都重发使得效率降低，而选择重传哪个出错就只重传哪个</p><p>6.根据 CSMA/CD协议的工作原理,需要提高最短帧长度的是（D）<br>A.网络传输速率不变,冲突域的最大距离变短<br>B.上层协议使用TCP的概率增加<br>C.在冲突域不变的情况下减少线路的中继器数量<br>D.冲突域的最大距离不变,网络传输速率提高</p><p>答：最小帧长=数据传输速率*往返时延</p><p>最小帧若想变大，那么可以提高传输速率或者提高时延。A中距离变短会使得往返时延也降低</p><blockquote><p>由公式可以看出，最小帧长与距离和速率成正比</p></blockquote><p>7.在以太网的二进制后退算法中,在4次碰撞之后,站点会在0和（C）之间选择一个随机数<br>A.7B.8C.15D.16</p><p>答：10次以内：2<sup>i</sup>-1。10次以上：2<sup>10</sup>-1=1023</p><p>8.一个通过以太网传送的IP分组有60B长,其中包括所有头部。若没有使用LLC<br>则以太网帧中需要（C）填充字节。<br>A.4字节B.144字节C.0字节D.64字节</p><p>答：以太网最小帧为64字节。其中帧的目的地址+源地址+类型+FCS已经占了18字节，加上帧的数据部分(整个IP分组就是帧数据部分)已经达到了60+18=78字节的长度，因此不需要再填充字节。</p><p>9.下列介质访问控制方法中,可能发生冲突的是（B）<br>A. CDMAB.CSMAC. TDMAD. FDMA</p><p>答：码分多路复用CDMA、时分多路复用TDMA和频分多路复用FDMA都属于信道划分介质访问控制，相当于一人一个专用道肯定不会发生冲突。</p><p>而对于随机访问介质来说可能就会发生冲突，如CSMA、CSMA/CD等</p><blockquote><p>助记：CSMA和CDMA判断静态还是动态记住玩&quot;CS&quot;动起来，所以CSMA是动态划分信道</p></blockquote><p>10.主机甲与主机乙之间使用后退N帧协议（GBN）传输数据，甲的发送窗口尺寸为1000，数据帧长为1000字节，信道宽带为100Mbps，乙每收到一个数据帧立即利用一个短帧（忽略其传输延迟）进行确认，若甲乙之间的单向传播延迟是50ms，则甲可以达到的最大平均数据传输速率约为（C）</p><p>A.10 MbpsB.20 MbpsC.80 MbpsD.100 Mbps</p><p>答：甲的发送窗口为1000，也就是发完第一个帧之后在收到该帧的确认前最多能再发999个帧。</p><p>不考虑带宽要想传输速率最大就要把这999帧都发出去。</p><p>而收到确认时延为2*50ms=0.1s，也就是说大约0.1s内发送1000x1000B=1MB数据。</p><p>V=1MB/0.1s=10MB/s=80Mbit/s</p><p>最终结果为min{100Mbit/s，80Mbits/s}=80MBit/s</p><blockquote><p>注意这里的最大传输速率是指豌豆射手吐豌豆的速率</p></blockquote><p>11.站点A、B、C通过CDMA共享链路,A、B、C的码片序列(chipping sequence)分别是(1,1,1,1)、(1,-1,1,-1)和(1,1,-1,1)。若C从链路上收到的序列是(2,0,2,0,0,-2,0,-2,0,2,0,2),则C收到A发送的数据是（B）<br>A.000B.101C.110D.111</p><p>答：将收到的序列分为三组分别为(2,0,2,0)、(0、-2、0、-2)、(0、2、0、2)分别与A的码片序列做内积运算</p><p>(2,0,2,0)*(1,1,1,1)/4=1</p><p>(0、-2、0、-2)*(1,1,1,1)/4=-1</p><p>(0、2、0、2)*(1,1,1,1)/4=1</p><p>所以A收到的数据为101</p><p>12.决定局域网特性有3个主要技术分别为（传输介质、拓扑结构和介质访问控制方法）</p><p>13.一个PPP帧的数据部分（用十六进制写出）是<strong>7D 5E</strong> FE 27 <strong>7D 5D</strong> <strong>7D 5D</strong> 65 <strong>7D 5E</strong>。试问真正的数据是什么（用十六进制写出）？</p><p>答：字节填充：7D–&gt;7D 5D，7E–&gt;7D 5E</p><p>所以答案为7E FE 27 7D 7D 65 7E</p><p>14.数据链路层的主要功能是（D）<br>A.直接为用户的应用进程提供服务B.负责主机中两个进程之间的通信<br>C.负责为分组交换网上的不同主机提供通信D.在两个相邻结点间的链路上传送以帧为单位的数据</p><p>答：A.应用层才是顶层离用户进程最近，因此直接为用户的应用进程提供服务的是应用层</p><p>B.负责主机中两个进程之间的通信的是传输层(进程对进程)</p><p>C.注意&quot;分组&quot;二字，应想到这和网络层有关，因此负责为分组交换网上的不同主机提供通信的是网络层</p><p>D.显然帧是数据链路层的内容</p><p>15.数据链路层的三个基本问题是 [封装成帧]、[透明传输]、[差错检测]</p><p>16.假定1km长的 CSMA/CD网络的数据率为1Gbit/s。设信号在网络上的传播速度为200000km/s。能够使用此协议的最短帧长是 [1250]字节</p><p>答：问的是最短帧长所以是最短帧长问题</p><p>最短帧长=数据发送速率*往返时延</p><p>数据发送速率是1Gbit/s，所以要求往返时延</p><p>而往返时延=2倍的传播时延。一个传播时延=1km / 200000km/s =5us，因此往返时延=10us</p><p>所以最短帧长=10us*1Gbit/s=10 * 10<sup>-6</sup> * 10<sup>9</sup>=10000bit=1250B</p><blockquote><p>要能根据题目想到隐含条件，这里的往返时延就是根据题目计算得来</p></blockquote><p>17.在一个采用CSMA/CD协议的网络中,传输介质是一根完整的电缆,传输速率为1Gbit/s,电缆中的信号传播速度为200000km/s,若最小数据帧减少800bit,则最远的的两个站点之间的距离至少需要？（B）</p><p>A.增加160mB.减少80mC.减少160mD.增加80</p><p>答：设距离为L，则最短帧长MIN=发送速率*往返时延=10<sup>9</sup> *2* (L/2*10<sup>8</sup>)</p><p>所以MIN=10L，因此最短帧长较少800bit，那距离至少减少800/10=80m</p><p>18.某局域网采用CSMA/CD协议实现介质访问控制，数据传输速率为10Mbit/s，主机甲和主机乙之间的距离为2km，信号传播速度为200 000km/s。请回答下列问题，要求说明理由或写出计算过程。</p><p>1）若主机甲和主机乙发送数据时发生冲突，则从开始发送数据时刻起，到两台主机均检测到冲突时刻止，最短需经过多长时间？最长需经过多长时间（假设主机甲和主机乙发送数据过程中，其他主机不发送数据）？</p><p>答：当甲和乙同时发送数据时，这种时候时间最短。这段时间相当于端到端单倍传播时延。</p><p>T<sub>min</sub> = 2km ÷ 200 000km/s = 0.01ms</p><p>若甲或乙先发送数据，当数据即将到达对方时，对方也开始发送数据。此时两台主机检测到冲突的时间最长</p><p>T<sub>max</sub> = (2km ÷ 200 000km/s) × 2 = 0.02ms</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/7574500_1526114891684_99690CEB4497B881D24E5DDEE39D9EE0"  alt="img"></p><p>2）若网络不存在任何冲突与差错，主机甲总是以标准的最长以太网数据帧（1518B）向主机乙发送数据，主机乙每成功收到一个数据帧后立即向主机甲发送一个64B的确认帧，主机甲收到确认帧后方可发送下一个数据帧。此时主机甲的有效数据传输速率是多少（不考虑以太网的前导码）？</p><p>答：甲的发送时延为 (1518 × 8b) ÷ 10Mb/s=1.2144ms</p><p>甲发送数据帧最后一比特的传播时延为 0.01ms</p><p>乙发送确认帧的发送时延为 (64×8bit) ÷ 10Mb/s=0.0512ms</p><p>乙发送确认帧的最后一比特的传播时延为 0.01ms</p><p>所以主机甲的发送周期T=1.2144ms+0.01ms+0.512ms+0.01ms ≈  1.2856ms</p><p>以太网帧的有效载荷为1500B,即去掉14B首部和4B尾部后的长度，而且题目说明不考虑前导码</p><p>综上所述，主机甲的有效数据传输速率为 (1500 × 8b) ÷ 1.2856ms ≈ 9.33Mb/s。</p><blockquote><p>注意有效数据传输速率的含义，虽然甲的发送速率已知，但发过去后乙只有确认后甲才能继续发，所以要求一个发送周期所需时间</p><p>而且甲发的数据并不都是有效数据，去掉首部和尾部才是有效数据</p></blockquote><p>19.下图中，以太网交换机有 <strong>6</strong> 个接口，分别接到 <strong>5</strong> 台主机和一个路由器。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210103095048960.png"  alt="image-20210103095048960"></p><p>在下面表中的“动作”一栏中。表示先后发送了 <strong>4</strong> 个帧。假定在开始时，以太网交换机的交换表是空的。</p><p>试把该表中其他的栏目都填写完。表格如下：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210103095232348.png"  alt="image-20210103095232348"></p><blockquote><p>从这题也能看出交换机的工作原理，如果交换表中没有目的主机就向除发送端口外的所有端口转发，同时把发送方的端口存到交换表中(交换表不存在它的端口时)，以后谁想给它发由于交换表存有它的接口所以就只用向这个接口转发就行了</p></blockquote><h1>网络层</h1><h2 id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2><p>1.网络层提供的两种服务</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102174401148.png"  alt="image-20210102174401148"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210102174442580.png"  alt="image-20210102174442580"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201213175034810.png"  alt="image-20201213175034810"></p><p>2.网络层功能</p><ul><li><p>异构网络互联：IP协议使得性能各异的网络形成一个虚拟互联网络，使得看起来好像是一个统一的网络</p></li><li><p>路由选择(确定哪一条路径)与分组转发(从合适的端口转发出去)</p></li><li><p>拥塞控制：结点都来不及接收分组而丢弃大量分组，此时就处于拥塞状态要采取措施缓解</p><ul><li>开环控制：事先考虑发生拥塞的因素，运行后不再修改（静态–事前诸葛亮）</li><li>闭环控制：即时检测然后报告拥塞再调整措施（动态–监控系统–事后算你账）</li><li>判断依据：网络的吞吐量是否随着负载的增加而不断下降</li><li>拥塞控制考虑全局，而流量控制只考虑发送端和接收端</li></ul></li></ul><p>3.IPV4分组</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228084343061.png"  alt="image-20201228084343061"></p><ul><li>版本：占4位，指明IP数据报是IPv4还是IPv6，通信双方需保持一致</li><li>首部长度：占4位，单位是4B，最大值1111时最大表示60B<ul><li>实际首部60B，但有40B基本不用，所以做题<strong>默认首部20B</strong></li></ul></li><li>区分服务：占1B，指期望获得哪种类型的服务</li><li>总长度：占2B，单位为1B，就是首部+数据的长度</li><li>标识：占2B，同一数据报的分片使用同一标识</li><li>标志：占3位，目前只有前2位有意义<ul><li>MF(More Fragment)：分割后表该分片后面还有分片吗，1为真表后面还有分片</li><li>DF(Don’t Fragment)：表不能分片吗？1为真表不能分片</li></ul></li><li>片偏移：占13位，单位是8B，表分片后该片在原分组的相对位置</li><li>生存时间(Time To Live–TTL)：占8位，防止数据报在网络中一直转圈，即表可通过的最大路由器数</li><li>协议：占8位，携带数据部分的协议，以便让接收方知道应该交给谁处理(如交给TCP)</li><li>首部检验和：占16位，注意<strong>只检验数据报首部</strong>不检验数据部分</li><li>源地址：占32位，表发送端主机的IP地址</li><li>目的地址：占32位，表接收端主机的IP地址</li><li>填充：首部长度单位为4B，若不是4B倍数就要填充成4B倍数</li></ul><blockquote><p>一种八片首饰（总长度单位1B，片偏移单位8B，首部长度单位4B）</p><p>得到目标IP后要转成MAC地址，因为MAC地址才是数据链路层和物理层使用的地址，可理解为它不认识IP地址</p><p>虚拟分组(Virtual Packet)就是IP数据报</p></blockquote><p>2.分类的IP地址</p><p>格式：{网络号,主机号}采用点分十进制如10.12.26.178，32位</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228092559704.png"  alt="image-20201228092559704"></p><blockquote><p>最大可用网络号如A类有8位网络号，但第一位是固定的还剩7位，最多表示2<sup>7</sup>但不能全0(表本网络)也不能全1(127表环回测试)所以要减2。对于B类(不能指派128.0)和C类(不能指派192.0.0)所以都要减1</p><p>最大主机数都减2是减去了全0(表示一个网络)和全1(广播地址)的情况</p></blockquote><table><thead><tr><th>NetID网络号</th><th>HostID主机号</th><th>作为IP分组源地址</th><th>作为IP分组目的地址</th><th>用途</th></tr></thead><tbody><tr><td>全0</td><td>全0</td><td>可以</td><td>不可以</td><td>本网络上的本主机，路由表中用于表示默认路由</td></tr><tr><td>全0</td><td>特定值</td><td>可以</td><td>不可以</td><td>表示本网内某个特定主机</td></tr><tr><td>全1</td><td>全1</td><td>不可以</td><td>可以</td><td>本网广播地址（路由器不转发）</td></tr><tr><td>特定值</td><td>全0</td><td>不可以</td><td>不可以</td><td>网络地址，表示一个网络</td></tr><tr><td>特定值</td><td>全1</td><td>不可以</td><td>可以</td><td>直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td>127</td><td>非全0或非全1</td><td>可以</td><td>可以</td><td>用于本地软件环回测试，称为环回地址</td></tr></tbody></table><p>3.私有IP地址</p><p>私有IP地址只能用于局域网，无法在internet使用，如最常见的192.168.0.1</p><table><thead><tr><th>地址类别</th><th>地址范围</th><th>网段个数</th></tr></thead><tbody><tr><td>A类</td><td>10.0.0.0~10.255.255.255 即10.0.0.0/8</td><td>1</td></tr><tr><td>B类</td><td>172.16.0.0~172.31.255.255 即172.16.0.0/<strong>12</strong></td><td>16</td></tr><tr><td>C类</td><td>192.168.0.0~192.168.255.255 即192.168.0.0/16</td><td>256</td></tr></tbody></table><blockquote><p>事实上我们的手机电脑都可以连网但他们并不在因特网上，查看ip会发现都是私有IP地址</p><p>那他们又是怎么上网的呢，答案为用NAT</p></blockquote><p>4.网络地址转换NAT(Network Address Translation)：NAT将专用网内部使用的IP转换成有效的全球IP使得专用网内只需一个全球IP就可以和因特网连通</p><ul><li><p>在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。</p></li><li><p>NAT节省了IP的消耗，但没增加IP个数，真正解决IP耗尽问题的是IPv6</p></li></ul><p>5.子网划分</p><ul><li>原因：IP地址空间利用率很低且两级IP地址不够灵活</li><li>将两级地址划为三级即IP地址={网络号,子网号,主机号}<ul><li>划分子网后，对外仍表现为一个网络，即本单位外的网络看不见本单位内子网的划分</li></ul></li></ul><p>6.子网掩码：将IP地址分为网络地址和主机地址两部分，可据此判断两个主机是否处于同一网段</p><ul><li>对应IP地址中的网络号和子网号位置为全1，主机号位置为全0</li><li>不管有没有划分子网，只要将子网掩码和IP地址相与就一定能得到网络地址</li></ul><p>7.使用了子网掩码后的路由转发分组算法</p><ul><li>1.从收到的分组首部提取目的IP地址D</li><li>2.先判断是否为直接交付,用那些和路由器直接相邻的网络的子网掩码和D逐位相“与”,看是否和相应的网络地址匹配。若匹配,则将分组直接交付,否则就是间接交付。</li><li>3.若路由表中有目的地址为D的特定主机路由,则将分组传送给指明的下一跳路由器，否则执行4</li><li>4.对路由表中的每一行的子网掩码和D逐位相“与”。若其结果与该行的目的网络地址匹配,则将分组传送给该行指明的下一跳路由器;否则,执行5</li><li>5.若路由表中有一个默认路由,则将分组传送给路由表中所指明的默认路由器;否则执行6</li><li>6.报告转发分组出错</li></ul><p>8.无分类编址CIDR：ip地址后加上&quot;/&quot;，然后写上网络前缀位数</p><ul><li>为解决IP地址耗尽而提出的一种措施</li><li>作用：把小的网络汇聚成大的超网</li><li>消除了传统的A类，B类和C类地址以及<strong>划分子网的概念</strong></li><li>融合子网地址与子网掩码，方便子网划分，把网络前缀都相同的连续的IP地址组成一个&quot;CIDR地址块&quot;</li></ul><p>9.路由聚合(构成超网)：将多个子网聚合成一个较大的子网</p><ul><li>方法：将网络前缀缩短即所有网络地址取交集</li></ul><p>10.最长前缀匹配：使用CIDR查路由表(与网络掩码相与)时可能得到多个匹配结果，应选择网络前缀最长的那个</p><ul><li><p>原因：前缀越长，地址块越小，路由越具体</p><blockquote><p>外卖可以送到你的小区，也可以送到你家门口(更具体)，那当然是选择送家门口了</p></blockquote></li></ul><p>11.ARP协议：完成主机或路由器IP地址到MAC地址的映射，<strong>解决下一跳走哪的问题</strong></p><ul><li>出现原因：在链路上传送数据帧时，必须要使用MAC地址</li><li>使用过程：检查ARP高速缓存，有对应项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并<strong>广播ARP请求分组</strong>，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机<strong>单播一个ARP响应分组</strong>，源主机收到后将此映射写入ARP缓存（10-20min更新一次）</li><li>4种典型情况（地址解析自动进行）<ul><li>ARP找到本地主机B的硬件地址<ul><li>主机A发给本网络的主机B</li><li>路由器发给本网络的主机B</li></ul></li><li>ARP找到本网络上的一个路由器的硬件地址，剩下的由路由器完成<ul><li>主机A发给另一网络的主机B</li><li>路由器发给另一网络的主机B</li></ul></li><li>总结：发给本网络就找本地对应主机的硬件地址，发给另一网络就找路由器的硬件地址</li></ul></li></ul><p>12.动态主机配置协议DHCP：提供即插即用连网的机制，主机可从服务器动态获取IP地址等信息。</p><ul><li><p><strong>属于应用层协议</strong>，使用客户/服务器方式</p></li><li><p>客户端和服务端通过广播方式交互，基于UDP</p></li><li><p>支持地址重用、移动用户加入网络、在用地址续租</p></li><li><p>客户端和服务端交换过程如下</p><ul><li>主机广播DHCP发现报文：试图找到网络中的服务器，服务器获得一个IP地址<ul><li>即主机喊了一声：“有没有DHCP服务器呀？”</li></ul></li><li>DHCP服务器广播DHCP提供报文：服务器拟分配给主机一个IP地址及相关配置<ul><li>多个服务器回答：“有的有的，我发给你IP地址用我的吧”</li></ul></li><li>主机广播DHCP请求报文：主机向服务器请求提供IP地址<ul><li>主机继续问：“你们哪个先到我就用哪个，那我用啦？”</li></ul></li><li>DHCP服务器广播DHCP确认报文：正式将IP地址分配给主机<ul><li>服务器回答：“好的好的，你用吧”</li></ul></li></ul><p>13.网际控制ICMP协议：为了更有效的转发IP数据报和提高交付成功的机会</p><blockquote><p>可理解为哪地方错了你告诉我一声我好改 或者 我有事要问问你</p></blockquote><ul><li><p>ICMP差错报文</p><ul><li>终点不可达：无法交付时向源点发</li><li><strong>源站抑制</strong>：<strong>拥塞</strong>丢数据时向源点发</li><li>时间超过：路由器收到生存时间TTL=0的数据报，向源点发送该报文</li><li>参数问题：收到的数据报首部字段有问题时向源点发</li><li>改变路由(重定向)：可以选择更好的路由，向源点发</li></ul></li><li><p>不应发送ICMP差错报文的情况</p><ul><li>对ICMP差错报文不再发送ICMP差错报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有组播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li></ul></li><li><p>ICMP询问报文</p><ul><li>有回送请求和回答报文：测试目的站是否可达以及了解其相关状态</li><li>时间戳请求和回答报文：请某个主机回答当前时间，用来时钟同步和测量时间</li><li>掩码地址请求和回答报文</li><li>路由器询问和通告报文</li></ul></li><li><p>应用</p><ul><li>ping：测试两个主机的连通性，使用了ICMP回送请求和回答报文</li><li>tracert：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文</li></ul></li><li><p>ICMP报文格式</p><ul><li>下图中根据ICMP报文类型源主机就知道发生了什么故障了</li><li>ICMP报文是放在IP数据报中的数据部分，组成IP数据报发送出去</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228165533997.png"  alt="image-20201228165533997"></p><ul><li><p>下图中根据IP数据报的首部就知道是哪个数据报错了</p></li><li><p>ICMP前8字节相当于ICMP的首部，对应上图的64位即最上面两行部分</p></li><li><p>而IP数据报数据部分前8个字节也要放入ICMP报文因为该8个字节包含了TCP(也可能是UDP,下同)报文首部中的TCP端口号，这样源主机和用户进程有了端口才能更好的联系起来</p></li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201228165601583.png"  alt="image-20201228165601583"></p></li></ul></li></ul><p>14.IPv6：由于IPv4即将耗尽且NAT和CIDR都没从根本上解决耗尽问题，为此诞生出IPv6从根本解决耗尽问题</p><ul><li>更大的地址空间：从32位增加到<strong>128位</strong></li><li><strong>不允许分片</strong>，数据报太大就会被丢弃,允许在源节点分片</li><li>扩展的地址层次结构：地址多了自然可划分更多层次</li><li>将IPv4的<strong>检验和字段移除</strong>以减少每跳的处理时间</li><li>取消协议字段改为下一个首部字段</li><li>取消总长度字段改为有效载荷长度字段</li><li>取消服务类型字段</li><li>将IPv4的可选字段移除首部变成扩展首部，首部更加灵活，路由器通常不检查扩展首部</li><li>允许协议继续扩充</li><li>支持即插即用（自动配置），不需要DHCP协议</li><li>支持资源的预分配，支持实时影像等要求</li><li>首部长度必须是<strong>8B的倍数</strong>而非IPv4的4B的倍数</li></ul><p>15.IPv6数据报格式</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201228201932828.png"  alt="image-20201228201932828"></p><ul><li>版本：占4位，指明协议版本，对于IPv6，该字段为6</li><li>优先级：占8位，区分不同IPv6类别或优先级，0-15优先级依次增大，0-7表允许延迟，8-15表高优先级需固定速率传输</li><li>流标签：占20位，所有属于同一个流的数据报具有相同的流标签</li><li>有效载荷长度：占16位，指明IPv6除基本首部以外的字节数，最大值为64KB</li><li>下一个首部：占8位，相当于IPv4的协议字段或可选字段</li><li>跳数限制：占8位，每经过一个路由器减1值为0时丢弃该数据报（TTL换了个名字）</li><li>源地址：占128位，数据报发送方的IP地址</li><li>目的地址：占128位，数据报接收方的IP地址</li></ul><p>16.IPv6用冒号十六进制表示：每16bit用一个十六进制数表示，各值用冒号分隔</p><ul><li>如4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</li><li>缩写法<ul><li>4BF5:0000:0000:0000:BA5F:039A:000A:2176–》4BF5:0:0:0:BA5F:39A:A:2176</li></ul></li><li>零压缩：一连串连续的0可以被一对冒号取代但双冒号表示法一个地址仅能出现一次双冒号<ul><li>FF05:0:0:0:0:0:0:B3–》FF05::B3</li></ul></li></ul><p>17.IPv6基本地址类型</p><ul><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ul><p>18.IPv4向IPv6过渡的策略</p><ul><li>双栈协议：一台设备上同时启用IPv4协议栈和IPv6协议栈</li><li>隧道技术：隧道技术将其它协议的数据帧或包重新封装然后通过隧道传输</li></ul><p>19.路由算法</p><ul><li>静态路由算法(非自适应路由算法)：管理员手动配置路由信息<ul><li>路由更新慢，不适合大型网络</li><li>虽然非自适应并不是一旦启动就不能更改只是它不能自动更改(可人为修改)</li></ul></li><li>动态路由算法：路由器间彼此交换信息，按照路由算法优化出路由表项<ul><li>全局性：所有路由器掌握完整的网络拓扑和链路费用信息，如OSPF</li><li>分散性：路由器只掌握物理相邻的邻居及链路费用，如RIP</li><li>特点：算法复杂，增加网络负担</li></ul></li></ul><p>20.自治系统AS：一个AS内的所有网络都属于一个行政单位管辖，内部使用AS内部的路由选择协议</p><ul><li>诞生原因：因特网规模很大，很多单位不想让外界知道自己的路由选择协议，但还想进入因特网</li></ul><p>21.路由选择协议</p><ul><li>内部网关协议IGP：在一个自治系统内使用，如RIP和OSPF（inside内部）</li><li>外部网关协议EGP：不同自治系统间使用，如BGP       （external外部）</li></ul><blockquote><p>网关和路由器是同义词，可按路由器理解</p></blockquote><p>22.RIP协议：分布式的基于距离向量的路由选择协议，最大优点是简单</p><ul><li>要求每个路由器维护从它自己到其它每个目的网络的唯一最佳距离记录<ul><li>距离：即跳数，从源端口到目的端口所经历的路由器个数</li><li>注意最大距离为16表示网络不可达</li></ul></li><li>和谁交换，多久交换一次，交换什么内容，传送方式<ul><li>和谁交换：仅和相邻路由器交换信息</li><li>交换什么：交换信息内容为自己所知道的全部信息即自己的路由表</li><li>多久交换：按固定间隔(如30s)交换路由信息</li><li>传送方式：UDP</li></ul></li><li>收敛：路由器第一次工作只知道自己相邻距离即1而经若干次更新后，所有路由器都会知道任一个网络的最短距离和下一跳地址</li><li>只适用于小的互联网（大的网络路由器数量肯定远远大于15个）</li></ul><p>23.RIP协议格式</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228212747369.png"  alt="image-20201228212747369"></p><p>24.RIP协议特点：好消息传的快，坏消息传的慢</p><ul><li>当网络出现故障时，要经过比较长的时间(如数分钟)才能将此信息传送到所有的路由器(慢收敛)<ul><li>若一个网络出现故障可能两个路由器不断更新路由表直到距离为16才知道不能到达那个损坏的网络</li></ul></li></ul><p>25.距离向量算法：即使用RIP协议的路由表怎么更新</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228212310617.png"  alt="image-20201228212310617"></p><p>一个小例题帮助理解（更新R6路由表）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201228212614653.png"  alt="image-20201228212614653"></p><p>26.开放最短路径优先OSPF协议：使用分布式的链路状态协议</p><ul><li>和谁交换，多久交换一次，交换什么内容，传送方式<ul><li>和谁交换：使用洪泛法向自治系统内所有路由器发送信息（广播）</li><li>交换什么：与本路由器相邻的所有路由器的链路状态（路由器所知道的部分信息）</li><li>多久交换：只有链路状态发生变化时，路由器才向所有路由器洪泛发送此消息</li><li>传送方式：IP（由于要交换信息较大不适合用传输层协议）</li></ul></li><li>最终所有路由器都能建立一个链路状态数据库即全网拓扑图</li><li>为了使OSPF能用于很大的网络，将自制系统划分为若干范围，叫做区域</li></ul><p>27.边界网关协议BGP：在不同自治系统之间交换信息，使用路径-向量路由选择协议</p><ul><li>和谁交换：与其它AS的邻站BGP发言人交换信息</li><li>交换什么：交换网络可达性信息，即要到达某个网络所要经历的一系列自治系统(如10.11.21.1/24可通过AS2、AS4、AS5到达)</li><li>多久交换：发生变化时更新有变化的部分</li><li>传送方式：TCP</li><li>四种报文<ul><li>OPEN(打开)报文：用来和相邻的另一个BGP发言人建立关系，并认证发送方</li><li>UPDATE(更新)报文：通告新路径或撤销原路径</li><li>KEEPALIVE(保活)报文：无更新时周期性验证邻站的连通性，也作为OPEN的确认</li><li>NOTIFICATION(通知)报文：报告先前报文的差错，也被用于关闭连接</li></ul></li></ul><p>28.三种路由协议对比</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228220304625.png"  alt="image-20201228220304625"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228220319735.png"  alt="image-20201228220319735"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228220343383.png"  alt="image-20201228220343383"></p><p>RIP适用于规模较小的网络，OSPF适用于规模很大的自治系统，BGP适用于不同自治系统间通信</p><p>29.单播和组播(也称多播)</p><ul><li>单播：发送者和每一个接收者之间都需要单独的数据信道（10个接收者那就要发10份数据）</li><li>组播：源主机只发一份数据，目的地址为组播地址，传输数据遇到如路由器时才会将数据复制继续转发<ul><li>组播地址范围为部分D类地址，不能用作源地址</li><li>尽最大努力交付，不提供可靠交付</li><li>对组播数据不产生ICMP差错报文</li></ul></li></ul><p>30.网际组管理协议IGMP：让路由器知道本局域网上是否有主机参加或退出了某个组播组</p><ul><li>某主机若想加入组播组，向组播地址发IGMP报文声称想要加入</li><li>本地组播路由器收到后利用组播路由选择协议把这组成员关系发到因特网其它组播路由器</li><li>本地组播路由器周期性探寻本地局域网主机，以便知道这些主机是否还是组播成员<ul><li>组内只要有一个主机响应则认为这个组是活跃的，若几次探寻都无主机回应则不再把这组成员关系发给其他组播路由器</li></ul></li><li>目的是找出以源主机为根节点的组播转发树(树可避免兜圈子)</li><li>IGMP和ICMP一样都使用IP数据报传递报文</li></ul><p>31.移动IP：移动结点以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证网络权限不会改变</p><ul><li><p>移动结点：具有永久IP地址的移动设备</p></li><li><p>归属(本地)代理：有一个端口和移动节点本地链路相连的路由器，根据移动用户的转交地址采用隧道技术转交其数据报</p></li><li><p>永久地址(主地址)：移动站点在归属网络中的原始地址</p></li><li><p>外部代理：移动结点漫游链路上的路由器，通知本地用户代理自己的转交地址，是移动结点漫游链路的默认路由器</p></li><li><p>转交地址(辅地址)：可以是外部代理的地址或动态配置的一个地址(临时地址)</p></li><li><p>通信过程</p><ul><li><p>移动结点在外部代理登记注册一个转交地址</p></li><li><p>本地代理截获发给移动节点的数据报</p></li><li><p>本地代理再封装数据报，新的数据报目的地址是转交地址，发给外部代理</p></li><li><p>外部代理拆封数据报并发给移动节点</p><blockquote><p>你去学校(外部网络)上学，有人给你写信寄到你家(归属网络)，你妈妈(归属代理)拿着信去学校交给你(虽然目的是交给你，但先给外部代理(路由器)，由外部代理交给你)</p><p>也就是你要是在家就直接交给你，但你不在家就要有个中间人转交给你</p></blockquote></li></ul></li></ul><p>32.路由器：一种具有多个输入和输出端口的专用计算机，任务是连接不同的网络转发分组</p><p>路由器的结构如下</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228233119198.png"  alt="image-20201228233119198"></p><blockquote><p>路由器的输入或输出队列产生溢出是造成分组丢失的重要原因</p></blockquote><p>33.路由表由路由选择算法得出，主要用于路由选择，用软件来实现</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201228233901800.png"  alt="image-20201228233901800"></p><p>来了一个分组，就要根据路由表将其转发出去</p><ul><li>将该目的IP分别与路由表子网掩码相与(二进制)，看结果是否有和表中的目的网络相同的<ul><li>若有相同的按表中转发端口和下一跳将其转发出去</li><li>若都没有相同的就按照图中最后一行的默认路由转发出去</li></ul></li></ul><blockquote><p>默认路由：根据目的地址在路由列表中没有匹配的路由时就交给默认路由，再由它交给另一个路由</p></blockquote><h2 id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2><p>1.在路由器进行互连的多个局域网的结构中,要求每个局域网©<br>A.物理层、数据链路层、网络层协议都必须相同,而高层协议可以不同<br>B.物理层、数据链路层协议可以不同,而数据链路层以上的高层协议必须相同<br>C.物理层、数据链路层、网络层协议可以不同,而网络层以上的高层协议必须相同<br>D.物理层、数据链路层、网络层协议及高层协议都可以不同</p><p>答：本层及本层以下的协议可以不同，但是高层协议必须相同，而局域网处于网络层因此选C</p><p>2.在链路状态路由算法中,每个路由器得到了网络的完整拓扑结构后,使用(B)算法来找出从它到其他路由器的路径长度。<br>A.Prim最小生成树算法B.Dijkstra最短路径算法<br>C.Kruskal最小生成树算法 D.拓扑排序</p><p>答：在链路状态路由算法中,路由器通过交换每个节点到邻居节点的延迟或开销来构建一个网络的完整拓扑结构。得到了完整的拓扑结构后,路由器就使用 Dijkstra最短路径算法来计算到所有节点的最短路径。</p><blockquote><p>路由算法肯定是要找最短路径，其它几个都不是求最短路径的算法</p></blockquote><p>3.下列关于分层路由的描述中,（B）是错误的。</p><p>A.采用了分层路由之后,路由器被划分成区域</p><p>B.每个路由器不仅知道如何将分组路由到自己区域的目标地址,而且知道如何路由到其他区域</p><p>C.采用了分层路由后,可以将不同的网络连接起来</p><p>D.对于大型网络,可能需要多级的分层路由来管理</p><p>答：采用了分层路由之后,路由器被划分为区域,每个路由器知道如何将分组路由到自己所在区域内的目标地址,但是<strong>对于其他区域内部结构毫不知情</strong>。</p><p>当不同的网络被相互连接起来的时候,可以将每个网络当作一个独立的区域,这样做的好处是一个网络中的路由器不必知道其他网络的拓扑结构。</p><p>4.对路由选择协议的一个要求是必须能够快速收敛,所谓“路由收敛”是指（C）<br>A.路由器能把分组发送到预订的目标<br>B.路由器处理分组的速度足够快<br>C.网络设备的路由表与网络拓扑结构保持一致<br>D.能把多个子网汇聚成一个超网</p><p>答：收敛,就是当路由环境发生变化后,各路由器调整自己的路由表以适应网络拓扑结构的变化,最终达到稳定的状态。“收敛”得越快,路由器就越快适应网络拓扑结构的变化</p><p>5.假设有一个B类地址指定了子网掩码255.255.255.0,则每个子网可以有的主机数为（B）<br>A.256B.254C.1024D.1022</p><p>答：B类地址的默认子网掩码是255.255.0.0,而题目给的子网掩码为255.255.255.0</p><p>所以只剩下最后8位来表示主机位,8位可最多表示2<sup>8</sup>而还要去除全0(表示一个网络)和全1(广播地址)的情况也就是256-2</p><p>6.把IP网络划分成子网,这样做的好处是©。<br>A.增加冲突域的大小B.增加主机的数量<br>C.减小广播域的大小D.增加网络的数量</p><p>答：划分子网也就是把一个大的网络划分成许多小的网络。</p><p>而广播域指这个范围内一个主机发广播信息其它主机能收到信息，而由于大网变成了许多小网，每个小网都形成了一个广播域，因此广播域减小了</p><p>7.在一条点对点的链路上,为了减少地址的浪费,子网掩码应该指定为（A）</p><p>A.255.255.255.252B.255.255.255.248<br>C.255.255.255.240D.255.255.255.196</p><p>答：点对点链路也就是只有两台主机，所以只分配两个主机位就可以</p><p>两个主机位所需位数n：2<sup>n</sup>-2=2，所以n=2</p><p>所以子网掩码为 11111111.11111111.11111111.11111100即255.255.255.252</p><blockquote><p>注意要减去全0和全1，两台主机最后一部分分别为11111101和11111110</p></blockquote><p>8.如果用户网络需要划分成5个子网,每个子网最多20台主机,则适用的子网掩码是（C）<br>A.255.255.255.192B.255.255.255.240<br>C.255.255.255.224D.255.255.255.248</p><p>答：划分5个子网需要占3位，而最多20台主机需要占5位(注意要满足等于20台的情况)，因此需要3位子网段和5位主机段，所以网络段占32-5=27位，即27位全1也就是255.255.255.224</p><blockquote><p>其实只看20台主机需要占多少位就行了，子网段一定包含在网络段里也就是说在子网掩码中一定是全1</p></blockquote><p>9.以下给出的地址中,属于子网192.168.15.19/28的主机地址是(A)<br>I.192.168.15.17 Ⅱ.192.168.15.14<br>Ⅲ.192.168.15.16Ⅳ.192.168.15.31<br>A.仅IB.仅I、ⅢC.仅I、Ⅲ、ⅣD.Ⅰ、Ⅱ、Ⅲ和Ⅳ</p><p>答：将IP地址192.168.15.19和28位子网掩码255.255.255.240相与后得到该子网的网络地址为192.168.15.16即最后一部分为0001 0000</p><p>主机位占4位，去掉主机位全0和全1主机位的范围就是0001 0001~0001 1110</p><p>也就是17-30对应主机地址范围为192.168.15.17-192.168.15.30</p><p>10.设有两个子网202.118.133.0/24和202.118.130.0/24,如果进行路由汇聚,得到的网络地址是（A）<br>A.202.118.128.0/21B.202.118.128.0/22<br>C.202.118.130.0/22D.202.118.132.0/20</p><p>答：从前往后看第一个不同的部分即133和130</p><p>转换为二进制为1000 0101和 1000 0010可以发现它们前5位是相同的</p><p>所以第三个字节应该是1000 0000(保留前5位，后面都为0)即128，而掩码中1的个数变为8+8+5=21</p><p>最终答案为202.118.128.0/21</p><p>11.若将网络213.0.0/16划分为128个规模相同的子网,则每个子网可分配的最大IP地址个数是©<br>A.254B.256C.510D.512</p><p>答：这个网络有16位网络地址，16位主机地址，而要划分128个子网而2<sup>7</sup>=128即需要占用7位地址(这7位就是子网号)，而剩下的9位主机地址用来作主机号。</p><p>主机号除去全0和全1即2<sup>9</sup>-2=512-2=510</p><p>12.为什么要划分子网？子网掩码的作用是什么？(帮助理解)</p><p>答：由于因特网的每台主机都要分配一个唯一的IP地址,所以分配的IP地址很多,这将使路由器的路由表变得很大,进而影响了路由器在进行路由选择时的工作效率。解决这个问题的方法就是将一个大的网络划分为几个较小的网络,每个小的网络称为一个子网。</p><p>当一个分组到达一个路由器时,路由器应该能够判断出IP地址的网络号。子网掩码用来判断IP地址的哪一部分是网络号与子网号,哪一部分是主机号。为了完成这种分离,路由器将对IP地址和子网掩码进行“与”运算。</p><p>13.当路由器转发一个IP数据报时,可能改变首部中的哪些字段（DFGHJKL）<br>A.版本B.首部长度C.服务类型D.总长度</p><p>E.标识F.标志G.片偏移H.生存时间</p><p>I.协议J.首部检验和K.源IP地址L.目的IP地址</p><p>答：本题为课堂习题，答案是对的，但解释为个人理解</p><p>A.版本不会变，不可能IPv4传着传着变成IPv6了</p><p>B.首部长度固定20B也不会变</p><p>C.服务类型设置了数据报的优先程度也不会改变的</p><p>D.总长度是首部+数据，而如果中间分片了数据部分肯定变短了</p><p>E.标识是原始数据报发出后就确定了的，即使分片也不会改变不然到达目的地没法组装</p><p>F.标志中如MF，如果传输中分片肯定有一个分片的MF=0而它前面的都为1，这是在分片后改变的</p><p>G.片偏移显而易见只要分片它肯定会变</p><p>H.生存时间每经过一个路由器就减1也会改变</p><p>I.协议中表明它携带的数据使用什么协议，比如携带的是ICMP，那传输过程即使分片也还是携带的ICMP</p><p>J.首部检验和检验的是首部，而首部中的生存时间每经过一个路由器都要变所以它每次也要跟着变</p><p>K和L.源IP和目的IP也会改变</p><ul><li><p>如果使用了NAT即网络地址转换，如手机想上网，手机的IP其实是私有IP，它首先要通过NAT把私有IP地址转为公网IP，这个过程中数据报的源IP由私有地址转为了公网地址。</p></li><li><p>同理因特网上的主机要想与手机发消息，首先它肯定会发给安装了NAT的那个路由器，而路由器收到后会把ip数据报的目的IP换成手机的私有IP地址</p></li></ul><p>14.在一个路由表中，特定主机路由的子网掩码表示为 [255.255.255.255]   (用点分十进制表示)<br>默认路由项中的子网掩码表示为[0.0.0.0],目的网络地址表示为[0.0.0.0]</p><p>答：子网掩码为全1和谁相与都不改变它的值</p><p>默认路由子网掩码是全0也就是无论哪个IP地址和我相与结果都是全0和目的网络全0相匹配，达到了默认路由的功能</p><p>15.假定网络中的路由器B的路由表有如下的项目（这三列分别表示&quot;目的网络&quot;、“距离&quot;和&quot;下一跳路由器”）</p><p>N1 7 A<br>N2 2 C<br>N6 8 F<br>N8 4 E<br>N9 4 F<br>现在B收到从C发来的路由信息（这两列分别表示“目的网络”“距离”）：<br>N2 4<br>N3 8<br>N6 4<br>N8 3<br>N9 5<br>试求出路由器B更新后的路由表（详细说明每一个步骤）</p><p>答：路由器B更新后的路由表如下：<br>N1　　　7　　A　　　　无新信息,不改变<br>N2　　　5　　C　　　　相同的下一跳,更新<br>N3　　　9　　C　　　　新的项目,添加进来<br>N6　　　5　　C　　　　不同的下一跳,距离更短,更新<br>N8　　　4　　E　　　　不同的下一跳,距离一样,不改变<br>N9　　　4　　F　　　　不同的下一跳,距离更大,不改变</p><blockquote><p>注意距离一样时不用改变</p></blockquote><p>16.一个数据报长度为 <strong>4000</strong> 字节（固定首部长度）。现在经过一个网络传送，但此网络能够传送的最大数据长度为 <strong>1500</strong> 字节。试问应当划分为几个短些的数据报片？各数据报片的数据字段长度、片偏移字段 和 <strong>MF</strong> 标志应为何数值？</p><p>答：固定首部位20B，所以数据报的有效数据为4000B-20B=3980B</p><p>而网络最大能传1500B，传输前要为每个分片加上首部，1500B去掉首部的20B，所以网络一次能传送有效数据1480B</p><p>3980 ÷ 1480 =2 余 1020 ，所以需要3片 (注意这些都是有效数据长度即不带首部)</p><p>第一个偏移量为0，第二个为1480/8，第三个为(1480+1480)/8</p><p>​   总长度(字节)   数据长度   MF   片偏移</p><p>原始数据报  4000          3980      0    0</p><p>数据报片1   1500          1480      1    0</p><p>数据报片2   1500          1480      1    185</p><p>数据报片3   1040          1020      0    370</p><blockquote><p>注意算分几片和偏移量的时候都不考虑首部长度，因为分片时，每个分片的首部是后来加上的，我们只用关心数据部分就行</p></blockquote><h1>传输层</h1><h2 id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2><p>1.传输层的功能如下</p><ul><li>提供应用进程间的逻辑通信：逻辑通信指两个进程之间&quot;好像&quot;有一条水平方向的物理连接<ul><li>注意网络层提供的是主机之间的逻辑通信</li></ul></li><li>差错检测：对报文的首部和数据部分都进行检测（网络层只检查IP首部）</li><li>提供无连接和面向连接的服务<ul><li>面向连接的TCP提供了一种可靠性较高的传输服务</li><li>无连接的UDP提供了一种高效率但不可靠的传输服务</li></ul></li><li>复用和分用<ul><li>复用指发送方不同的应用进程可使用同一个传输层协议传送数据到网络层(多到一)</li><li>分用指接收方从网络层收到数据后能够把这些数据正确的交付到目的应用进程(一到多)</li></ul></li></ul><p>2.端口：网络层按IP寻址，而传输层按端口寻址，表明主机中的应用进程，长度16bit</p><ul><li>服务端使用的端口<ul><li>熟知(保留)端口号：给TCP/IP等最重要的一些应用程序，让所有用户都知道。0~1023</li><li>登记端口号：为没有熟知端口号的应用程序使用且为防止重复必须先登记。1024~49151</li></ul></li><li>客户端使用：仅在客户进程运行时才动态选择的端口号。49152~65535</li></ul><p>3.套接字：唯一标识了网络中的某台主机和它的某个应用进程</p><ul><li>套接字Socket=(主机IP地址,端口号)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201229085634033.png"  alt="image-20201229085634033"></p><p>4.用户数据报协议UDP：UDP只是在IP数据报服务之上增加了端口和差错检测的功能</p><ul><li>UDP是无连接的，减少开销和发送数据前的时延</li><li>尽最大努力交付，即不保证可靠传输</li><li>UDP用户数据报只有8个字节的首部开销</li><li>提供复用/分用技术</li><li>面向报文</li><li>无拥塞控制，适合很多实时应用(如实时视频会议)</li><li>适合一次性传输少量数据</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229090549174.png"  alt="image-20201229090549174"></p><p>5.UDP检验</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201229090731295.png"  alt="image-20201229090731295"></p><ul><li>伪首部只在计算检验和时才出现，不向下传送也不向上递交<ul><li>17是协议字段，UDP固定为17</li></ul></li><li>UDP长度：指UDP的8B首部 + 数据部分长度（不包括伪首部）</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201229091519236.png"  alt="image-20201229091519236"></p><table><thead><tr><th>协议名称</th><th>检验和检验内容</th></tr></thead><tbody><tr><td>IP</td><td>首部</td></tr><tr><td>ICMP</td><td>首部+数据</td></tr><tr><td>TCP</td><td>伪首部+首部+数据</td></tr><tr><td>UDP</td><td>伪首部+首部+数据</td></tr></tbody></table><blockquote><p>助记：越往上检验的越多</p></blockquote><p>6.TCP：面向连接的传输层协议，特点如下</p><ul><li>每一条TCP连接只能有两个端点即点对点</li><li>TCP提供可靠交付的服务，无差错，不丢失、不重复、按序到达（不多不少不出错还有序）</li><li>提供全双工通信</li><li>面向字节流，把应用程序传下来的数据看成一连串的无结构的字节流</li></ul><p>7.TCP报文首部格式</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201229092454191.png"  alt="image-20201229092454191"></p><ul><li>序号：占4B，传送的字节流按顺序编号，这样才能保证按序交付</li><li>确认号：占4B，期望收到的下一个报文段的序号<ul><li>若确认号为N表明到序号N-1为止的数据都已正确收到</li></ul></li><li>数据偏移：占4位，其实就是首部长度，最小为0001表示4B最大为1111表示60B</li><li>保留字段：占6位，保留为以后使用，但目前应置0</li><li>紧急URG：URG=1时表明此报文段有紧急数据高优先级不用在缓存排队配合紧急指针使用</li><li>确认位ACK：ACK=1时确认号才有效，连接建立后所有传送的报文段都要把ACK置为1</li><li>推送位PSH：PSH=1时，接收方就应该尽快交付给应用进程，不再等整个缓存填满才交付（催你一下）<ul><li>URG数据不经过缓冲区直接交付，PSH前提是经过缓冲区</li></ul></li><li>复位RST：RST=1时表明TCP连接中出现严重差错，必须释放连接，然后重新建立连接</li><li>同步位SYN：SYN=1时表明这是一个连接请求或连接接受报文</li><li>终止位FIN：FIN=1时表明此报文段发送方数据已发完，要求释放连接</li><li>窗口：占2B，现在允许对方发送的字节数</li><li>检验和：占2B，检验首部+数据，检验时要加上12B伪首部(只需将UDP的伪首部的协议17改为6)</li><li>紧急指针：占2B，当URG=1时才有意义，指出本报文段中紧急数据的字节数</li><li>选项：长度可变，最大报文段MSS、窗口扩大、时间戳、选择确认…</li><li>填充字段：使首部长度是4B的整数倍</li></ul><blockquote><p>由于TCP首部没有目的IP地址，因此TCP必须告诉IP层目的IP地址，此目的IP地址填写在IP首部中</p></blockquote><p>8.TCP连接管理，分为三个阶段</p><ul><li><p>连接建立：采用三次握手的方法（客户/服务器模式）</p><blockquote><p>seq表发送报文的第一个字节的序号，记住TCP连接和释放每次都是只发一个字节内容，而ack是期望收到的第一个字节序号，所以ack=seq+1</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229100046134.png"  alt="image-20201229100046134"></p><p>可理解为如下图所示</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229100208593.png"  alt="image-20201229100208593"></p><p>为什么不采用两次握手？</p><p>答：可能引起死锁，A发送请求，B收到后认为连接建立了，开始发数据。但若B的确认传输过程中丢失了，A不知道B是否准备好甚至怀疑B收到了请求吗，因此A认为连接未建立。最终A忽略B发的任何数据一直等B的确认，而B发数据无响应超时后会重复发同样的分组，形成了死锁。</p><blockquote><p>SYN泛洪攻击利用三次握手攻击者发送第一次握手，服务器返回ACK即二次握手后，攻击者一直不确认使得该TCP连接处于挂起状态，会损耗服务器大量资源。</p></blockquote></li><li><p>数据传送</p><ul><li>没啥说的，传就完了</li></ul></li><li><p>连接释放（客户/服务器模式）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229100936147.png"  alt="image-20201229100936147"></p><p>可理解为如下图所示</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229101004373.png"  alt="image-20201229101004373"></p></li></ul><p>9.TCP实现可靠传输的机制</p><ul><li>检验：与UDP一样，增加伪首部</li><li>序号：一个字节占一个序号，即使接收的顺序是乱的按序号排序即可</li><li>确认：采用累积确认，如A发送123456，但ACK3(12已收到期望收3)丢失了，此时发送方正准备重发1和2，但又收到了ACK6表明12345接收方都收到了，因此就无需重传12了</li><li>重传：发送方发一个报文段就计一次时，规定时间内没收到确认就重传该报文段（超时重传）<ul><li>TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)<ul><li>记录每个报文发出时间与确认时间之差即往返时延</li><li>求加权平均往返时延RTTs</li><li>每新测量一次往返时延样本，就重新计算RTTs<ul><li>新的RTTs=(1-a)*(旧的RTTs) + a*(新测的RTT)</li></ul></li><li>超时重传时间RTO应略大于加权平均往返时延RTTs</li></ul></li><li>收到了确认如何确定这是先发送的报文段的确认还是后来超时重传的报文段的确认？<ul><li>Karn提出一个算法：计算RTTs时，若重传了就不采用其往返时间样本</li></ul></li></ul></li></ul><blockquote><p>可靠：保证接收方接收的数据和发送方发送的完全一样</p></blockquote><p>10.快重传(冗余确认、冗余ACK)：每收到比期望序号大的报文段时发送一个冗余ACK</p><p>例如</p><ul><li><p>发送方发送1、2、3、4、5</p></li><li><p>接收方收到1，返回确认号2</p></li><li><p>接收方收到3，仍返回确认号2（期望收2却收到了比2大的3，发送第一个冗余ACK）</p></li><li><p>接收方收到4，仍返回确认号2（期望收2却收到了比2大的4，发送第二个冗余ACK）</p></li><li><p>接收方收到5，仍返回确认号2（期望收2却收到了比2大的5，发送第三个冗余ACK）</p></li></ul><p>发送方收到3个对报文1的冗余ACK，则认为2报文段丢失重传2报文段</p><blockquote><p>事不过三，别人都说了三次它想收到的是2，那就赶紧给它传个2吧</p></blockquote><p>11.TCP流量控制：让发送方慢点发，接收不过来了。TCP利用滑动窗口实现</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201229110309849.png"  alt="image-20201229110309849"></p><p>12.TCP拥塞控制：防止过多的数据注入到网络中，全局性问题</p><ul><li><p>发送窗口=Min{接收窗口rwnd，拥塞窗口cwnd}</p></li><li><p>慢开始算法和拥塞避免算法</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201229110708518.png"  alt="image-20201229110708518"></p><ul><li>慢开始算法：cwnd设置为一个最大报文段(通常为1)，一个RTT就加倍一次拥塞窗口<ul><li>最大报文段MSS指的是TCP报文段中的数据字段的最大长度</li></ul></li><li>拥塞避免算法<ul><li>当cwnd&lt;ssthresh(慢开始门限)时，使用慢开始算法</li><li>当cwnd&gt;ssthresh时，停止慢开始算法改用拥塞避免算法</li><li>当cwnd=ssthresh时，既可以使用慢开始算法也可以使用拥塞避免算法</li></ul></li><li>加法增大：经过一个RTT就让cwnd增加一个MSS(最大报文段)</li><li>乘法减小：若出现网络拥塞就把ssthresh设为当前cwnd的一半</li><li>网络拥塞时：采用乘法减小且将cwnd设为一个最大报文段(通常为1)</li></ul></li><li><p>快重传算法和快恢复算法</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229110748864.png"  alt="image-20201229110748864"></p><ul><li>快重传：收到3个重复确认就重传，详见第10个知识点</li><li>快恢复：快重传后不是像慢开始那样把cwnd设为一个最大报文段(通常为1)而是设置为当前cwnd的一半，然后开始拥塞避免算法</li></ul></li></ul><h2 id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2><p>1.假设某应用程序每秒产生一个60B的数据块,每个数据块被封装在一个TCP报文中,然后再封装到一个IP数据报中,那么最后每个数据报所含有的应用数据所占的百分比是（C）(注意:TCP报文和IP数据报的首部没有附加字段)。<br>A.20%B.40%C.60%D.80%</p><p>答：之前说过TCP和IP的首部都是按20B计算(这题题目也指出了没有附加字段)。</p><p>一个TCP的首部是20B，一个IP的首部也是20B，即60/(60+20+20)=60%</p><blockquote><p>注意UDP的首部只有8B</p></blockquote><p>2.假设在没有发生拥塞的情况下,在一条往返时间RTT为10ms的线路上采用慢开始控制策略。如果接收窗口的大小为24KB,最大报文段长度MSS为2KB,那么需要(B)发送方才能发送出一个完全窗口。<br>A. 30msB. 40msC. 50msD. 60ms</p><p>答：慢开始指拥塞窗口设置为一个最大报文段(通常为1)，一个RTT就加倍一次拥塞窗口。</p><p>而本题中指出最大报文段是2KB，所以从2KB开始依次翻倍是4KB，8KB，16KB，然后达到接收窗口的大小24KB，经历了4个RTT即4*10ms=40ms</p><p>3.下列有关面向连接和无连接的数据传输的速度的描述,正确的说法是(D)。<br>A.面向连接的网络数据传输得快B.面向无连接的数据传输得慢<br>C.二者速度一样 D.不可判定</p><p>答：面向连接由于建立了一个虚链路,所以每个数据分组可以省略信源地址,减小了数据冗余,这是速度增加的因素。</p><p>另外,建立虚链路也要花费一定的时间,这是速度降低的因素。因此,很难说二者速度谁快,但是可以肯定的是大量数据传输时面向连接的方式更有利</p><p>4.UDP报文头部不包括(A)。<br>A.目的地址B.源UDP端口C.目的UDP端口D.报文长度</p><p>答：和TCP一样，目的地址放在伪首部里面，但伪首部并不属于UDP和TCP的一部分。</p><blockquote><p>由于它们首部没有目的IP地址，因此它们必须告诉IP层目的IP地址是什么(不用管怎么告诉反正不是放在首部里面)</p></blockquote><p>5.A和B之间建立了TCP连接,A向B发送了一个报文段,其中序号字段seq=300,确认号字段ACK=101,数据部分包含7个字节,那么在B对该报文的确认报文段中(D)<br>A. seq=301, ACK=101B. seq=301, ACK=108<br>C. seq=101, ACK=101D. seq=101, ACK=307</p><p>答：seq=300说明发送报文的第一个字节的序号为300，有7字节数据，所以发的最后一个字节序号是306(不要弄错了)</p><p>ACK表示期待收到的第一个字节的序号，B收到的最后一个字节序号是306期待收到307所以ACK=307</p><p>A发的ACK=101说明A期望收到B发的第一个字节序号是101，所以B发的seq的值即为101</p><p>6.假设TCP的拥塞窗口的慢启动门限值初始为8(单位为报文段),当拥塞窗口上升到12时,网络发生超时,TCP开始慢启动和拥塞避免,那么第12次传输时拥塞窗口大小为（B）<br>A.4B.6C.7D.8</p><p>答：题目没指明最大报文段，则默认最大报文段为1即拥塞窗口初始值为1</p><p>首先是慢启动序列依次是1、2、4、8。</p><p>达到门限值8后开始拥塞控制每次增加一个最大报文段即1，序列依次是9、10、11、12</p><p>达到12后出现超时，门限值设为当前拥塞窗口的一半即6同时将拥塞窗口置为初始值1，接着采用慢开始算法，序列依次是1、2、4。注意此时4再翻倍就是8而此时的门限值为6所以4接下来只能到门限值6</p><p>所以第12次传输拥塞窗口大小为6(注意第一次传输从1开始)</p><p>7.假设某时刻接收端收到有差错的UDP用户数据报,其动作为(A)。<br>A.将其丢弃B.请求重传C.纠错D.忽略差错</p><p>答：由于UDP采用的是无连接不可靠的方式，所以只要出错就会直接丢弃了</p><p>8.TCP中滑动窗口的值设置太大,对主机的影响是(A)<br>A.由于传送的数据过多而使路由器变得拥挤,主机可能丢失分组<br>B.产生过多的ACK<br>C.由于接收的数据多,而使主机的工作速度加快<br>D.由于接收的数据多,而使主机的工作速度变慢</p><p>答：TCP使用滑动窗口机制来进行流量控制,其窗口尺寸的设置很重要。</p><p>如果滑动窗口的值设置太小,会产生过多的ACK(因为窗口大可以累积确认,这样就会有更少的ACK);</p><p>如果设置太大,又会由于传送的数据过多而使路由器变得拥挤,导致主机可能丢失分组。</p><blockquote><p>C和D可理解为现在的主机的处理能力都很强，窗口大点也不会拖慢工作速度</p></blockquote><p>9.下列关于传输层协议中面向连接的描述,（C）是错误的。<br>A.面向连接的服务需要经历3个阶段:连接建立、数据传输以及连接释放<br>B.面向连接的服务可以保证数据到达的顺序是正确的<br>C.面向连接的服务有很高的效率和时间性能<br>D.面向连接的服务提供了一个可靠的数据流</p><p>答：由于面向连接的服务需要建立连接,并且需要保证数据的有序性和正确性,导致了它比无连接的服务开销大,而速度和效率方面也比无连接的服务差一点。</p><blockquote><p>助记：无连接:年轻人就要追求速度和效率  面向连接:年轻人还是太浮躁，出错了怎么办，还是稳点好</p></blockquote><p>10.一个UDP用户数据报的数据字段为8192B。在链路层要使用以太网来传输,那么应该分成(D)IP数据片。<br>A.3个B.4个C.5个D.6个<br>答：数据报总长度=8192+8（UDP首部）=8200字节，以太网传的最大数据负载MTU(最大数据部分)=1500，也就是所能携带的一个IP数据报是1500B</p><p>因为IP首部为20字节，所以数据部分占了1480字节。则：8200/1480=5…800，所以划分为6个IP数据报片，前五个数据字段长度为1480字节，最后一个数据字段长度为800字节。</p><blockquote><p>8200B有效数据都要封装到IP数据报中，而一个IP数据报虽然1500B,但每个IP数据报都会有20B首部，因此实际一个IP数据报所能存放的有效数据只为1480B</p></blockquote><p>第一个偏移量的值为0，长度为1480；</p><p>第二个偏移量的值为1480/8=185，因为片偏移以8个字节为偏移单位，长度为1480；</p><p>第三个偏移量的值为1480*2/8=370，长度为1480；</p><p>第四个偏移量的值为1480*3/8=555，长度为1480；</p><p>第五个偏移量的值为1480*4/8=740，长度为1480；</p><p>第六个偏移量的值为1480*5/8=925，长度为800。</p><blockquote><p>注意这题和IP数据报分片的区别，IP数据报算分片没算首部长度，而这题算了</p><p>可理解为UDP加了首部后才是一个完整的UDP，然后把它分片再在<strong>每个分片前添加IP数据报的首部</strong>，这也就意味着UDP的数据加首部都是有效数据</p></blockquote><p>11.主机甲和主机乙新建一个TCP连接,甲的拥塞控制初始阈值为32KB,甲向乙始终以MSS=1KB大小的段发送数据,并一直有数据发送;乙为该连接分配16KB接收缓存,并对每个数据段进行确认,忽略段传输延迟。若乙收到的数据全部存入缓存,不被取走,则甲从连接建立成功时刻起,未发送超时的情况下,经过4个RTT后,甲的发送窗口是(A)。<br>A. 1KBB. 8KBC. 16KBD. 32KB</p><p>答：第一个RTT发送1KB，第二个RTT发送2KB，依次是发送4KB、8KB。</p><p>4个RTT总共发了1KB+2KB+4KB+8KB=15KB数据，而乙只分配了16KB的接收缓存即接收窗口为16</p><p>现在接收窗口已经存了15只剩下1KB的剩余，而发送窗口=min{拥塞窗口,接收窗口}={16,1}=1</p><p>所以4个RTT后甲的发送窗口为1</p><blockquote><p>注意甲在前几次的发送过程中其实也要判断拥塞窗口和接收窗口的大小来判断当前发送窗口的大小</p></blockquote><h1>应用层</h1><h2 id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2><p>1.应用层的功能</p><ul><li>文件传输、访问、管理</li><li>电子邮件</li><li>虚拟终端</li><li>查询服务和远程作业登录</li></ul><p>2.两种网络应用模型</p><ul><li>客户/服务器(C/S)模型：服务器：提供永久服务的设备，客户：请求计算服务的主机<ul><li>各计算机地位不平等，服务器可对客户进行权限限制</li><li>网络管理由少量服务器承担，管理集中且方便</li><li>可扩展性不佳</li><li>应用：Web、文件传输FTP、远程登录、电子邮件</li></ul></li><li>P2P模型(peer to peer)：每个主机既可以提供服务也可以请求服务<ul><li>计算任务被分配到各结点，聚合各计算机实现强大的服务</li><li>可扩展性好</li><li>网络更加健壮，不存在中心节点失效的问题</li></ul></li></ul><p>3.域名解析系统DNS：将域名解析成IP地址</p><ul><li>最右面的是顶级域名，向左依次是二级域名、三级域名…<ul><li><a href="http://xn--www-eo8e.baidu.com">如www.baidu.com</a></li><li>com是顶级域名，baidu是二级域名，www是三级域名</li></ul></li></ul><p>4.域名服务器：域名系统DNS采用C/S模型，域名解析由若干服务器完成</p><blockquote><p>下面各服务器按树状结构从树根向下一层一层排列</p></blockquote><ul><li>根域名服务器：最高层次的域名服务器，用来管辖顶级域名<ul><li>本地域名服务器对任何一个域名无法解析时首先就会去问根域名服务器</li><li>它不直接解析域名而是告诉本地域名服务器下一步应该找哪一个顶级域名服务器查询</li></ul></li><li>顶级域名服务器：管理所有该顶级域名服务器注册的所有二级域名</li><li>权限域名服务器：负责一个区的域名服务</li><li>本地域名服务器：一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器</li></ul><p>5.域名解析过程</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229190543683.png"  alt="image-20201229190543683"></p><p>一台主机想解析域名，首先主机去本地DNS高速缓存里看有没有</p><p>若缓存里没有就去找本地域名服务器（查询的第一个域名服务器）</p><p>如果本地域名服务器没找到时，本地域名服务器就会跑去问根域名服务器</p><p>如果根域名服务器还没找到时，就分两种情况</p><ul><li>递归查询：根域名服务器到查询域名的授权域名服务器(可理解为一定能找到的服务器)去找，查询结果逐级返回给原主机</li><li>递归与迭代相结合的方法(迭代查询)：根域名服务器把授权域名服务器的IP地址返回给本地域名服务器，由本地域名服务器自己去找授权域名服务器查询</li></ul><blockquote><p>助记：递归转个圈，迭代发三叉</p></blockquote><p>6.文件传输协议FTP：提供不同种类系统之间的文件传输能力</p><ul><li><p>基于C/S模型，使用TCP实现可靠传输</p></li><li><p>FTP服务器主进程负责接收新的请求，若干从属进程负责单个请求</p></li><li><p>控制连接与数据连接</p><ul><li>控制连接：用于传输控制命令和响应，会话期间始终保持<ul><li>FTP服务器监听21号端口，等待客户机连接</li></ul></li><li>数据连接：用于实际的文件内容传输，数据传送完毕就关闭连接<ul><li>数据连接通常使用20端口（被动方式下不一定是20由客户和服务器协商一个端口）</li></ul></li></ul></li></ul><p>7.电子邮件：又称E-mail</p><ul><li><p>用户代理：用户与电子邮件系统(如Foxmail)的接口，用于撰写、显示和处理</p></li><li><p>邮件服务器：因特网上所有的ISP(互联网服务提供商)都有邮件服务器，用于发送和接收邮件，还要向发信人报告邮件传送状态</p></li><li><p>电子邮件使用的协议：如简单邮件传送协议SMTP、邮局协议版本3(POP3)等</p></li><li><p>格式：由信封和内容组成</p></li><li><p>发送和接收过程如下</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229192342219.png"  alt="image-20201229192342219"></p></li></ul><p>8.电子邮件使用的协议</p><ul><li><p>SMTP(<strong>S</strong>imple <strong>M</strong>ail <strong>T</strong>ransfer <strong>P</strong>rotocol)：使用25号端口，C/S模型，TCP。规定了14条命令和21种应答信息</p><ul><li>通信分为三个阶段：连接建立(发方SMTP客户和收方SMTP服务器)、邮件传送、连接释放</li></ul></li><li><p>MIME：由于SMTP只能传送7位ASCII码，通过MIME可以发音频、视频等各种形式文件</p><ul><li>quoted-printable编码：用一个等号后面加两个数字来表示一个非ASCII码，适合只有少量非ASCII码</li><li>base64编码：适用于任意的二进制文件</li></ul></li><li><p>POP3(<strong>P</strong>ost <strong>O</strong>ffice <strong>P</strong>rotocol <strong>3</strong>)：用于邮件读取</p></li><li><p>网际报文存取协议IMAP：用户可用不同的计算机随时阅读处理邮件且可只读其中一部分</p></li><li><p>基于万维网的电子邮件：只要有网都可发邮件</p><ul><li>浏览器到邮件服务器使用HTTP，邮件服务器之间使用SMTP</li></ul></li></ul><blockquote><p>总结：SMTP用于发邮件，POP3和IMAP用于收邮件，MIME对SMTP进行了拓展</p></blockquote><p>9.万维网WWW：是一个大规模的、联机式的信息储藏所，是无数网站站点和网页的集合</p><ul><li>以C/S方式工作，浏览器是客户端，存有万维网文档的主机运行服务器程序</li><li>使用URL(统一资源定位符)来标志WWW上的各种文档<ul><li>格式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 如http://baidu.com</li></ul></li><li>用户点击超链接获取资源，这些资源使用HTTP传给用户</li><li>使用超文本标记语言HTML，可以很方便地从一个界面跳转到另一个界面</li><li><strong>不是协议</strong>，是应用层提供的一种最为重要和普及的服务</li></ul><p>10.超文本传输协议HTTP：定义了浏览器怎样向服务器请求万维网文档和服务器怎样把文档传给浏览器</p><ul><li><p>使用TCP可靠传输，80端口，但HTTP协议本身是无连接的</p></li><li><p>非持久连接：每一个网页元素对象的传输都需要单独建立一个TCP连接（三次握手）</p><ul><li>Connection:Close</li></ul></li><li><p>持久连接：服务器发送响应后仍然保持这条连接</p><ul><li>流水线：客户每遇到一个对象引用就立即发出一个请求</li><li>非流水线：客户只能在接收到前一个请求的响应后才能发新的请求</li><li>Connection:Keep-Alive</li></ul></li><li><p>报文结构</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229200630366.png"  alt="image-20201229200630366"></p></li></ul><p>11.远程终端协议TELNET：又称为终端仿真协议，定义了数据和命令怎么通过互联网</p><ul><li>诞生原因：如中断程序有的系统使用^C而有的使用ESC，为了适应这种差异即格式统一</li><li>客户端格式转为NVT(网络虚拟终端)格式后发给服务器，到了服务器NVT再转为服务器使用的格式</li></ul><p>11.应用层与传输层协议对应关系</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20201229195947832.png"  alt="image-20201229195947832"></p><h2 id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2><p>1.域名与(D)是一一对应的。<br>A.IP地址B.MAC地址C.主机名称D.以上都不是</p><p>答：域名和IP不是一一对应关系，一个IP可能有多个域名而多个域名也可能都指向同一个IP</p><p>主机名称和域名根本没关系</p><p>一个主机如果有两个网卡，实际上就有两个MAC地址，与域名也不是一一对应</p><blockquote><p>结合生活中域名的配置</p></blockquote><p>2.匿名FTP访问通常使用©作为用户名。<br>A.guestB.E-mai地址C.anonymousD.主机id</p><p>答：anonymous中文为匿名的意思，记住即可</p><p>3.在TCP/IP协议族中,应用层的各种服务是建立在传输层提供服务的基础上的。下列协议组中(B)需要使用传输层的TCP建立连接。<br>A.DNS、DHCP、FTPB.TELNET、SMTP、HTTP<br>C.RIP、FTP、TELNET  D.SMTP、FTP、TFTP</p><p>答：通常在传送对实时性要求较高,传送数据量较小时选择用UDP,可以节省开销,减小时延。</p><p>在传送数据量较大,可靠性要求较高时,采用TCP较合适。</p><blockquote><p>注意DNS多数情况下使用UDP,但有时也使用TCP。</p></blockquote><p>4.现给出一串二进制的文件:11001100 10000001 00111000,如果对该二进制文件进行base64编码,则最后所传送的ASCII码是(B)<br>A.8A 49 45 34B.7A 49 45 34</p><p>C.7A 49 34 45D.7A 34 49 45</p><p>答：首先将24位二进制11001100 1000001 0011000分成4等份，即110011 001000 000100 11100</p><blockquote><p>助记：3个8分为4个6（实际传输是3个8分为4个6，然后6在前面补两个0即4个8）</p></blockquote><p>根据转换原则:用A表示0，用B表示1。先排26个大写字母(0-25)，再排26个小写字母(26-51)，再排10个数字(52-61)，最后用&quot;+“表示62，用”/&quot;表示63。</p><p>如果最后一组不足24位就要填充成24位</p><ul><li>最后一组只有一个字节时，第二个六后面全补0填充到六位，最终编码结果加两个&quot;=&quot;</li><li>最后一组只有两个字节时，第三个六后面全补0填充到六位，最终编码结果加一个&quot;=&quot;</li></ul><p>110011为51,对应小写z;00100为8,对应大写I;000100为4,对应大写E;11100为56,对应4。(注意大写字母从0开始)</p><p>而z、I、E、4对应的ASCII码分别是0111 1010、0100 1001、0100 0101、0011 0100。将这4组32位二进制数转换成十六进制数为7A、49、45、34。</p><blockquote><p>ascii码：0-10(<strong>48</strong>-57)，a-z(<strong>97</strong>-122)，A-Z(<strong>65</strong>-90) 记住每个的起始</p></blockquote><p>5.FTP客户机发起对FTP服务器的连接,此时建立的第一阶段为(D)。<br>A.控制传输连接B.数据连接<br>C.会话连接   D.控制连接</p><p>答：一个完整的FTP的工作过程需要历经连接建立、数据传输、释放连接3个阶段。</p><p>其中,连接建立又分为控制连接建立和数据连接建立两个阶段。因此,FTP客户端<br>与FTP服务器连接建立的第一个阶段是控制连接的建立,主要用于传输FTP的各种命令。</p><p>6.下面关于客户服务器模型的描述,（D）存在错误。<br>A.客户端必须知道服务器的地址,而服务器则不需要知道客户端的地址<br>B.客户端主要实现如何显示信息与收集用户的输入,而服务器主要实现数据的处理<br>C.浏览器的现实内容来自服务器<br>D.客户端是请求方,即使连接建立后,服务器也不能主动发送数据</p><p>答：客户端是连接的请求方,在连接未建立之前服务器在某一个端口上监听。这时客户端必须要知道服务器的地址才能发出请求。显然服务器不需要知道客户端的地址。<br>一旦连接建立后,服务器也能主动发送数据给客户端,用于些消息的通知,如一些错误的通知。</p><p>7.下面关于POP3,（B）是错误的。<br>A.由客户端选择接收后是否将邮件保存在服务器上<br>B.登录到服务器后,发送的密码是加密的<br>C.协议是基于ASCII码的,不能发送二进制数据<br>D.一个账号在服务器上只能有一个邮件接收目录</p><p>答：POP3是使用明文来传输密码的,并不对密码进行加密,所以B选项是错误的。</p><p>POP3是基于ASCII码的,如果要传输非ASCII码的数据,需要使用MINE协议来将数据转换成ASII码的形式。</p><p>8.使用浏览器访问某大学Web网站主页时,不可能使用到的协议是(D)<br>A. PPPB. ARPC. UDPD. SMTP</p><p>答：SMTP是用于发送邮件的，访问网站肯定用不到</p><p>当接入网络时可能会用到PPP协议,A可能用到;</p><p>而当计算机不知道某主机的MAC地址时,用IP地址查询相应的MAC地址时会用到ARP协议,B可能用到;</p><p>而当访问web网站时,若DNS缓冲没有存储相应域名的IP地址,用域名查询相应的IP地址时要使用DNS协议,而DNS是可以基于UDP协议的,所以C可能用到;</p><p>9.假设所有域名服务器均采用迭代查询方式进行域名解析。当一主机访问域名为www.abc.xyz.com的网站时,在完成该域名解析过程中,可能发出DNS查询的最少和最多次数分别是©。<br>A.0,3B.1,3C.0,4D.1,4</p><p>答：最少情况下:当本机DNS高速缓存中存有该域名的DNS信息时,则不需要查询任何域名服务器,这样最少发出0次DNS查询。</p><p>最多情况下:因为均采用迭代查询方式,在最坏的情况下,需要依次迭代地向本地域名服务器、根域名服务器(.com)、顶级域名服务器(<a href="http://xyz.com">xyz.com</a>)、权限域名服务器(abc·<a href="http://xyz.com">xyz.com</a>)发出DNS查询请求,因此最多发出4次DNS查询。</p><blockquote><p>权限域名服务器管理所有的xxx.abc.xyz.com所以它一定知道www.abc.xyz.com的ip地址</p></blockquote><p>10.下列关于FTP协议的叙述中,错误的是©<br>A.数据连接在每次数据传输完毕后就关闭<br>B.控制连接在整个会话期间保持打开状态<br>C.服务器与客户端的TCP20端口建立数据连接<br>D.客户端与服务器的TCP21端口建立控制连接</p><p>答：FTP协议使用控制连接和数据连接,控制连接存在于整个FTP会话过程中,数据连接在每次文件传输时才建立,传输结束就关闭,A对,B对。</p><p>默认情况下FTP协议使用TCP20端口进行数据连接,TCP21端口进行控制连接。</p><p>但是是否使用TCP20端口建立数据连接与传输模式有关,主动方式使用TCP20端口,被动方式由服务器和客户端自行协商决定,C错,D对。故选C。</p><blockquote><p>只需记住FTP用于数据传输的不一定是20端口即可</p></blockquote><p>11.如果本地域名服务无缓存,当采用递归方法解析另一网络某主机域名时,用户主机和本地域名服务器发送的域名请求条数分别为（A）</p><p>A.1条，1条B.1条，多条C.多条，1条D.多条，多条</p><p>答：递归方式下转个圈的查询，但是主机和本地域名起始都只发了一次请求(序号1和序号2)，如下图</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201229190543683.png"  alt="image-20201229190543683"></p><p>12.设TELNET的客户端有n种格式,服务器端有m种格式</p><p>若不使用NVT,客户端需要装 [m] 种格式转换程序,服务器端需要装 [n] 种格式转换程序<br>若使用NVT,客户端需要装 [1] 种格式转换程序,服务器端需要装 [1] 种格式转换程序</p><p>答：不使用NVT的情况下，对于客户机它要能解析所有服务器发来的格式即m，同理服务器也要有n种格式转换</p><p>而使用了NVT后，只需安装1种和NVT互相转换的转换程序即可。发送方将数据转成NVT传输给接收方，接收方收到后再把NVT转成自己能识别的格式即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;作者：夏日&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文结合天勤考研的高分笔记和王道考研的PPT进行总结</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>计算机病毒与恶意代码期末总结</title>
    <link href="https://zss192.github.io/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E4%B8%8E%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    <id>https://zss192.github.io/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E4%B8%8E%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</id>
    <published>2021-07-04T07:54:00.000Z</published>
    <updated>2021-07-04T07:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>所用教材：刘功申等人编著的第四版</p><p>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><p>说明：博客为根据老师所画重点有针对性的总结，供个人复习使用，仅供参考</p><h1>第一章 恶意代码概述</h1><h3 id="1-恶意代码的共同特征（P3选）"><a class="header-anchor" href="#1-恶意代码的共同特征（P3选）">¶</a>1.恶意代码的共同特征（P3选）</h3><ul><li>目的性：基本特征，是判别程序是否为恶意代码的最重要的特征，也是法律上判断恶意代码的标准。</li><li>传播性：恶意代码体现其生命力的重要手段。</li><li>破坏性：恶意代码的表现手段。</li></ul><h3 id="2-恶意代码种类（P9选）"><a class="header-anchor" href="#2-恶意代码种类（P9选）">¶</a>2.恶意代码种类（P9选）</h3><ul><li>普通计算机病毒</li><li>蠕虫</li><li>特洛伊木马</li><li>RootKit工具</li><li>流氓软件</li><li>间谍软件</li><li>恶意广告</li><li>逻辑炸弹</li><li>僵尸网络</li><li>网络钓鱼</li><li>恶意脚本</li><li>垃圾短信</li><li>勒索软件</li><li>移动终端恶意代码</li></ul><h3 id="3-恶意代码发作后的现象（P18选哪个不是）"><a class="header-anchor" href="#3-恶意代码发作后的现象（P18选哪个不是）">¶</a>3.恶意代码发作后的现象（P18选哪个不是）</h3><ul><li>无法启动系统</li><li>系统文件丢失或被破坏</li><li>部分BIOS程序混乱</li><li>部分文档丢失或被破坏</li><li>部分文档自动加密</li><li>目录结构发生混乱</li><li>网络无法提供正常的服务</li><li>浏览器自动访问非法网站</li></ul><h3 id="4-与病毒现象类似的故障（P19选）"><a class="header-anchor" href="#4-与病毒现象类似的故障（P19选）">¶</a>4.与病毒现象类似的故障（P19选）</h3><ul><li>硬件故障<ul><li>系统的硬件配置</li><li>电源电压不稳定</li><li>接触不良</li><li>驱动器故障</li><li>CMOS的问题</li></ul></li><li>软件故障<ul><li>软件程序已被破坏</li><li>软件与操作系统不兼容</li><li>引导过程故障</li><li>使用不同的编辑软件导致错误</li></ul></li></ul><blockquote><p>推测与第3点结合出题，给出4个选项，其中混着一个硬件故障或软件故障，让选择哪个不是恶意代码的发作现象</p></blockquote><h1>第二章 恶意代码模型及机制</h1><h3 id="1-计算机病毒的组成（P48选）"><a class="header-anchor" href="#1-计算机病毒的组成（P48选）">¶</a>1.计算机病毒的组成（P48选）</h3><ul><li>引导模块<ul><li>引导过程：驻留在内存中、窃取系统控制权、恢复系统功能</li></ul></li><li>感染模块<ul><li>传染过程<ul><li>被动传染：随着复制或网络传输工作的进行而进行</li><li>主动传染：在系统运行时，进入系统的内存储器，常驻内存监视系统的运行，用多种方式传染</li></ul></li><li>传染方式<ul><li>立即传染：病毒在被执行的瞬间，抢在宿主程序开始执行前感染磁盘上的其他程序，然后再执行宿主程序</li><li>驻留内存伺机感染：在执行程序或浏览网页时传染磁盘上的程序，在宿主程序运行结束后仍可活动，直至关闭计算机</li></ul></li></ul></li><li>破坏模块<ul><li>不一定都是删除磁盘文件，也有可能是显示一串无用的信息或干扰用户工作</li><li>破坏行为越来越隐秘，甚至窃取信息后会自动销毁</li></ul></li><li>触发模块<ul><li>病毒常用的触发条件：日期触发、时间触发、键盘触发、感染触发、启动触发、访问磁盘次数触发、CPU型号/主板型号触发</li></ul></li></ul><h3 id="2-世界上第一台计算机ENIAC是（随机访问计算机）模型（P51）"><a class="header-anchor" href="#2-世界上第一台计算机ENIAC是（随机访问计算机）模型（P51）">¶</a>2.世界上第一台计算机ENIAC是（随机访问计算机）模型（P51）</h3><h1>第三章 传统计算机病毒</h1><h3 id="1-PE文件结构及其运行原理（P66）"><a class="header-anchor" href="#1-PE文件结构及其运行原理（P66）">¶</a>1.PE文件结构及其运行原理（P66）</h3><p>PE(Portable Executable,可移植的执行体)是Win32环境自身所带的可执行文件格式。它的一些特性继承自UNIX的COFF(Common Object File Format)文件格式。</p><p>可移植的执行体意味着此文件格式是跨Win32平台的,即使 Windows运行在非 Intel的CPU上，任何Win32平台的PE装载器都能识别和使用该文件格式。</p><p>当然，移植到不同的CPU上PE执行体必然得有一些改变。除VxD和16位的DLL外，所有Win32执行文件都使用PE文件格式。因此,研究PE文件格式是我们洞悉 Windows结构的良机。</p><h3 id="2-病毒感染其他文件的步骤（P71简答）"><a class="header-anchor" href="#2-病毒感染其他文件的步骤（P71简答）">¶</a>2.病毒感染其他文件的步骤（P71简答）</h3><p>（1）判断目标文件开始的两个字节是否为MZ</p><p>（2）判断PE文件标记&quot;PE&quot;</p><p>（3）判断感染标记，如果已被感染过则跳出继续执行宿主程序，否则继续</p><p>（4）获得数据目录的个数（每个数据目录信息占8个字节）</p><p>（5）得到节表起始位置(数据目录的偏移地址+数据目录占用的字节数=节表起始位置)</p><p>（6）得到节表的末尾偏移（紧接其后用于写入一个新的病毒节信息，节表起始位置+节的个数*每个节表占用的字节数28H=节表的末尾偏移）</p><p>（7）开始写入节表</p><p>（8）在新添加的节中写入病毒代码</p><p>（9）将当前文件位置设为文件末尾</p><blockquote><p>必须背会，括号里的记不住可不写</p></blockquote><h3 id="3-Ring3与Ring0（P72）"><a class="header-anchor" href="#3-Ring3与Ring0（P72）">¶</a>3.Ring3与Ring0（P72）</h3><ul><li><p>Windows操作系统运行在保护模式，保护模式将指令执行分为4个特权级：Ring0,Ring1,Ring2,Ring3</p></li><li><p>Ring0级别最高，可以执行特权指令（OS使用）；Ring3级别最低（应用程序使用)</p></li></ul><h3 id="4-什么是宏病毒（P73）"><a class="header-anchor" href="#4-什么是宏病毒（P73）">¶</a>4.什么是宏病毒（P73）</h3><p>宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。</p><blockquote><p>宏：一些命令组织在一起，作为一个独立单元完成一个特定任务</p><p>经典宏病毒：美丽莎（Melissa）、台湾NO.1B、O97M.Tristate.C病毒</p></blockquote><h1>第五章 特洛伊木马</h1><h3 id="1-什么是特洛伊木马（P122）"><a class="header-anchor" href="#1-什么是特洛伊木马（P122）">¶</a>1.什么是特洛伊木马（P122）</h3><p>特洛伊木马(Trojan Horse)是一种与远程计算机之间建立起连接，使远程计算机能够通过网络控制用户计算机系统并且可能造成用户的信息损失、系统损坏甚至瘫痪的程序。</p><h3 id="2-一个完整的木马系统的组成（P122简答）"><a class="header-anchor" href="#2-一个完整的木马系统的组成（P122简答）">¶</a>2.一个完整的木马系统的组成（P122简答）</h3><ul><li>硬件部分：建立木马连接所必需的硬件实体。包括控制端、服务端、Internet</li><li>软件部分：实现远程控制所必需的软件程序。包括控制端程序、木马程序、木马配置程序</li><li>具体连接部分：通过Internet在服务端和控制端之间建立一条木马通道所必需的元素。包括控制端IP和服务端IP、控制端端口和木马端口</li></ul><h3 id="3-木马程序的基本特征（P123）"><a class="header-anchor" href="#3-木马程序的基本特征（P123）">¶</a>3.木马程序的基本特征（P123）</h3><p>欺骗性、隐蔽性(木马和远程控制软件的区别)、自动运行性、自动恢复性、功能的特殊性</p><h3 id="4-什么是网站挂马技术（P139）"><a class="header-anchor" href="#4-什么是网站挂马技术（P139）">¶</a>4.什么是网站挂马技术（P139）</h3><p>网页挂马就是攻击者通过在正常的页面中(通常是网站的主页)插入一段恶意代码。浏览者在打开该页面的时候，这段代码被执行，然后把某木马的服务器端程序或种子下载到浏览者本地并运行，进而控制浏览者的主机。</p><blockquote><p>常见的有框架挂马、js挂马、图片伪装挂马、网络钓鱼挂马、伪装挂马</p></blockquote><h3 id="5-什么是隐藏技术（P143）"><a class="header-anchor" href="#5-什么是隐藏技术（P143）">¶</a>5.什么是隐藏技术（P143）</h3><p>木马为了生存，使用许多技术隐藏自己的行为(进程、连接和端口)</p><blockquote><p>主要的隐藏技术有：反弹式木马技术、用ICMP方法隐藏连接、隐藏端口、Windows NT系统下木马进程的隐藏、远程线程技术</p></blockquote><h1>第七章 蠕虫</h1><h3 id="1-蠕虫的分类-P187"><a class="header-anchor" href="#1-蠕虫的分类-P187">¶</a>1.蠕虫的分类(P187)</h3><ul><li>一种是面向企业用户和局域网的，其利用系统漏洞，主动进行攻击，可使整个互联网瘫痪。<ul><li>爆发具有一定的突然性，查杀这种病毒并不是很难</li><li>以红色代码、尼姆达以及SQL蠕虫王为代表</li></ul></li><li>另外一种是针对个人用户的，通过网络(主要是电子邮件、恶意网页形式)迅速传播的蠕虫病毒<ul><li>比较复杂多样，常利用社会工程学欺诈和诱骗用户，造成损失非常大且很难根除</li><li>以爱虫病毒、求职信病毒为代表</li></ul></li></ul><blockquote><p>蠕虫：一种能够利用系统漏洞通过网络进行自我传播的恶意程序</p></blockquote><h3 id="2-什么是RPC漏洞（P192）"><a class="header-anchor" href="#2-什么是RPC漏洞（P192）">¶</a>2.什么是RPC漏洞（P192）</h3><p>远程过程调用RPC(Remote Procedure Call)是 Windows操作系统使用的一个协议，提供了一种进程间通信机制，通过这一机制，在一台计算机上运行的程序可以顺畅地执行某个远程系统上的代码。RPC漏洞则是利用RPC的漏洞。</p><blockquote><p>RPC中处理通过TCP/IP的消息交换的部分存在一个漏洞(错误地处理格式不正确的消息造成)</p><p>RPC漏洞影响分布式组件对象模型(DCOM)与RPC间的一个接口，此接口侦听135端口</p><p>Samba在处理用户数据输入时存在输入验证漏洞，攻击者可执行任意命令</p></blockquote><h1>第八章 勒索型恶意代码</h1><h3 id="1-勒索型恶意代码加密算法（P212）"><a class="header-anchor" href="#1-勒索型恶意代码加密算法（P212）">¶</a>1.勒索型恶意代码加密算法（P212）</h3><p>对称加密算法：AES(使用最多)，非对称加密算法：RSA</p><p>摘要：用Hash函数(也称散列函数或哈希函数)将任意长度的数据变成固定长度的数据</p><h1>第九章 其他恶意代码</h1><h3 id="1-流氓软件的定义（P227简答）"><a class="header-anchor" href="#1-流氓软件的定义（P227简答）">¶</a>1.流氓软件的定义（P227简答）</h3><p>第一个定义：流氓软件是指具有一定的实用价值但具备计算机恶意代码和黑客的部分行为特征的软件。它处在合法软件和恶意代码之间的灰色地带，使用户无法卸载，并强行弹出广告和窃取用户的私人信息。</p><p>第二个定义：流氓软件是介于恶意代码和正规软件之间，同时具备正常功能(下载、媒体播放等)和恶意行为(弹广告、开后门)的软件，给用户带来实质危害。</p><h3 id="2-Rootkit的定义（P243）"><a class="header-anchor" href="#2-Rootkit的定义（P243）">¶</a>2.Rootkit的定义（P243）</h3><p>Rootkit是攻击者用来隐藏自己的踪迹和保留root访问权限的工具。Rootkit一般都和木马、后门等其他恶意程序结合使用。</p><h3 id="3-APT的攻击过程（P246简答）"><a class="header-anchor" href="#3-APT的攻击过程（P246简答）">¶</a>3.APT的攻击过程（P246简答）</h3><ul><li>第一阶段：定向信息收集：有针对性的搜集系统和员工信息</li><li>第二阶段：单点攻击突破：采用一切可以采用的手段攻击员工的个人计算机，设法实现单点突破</li><li>第三阶段：构建通道：建立长期的联系通道，通过该通道发送攻击指令、传输数据等</li><li>第四阶段：横向渗透：以员工个人计算机为跳板，在系统内部横向渗透，以攻陷更多的个人计算机和服务器</li><li>第五阶段：目标行动：获得有价值的数据并偷运到由攻击者控制的外部</li></ul><blockquote><p>高级持续性威胁(APT)是利用先进的攻击手段对特定目标进行长期持续型网络攻击的攻击形式</p></blockquote><h3 id="4-APT的特征（P248简答）"><a class="header-anchor" href="#4-APT的特征（P248简答）">¶</a>4.APT的特征（P248简答）</h3><ul><li>高级性：APT攻击的方式相对于其他攻击形式更为高级，体现在3个方面<ul><li>高级的收集手段</li><li>高级的攻击手法</li><li>威胁高级的数据</li></ul></li><li>持续性：持续性是APT攻击的最大威胁，可以包括以下几点<ul><li>持续潜伏</li><li>持续攻击</li><li>持续欺骗</li><li>持续控制</li></ul></li></ul><h1>第十章 恶意代码防范技术</h1><h3 id="1-恶意代码防范思路（P256）"><a class="header-anchor" href="#1-恶意代码防范思路（P256）">¶</a>1.恶意代码防范思路（P256）</h3><p>（1）检测：利用静态检测、动态检测等技术，通过手工检测或自动检测等方法来识别恶意代码<br>（2）清除：根据恶意代码的类型，选择不同的方法来清除恶意代码；<br>（3）预防：通过个人防火墙和系统加固等技术来防止恶意代码对系统进行传染和破坏（被动）<br>（4）免疫：通过计算机系统本身的技术增加自己的防范能力，是一种主动的预防技术<br>（5）数据备份及恢复：及时对数据进行备份、遇到故障时保证数据可恢复<br>（6）防范策略：以单位实际情况为主要依据形成一套好的管理制度和策略</p><h1>第十一章 常用杀毒软件及其解决方案</h1><h3 id="1-杀毒软件必备功能（P287）"><a class="header-anchor" href="#1-杀毒软件必备功能（P287）">¶</a>1.杀毒软件必备功能（P287）</h3><p>查杀能力、防范新恶意代码的能力、备份和恢复能力、实时监控能力、升级能力、智能安装能、简单易用、资源占用情况、兼容性、价格、厂商的实力</p><h1>第十二章 恶意代码防治策略</h1><h3 id="1-恶意代码防止策略的基本准则（P302）"><a class="header-anchor" href="#1-恶意代码防止策略的基本准则（P302）">¶</a>1.恶意代码防止策略的基本准则（P302）</h3><ul><li>拒绝访问能力：来历不明的软件不得进入计算机系统</li><li>检测能力：系统应设置检测恶意代码的机制来阻止外来恶意代码的侵犯</li><li>控制传播的能力：应阻止恶意代码在系统中任意传播</li><li>清除能力：如果恶意代码突破了系统的防护，即使传播受到了控制，也要有相应的措施将它清除</li><li>恢复能力：系统应提供一种高效的方法来恢复被破坏的数据，将损失减到最少</li><li>替代操作：系统未恢复前用替代系统工作，等问题解决后再换回来</li></ul><h3 id="2-恶意代码的防治策略（P303简答）"><a class="header-anchor" href="#2-恶意代码的防治策略（P303简答）">¶</a>2.恶意代码的防治策略（P303简答）</h3><ul><li>国家层面<ul><li>完善相关法律法规及其贯彻落实工作</li><li>在各主干网络建立恶意代码预警系统</li><li>建立多层次恶意代码应急体系</li><li>建立动态的系统风险评估措施</li><li>建立恶意代码事故分析制度</li><li>制定完备的备份和恢复计划</li><li>提高国内运营商自身的安全性</li><li>加强信息安全培训</li><li>加强技术防范措施</li></ul></li><li>单机用户<ul><li>一般措施<ul><li>安装操作系统后第一时间进行系统升级</li><li>使用高强度的口令并定定期更换</li><li>及时安装系统补丁</li><li>重要数据应当留有备份</li><li>选择经权威机构认证的安全防范软件</li><li>使用个人防火墙保障系统的安全性</li><li>不需要使用网络时，就不要接入互联网</li><li>设置杀毒软件的邮件自动杀毒功能</li><li>正确配置恶意代码防治产品</li><li>充分利用系统提供的安全机制，正确配置系统</li><li>定期检查敏感文件</li></ul></li><li>个人用户上网基本策略<ul><li>关闭浏览器cookie选项</li><li>使用个人防火墙</li><li>浏览电子商务网站尽可能使用安全的连接方式</li><li>不透漏关键信息</li><li>避免使用过于简单的密码</li><li>不要随意打开电子邮件附件</li><li>定期扫描计算机并查找安全漏洞</li><li>使用软件的稳定版本并及时安装补丁</li><li>尽量关闭不需要的组件和服务程序</li><li>尽量使用代理服务器上网</li></ul></li></ul></li></ul><blockquote><p>应该不用记完，每个大点记住几个小点就行，尽量都记住</p></blockquote><h1>其它知识点</h1><blockquote><p>详细内容看实验文档</p></blockquote><h3 id="1-什么是符号文件"><a class="header-anchor" href="#1-什么是符号文件">¶</a>1.什么是符号文件</h3><p>符号文件（Symbol Files）是一个数据信息文件。</p><p>它包含了应用程序二进制文件（比如：EXE、DLL等）调试信息，专门用来作调试之用，最终生成的可执行文件在运行时并不需要这个符号文件，但你的程序中所有的变量信息都记录在这个文件中。所以调试应用程序时，这个文件是非常重要的。</p><p>符号文件可能包含：全局变量、局部变量、函数名称和其入口点的地址、帧指针省略 (FPO) 记录、源行号，其中每个项分别称为一个符号。</p><p>在 Windows 系统中，符号文件以 .pdb 为扩展名</p><p>windbg调试器键入ctrl+s打开符号表路径设置</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628105246.png"  alt=""></p><blockquote><p>windbg命令行下载符号文件（.sympath设置加载路径，也可按上图那样设置路径）</p><p>.sympath srv*c:\MyServerSymbols*<a href="https://msdl.microsoft.com/download/symbols">https://msdl.microsoft.com/download/symbols</a></p><p>.reload /f</p></blockquote><h3 id="2-用户模式调试和内核模式调试的区别"><a class="header-anchor" href="#2-用户模式调试和内核模式调试的区别">¶</a>2.用户模式调试和内核模式调试的区别</h3><p>用户模式调试是在Ring3级别调试，而内核模式调试在Ring0级别调试</p><p>如WinDbg是由Microsoft开发的内核模式调试器，可用于调试运行它的操作系统本身。这意味着它可以调试内核代码，即运行在Ring 0中的特权代码。</p><p>而OllyDbg是一个用户模式调试器，它只能调试用户模式的可执行文件，例如Exe。</p><p>内核模式调试环境通常有两台计算机：主计算机和目标计算机，二者通过以太网电缆连接，也可以用命名管道连接(如VMware)</p><h3 id="3-windbg串口-串行端口-问题"><a class="header-anchor" href="#3-windbg串口-串行端口-问题">¶</a>3.windbg串口(串行端口)问题</h3><p>windbg内核调试使用虚拟机调试时需要设置串口</p><p>管道名称：\\.\pipe\com1（注意打印机会占用端口1，若使用端口1需先删除打印机设备）</p><p>主计算机：选择从客户端到一个虚拟机器</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628103326.png"  alt=""></p><p>目标计算机：选择从服务器到一个虚拟机器</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628103450.png"  alt=""></p><p>调试机中win+R键入c:\boot.ini打开系统启动配置.然后添加一行配置，如下</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628105621.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628105749.png"  alt=""></p><p>右键windbg快捷方式，选择属性-&gt;快捷方式-&gt;目标，在后面添加-b -k com:port=1,baud=115200</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628105006.jpg"  alt=""></p><h3 id="4-EMACS常用命令（选）"><a class="header-anchor" href="#4-EMACS常用命令（选）">¶</a>4.EMACS常用命令（选）</h3><table><thead><tr><th>操作</th><th>按键</th></tr></thead><tbody><tr><td>打开文件</td><td>C-x C-f</td></tr><tr><td>保存文件</td><td>C-x C-s</td></tr><tr><td>保存所有文件</td><td>C-x s</td></tr><tr><td>另存为文件</td><td>C-x C-w</td></tr><tr><td>退出Emacs</td><td>C-x C-c</td></tr><tr><td>打开SHELL</td><td>M-x shell</td></tr><tr><td>执行SHELL命令</td><td>M-!</td></tr><tr><td>粘贴</td><td>C-y</td></tr><tr><td>切换到 EVIL 模式</td><td>M-x evil-mode</td></tr></tbody></table><p>若安装插件，先配置.emacs文件（windows是init.el文件）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628110903.png"  alt=""></p><p>运行 M-x package-refresh-contents 刷新插件服务器内容</p><p>运行 M-x package-install RET 后输入 M-x evil-org 安装此插件</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628111019.png"  alt=""></p><h3 id="5-windbg常用命令（选）"><a class="header-anchor" href="#5-windbg常用命令（选）">¶</a>5.windbg常用命令（选）</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">解释</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">bp</td><td style="text-align:center">某个地址下断点</td><td style="text-align:center"><code>bp @exentry</code>、<code>bp 0x88888888</code>、<code>bp MyApp!Func</code></td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">继续执行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">bu</td><td style="text-align:center">针对某个符号下断点</td><td style="text-align:center"><code>bu test1!main</code> 在test1程序的main函数下断点</td></tr><tr><td style="text-align:center">bm</td><td style="text-align:center">支持正则表达式断点</td><td style="text-align:center"><code>bm *!draw*</code></td></tr><tr><td style="text-align:center">bl</td><td style="text-align:center">列出所有断点</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">bc</td><td style="text-align:center">清除断点</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ba</td><td style="text-align:center">指定内存被访问触发断点</td><td style="text-align:center">ba Access Size [地址]：<code>ba w4 0x0483DFE</code></td></tr><tr><td style="text-align:center">!address</td><td style="text-align:center">目标进程内存使用</td><td style="text-align:center"><code>!address Address</code></td></tr><tr><td style="text-align:center">!address</td><td style="text-align:center">将堆栈地址分开</td><td style="text-align:center"><code>!address -summary</code></td></tr><tr><td style="text-align:center">!dh</td><td style="text-align:center">扩展显示指定映像的头部</td><td style="text-align:center"><code>!dh -h</code>、<code>!dh -f notepad</code>、<code>!dh ntdll</code></td></tr><tr><td style="text-align:center">!lmi</td><td style="text-align:center">某个模块的详细信息</td><td style="text-align:center"><code>!lmi ntdll</code></td></tr><tr><td style="text-align:center">lm</td><td style="text-align:center">模块及模块的符号加载</td><td style="text-align:center"><code>lm</code>、<code>lm vm test.dll</code></td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">检查符号</td><td style="text-align:center"><code>x kernel32!Virtual*</code></td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">查看线程调用栈</td><td style="text-align:center"><code>k</code></td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">显示每个函数的前三个参数</td><td style="text-align:center"><code>kb</code></td></tr><tr><td style="text-align:center">db</td><td style="text-align:center">显示存储在某地址中的数据</td><td style="text-align:center"><code>db notepad</code></td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">同上，双字节显示</td><td style="text-align:center"><code>db notepad L100</code></td></tr><tr><td style="text-align:center">dt</td><td style="text-align:center">显示结构信息</td><td style="text-align:center"><code>dt _PEB</code></td></tr><tr><td style="text-align:center">dt</td><td style="text-align:center">PE 的结构</td><td style="text-align:center"><code>dt -r ntdll!_IMAGE_NT_HEADERS 00fd00f8</code></td></tr><tr><td style="text-align:center">dx</td><td style="text-align:center">C++指针计算</td><td style="text-align:center"><code>dx -r1 (*((ntdll!_IMAGE_OPTIONAL_HEADER *) 0xfd0110))</code></td></tr><tr><td style="text-align:center">ed</td><td style="text-align:center">修改寄存器的值</td><td style="text-align:center"><code>ed esp 00401010</code></td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">显示修改CPU寄存器</td><td style="text-align:center"><code>r eax</code>、<code>r eax=2</code></td></tr></tbody></table><h1>可能会出的简答汇总</h1><p>1.病毒感染其他文件的步骤</p><p>2.一个完整的木马系统的组成</p><p>3.流氓软件的定义</p><p>4.APT的攻击过程</p><p>5.APT的特征</p><p>6.恶意代码的防治策略（国家层面和单机用户层面）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;所用教材：刘功申等人编著的第四版&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明：博客为根据老师所画重点有</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>密码学题型速记</title>
    <link href="https://zss192.github.io/2020/06/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E9%A2%98%E5%9E%8B%E9%80%9F%E8%AE%B0/"/>
    <id>https://zss192.github.io/2020/06/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E9%A2%98%E5%9E%8B%E9%80%9F%E8%AE%B0/</id>
    <published>2020-06-28T09:36:00.000Z</published>
    <updated>2020-06-28T09:36:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>本篇文章根据老师给的重点有针对性的快速复习。</p><p>对于河南大学的学弟学妹们，如果你们任课老师是袁老师的话，他会给复习要点，跟着复习要点有针对性的复习就行。</p><h1>判断题2*5</h1><ul><li>题型太杂无法预测，可能考PPT黄色或黑色部分的内容</li></ul><h1>简答题5*6</h1><h2 id="范围"><a class="header-anchor" href="#范围">¶</a>范围</h2><ul><li>清楚信息安全专业学习密码学的原因</li><li>掌握流密码的基本思想</li><li>理解分组密码的CBC工作模式，能够画出该模式的加密示意图</li><li>理解弱单向函数与强单向函数的定义</li><li>能够知道5种密码学新方向或新技术(写出来5个就行)</li><li>第六个可能是标黄的也可能是标黑的</li></ul><h2 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.==清楚信息安全专业学习密码学的原因==   （非标准答案）（==必考！==）</p><p>答：信息在社会中的地位和作用越来越重要，而其安全也愈发重要，而密码学是保障信息安全的核心技术。密码学已渗透到我们日常生活各个方面。比如公钥密码技术用于数字签名，认证服务，没有它，常用的网上支付系统就无法存在。还有一些重要的用户登录系统，手机通信中的信息加密等也依赖密码学。信息安全专业学习密码学有利于学生了解如何保障信息的安全和基本思想的建立。</p><p>2.==流密码的基本思想==：  (==必考！==)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200616215215527.png"  alt="image-20200616215215527"></p><p>3.==CBC工作模式为==：它一次对一个明文分组(8个字节一组)加密，每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或，因此加密算法的输入不会显示出这次的明文分组之间的固定关系，所以重复的明文分组不会在密文中暴露出这种重复关系                   （==必须背会！==）</p><p>==CBC模式加解密示意图== （==必考！==）</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614163017246.png"  alt="image-20200614163017246" style="height:450px" /><p>加密: C<sub>i</sub>= E<sub>k</sub>[P<sub>i</sub>⊕C<sub>i-1</sub>] (可认为C<sub>0</sub>=IV)         解密:P<sub>i</sub>= D<sub>K</sub>[C<sub>i</sub>]⊕C<sub>i-1</sub></p><blockquote><p>IV初始向量与第一个明文分组异或，应像密钥一样被保护。该模式能够获得保密性也可认证，适合加密64比特的消息</p></blockquote><p>4.==弱单向函数和强单向函数==            （==必考！==）</p><p>单向函数：已知h，求使得H(x)=h的x在计算上是不可行的。</p><p>已知x，找出y (y≠x) 使得H(y)=H(x)在计算上是不可行的，若单向函数满足这种性质则称其为弱单向函数            （==必须会背！==）</p><p>找出任意两个不同的输入x、y，使得H(x)=H(y)在计算上是不可行的，若单向函数满足这种性质则称其为强单向函数                   （==必须会背！==）</p><blockquote><p>已知一个另找一个使得H函数相等是弱单向，任意给倆使其H函数相等是强单向（看谁单的很）</p></blockquote><p>5.写出5个密码学新方向或新技术</p><p>身份基加密(IBE)、属性基加密(ABE)、全同态加密、动态加密、可搜索加密</p><h1>计算题10*4</h1><h2 id="范围-v2"><a class="header-anchor" href="#范围-v2">¶</a>范围</h2><ul><li>能够根据给定的一个字节a，给定的AES仿射变换(*)和不可约多项式m(x)，求出字节a在AES S盒中字节代替变换的结果(需要自己求逆,自己试试就出来了)</li><li>能够根据RSA算法进行加密与解密计算<ul><li>a*b (mod q) = a (mod q) * b (mod q)</li><li>φ(n) = φ§*φ(q) = (p-1)*(q-1)</li></ul></li><li>能够使用ElGamal数字签名体制，进行签名与验证计算<ul><li>a*b (mod q) = a (mod q) * b (mod q)</li></ul></li><li>能够基于D-H密钥交换协议计算生成通信双方的共享密钥</li></ul><h2 id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.==对字节a=1011  0110字节替代变换，设a的逆为a<sup>-1</sup>==                 （ ==必考！==）</p><p>答：先求a的逆，再用仿射变换即可</p><p>:one: 由a得(x<sup>7</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>2</sup>+x)a<sup>-1</sup> ≡ 1(mod x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1)</p><p>所以a<sup>-1</sup>=x<sup>6</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>3</sup>             即0111 1000     （二进制对应位数有1就代表有x的那一次方）</p><blockquote><p>根据老师给的考试要点，仿射变换和m(x)题目会给出，a的逆试试就出来了</p><p>a*a<sup>-1</sup>即1011 0110*0111 1000 = 1101 0110 0100 00</p><p>a*a<sup>-1</sup> mod m(x)：1101 0110 0100 00 % 1000 1101 1(m(x)) = 1</p><p>考试时试试1的二进制，2的二进制，3的二进制，和a相乘%m(x)看是否为1</p></blockquote><p>:two: 使用仿射变换   （注意要用a的逆而且注意x的顺序从下往上读）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/QQ%E5%9B%BE%E7%89%8720200614210639.jpg"  alt=""></p><blockquote><p>注意是模2加，即只有0和1</p></blockquote><p>即(0100 1110)<sub>2</sub>=(4E)<sub>16</sub>                 注意也是从下开始读  因为最下面的是字节高位即最前面的01…</p><p>2.1 ==RSA加密体制中，接收方的公开钥是(e,n)=(5,35)，接收到的密文是C=10，求明文M== （==必考！==）</p><p>答：（    m ≡ c<sup>d</sup> mod n         所以得先算出d  -----&gt; d*e ≡ 1 mod φ(n)  ）</p><p>n=35             所以 p=5，q=7</p><p>φ(35) = (p-1)*(q-1) =4*6=24</p><p>因为 d*e ≡ 1 mod φ(n)   所以d=5      （这个到时候一个一个试就行）</p><p>m ≡ c<sup>d</sup> mod n ≡ 10<sup>5</sup> mod 35 ≡ 5          （注意不是等号）</p><blockquote><p>考试可求出明文再反推密文试下看看密文是不是10</p></blockquote><p>2.2 ==假设明文m=5，e=7，p=11，q=13，给出RSA的加密解密过程==     （==必考！==）</p><p>答：n=p*q=11*13=143           φ(143) = (p-1)*(q-1) = 10*12=120</p><p>因为d*e ≡ 1 mod φ(n)  即d*7 ≡ 1 mod 120   所以 d=103</p><p>加密：c ≡ m<sup>e</sup> mod n  ≡ 5<sup>7</sup> ≡ 47 mod 143</p><p>解密：m ≡ c<sup>d</sup> mod n  ≡ 47<sup>103</sup> ≡ 5 mod 143</p><p>3.ElGamal签名体制中，假设p=19，g=13。签名者A的私钥为x = 10，试计算公钥。设消息M=15，k=11，求签名过程并验证。  (==必考！==)</p><p>答：公钥：y ≡ g<sup>x</sup> mod p ≡ 13<sup>10</sup> mod 19 = 6</p><p>签名：r ≡ g<sup>k</sup>  (mod p) ≡ 13<sup>11</sup> mod 19 =2</p><p>s ≡ (H(m)-xr)k<sup>-1</sup> (mod p-1) ≡ (m-xr)k<sup>-1</sup> (mod p-1) ≡ (15-10*2)*11<sup>-1</sup> mod 18 = 11</p><p>所以(r,s)=(2,11)</p><p>验证：y<sup>r</sup>r<sup>s</sup> ≡ 6<sup>2</sup>*2<sup>11</sup> mod 19 ≡ 8 ≡ g<sup>m</sup> (mod p) ≡ 13<sup>15</sup> ≡ 8 mod 19</p><blockquote><p>根据老师的重点中给出的a*b (mod q) = a (mod q) * b (mod q)应该是用在比如这题求6<sup>2</sup>*2<sup>11</sup> mod 19就等同于求6<sup>2</sup> mod 19 * 2<sup>11</sup> mod 19 ≡ 17 *15 ≡ 8 mod 19</p></blockquote><p>求上面的11<sup>-1</sup>mod 18：</p><p>11*x ≡ 1 mod 18可算出x=5，而11*11<sup>-1</sup> ≡ 1 mod 18 即11<sup>-1</sup> ≡ 5 mod 18</p><p>4.在Diffie- Hellman密钥交换过程中，设大素数p=11,a=2是p的本原根。  （==必考！==）<br>(1) 用户A的公开钥Y<sub>A</sub>=9,求其秘密钥XA。<br>(2)设用户B的公开钥Y<sub>B</sub>=3,求A和B的共享密钥K。</p><p>答：:one: Y<sub>A</sub>=a<sup>XA</sup> mod p = a<sup>XA</sup> mod p 即 9=2<sup>XA</sup> mod 11   所以 X<sub>A</sub>=6  (考试时一个一个试就行)</p><p>:two: K=Y<sub>B</sub><sup>XA</sup> mod p = 3<sup>6</sup> mod 11 =3</p><h1>论述题1*20  （任选一个即可）</h1><ul><li>介绍一种密码学协议研究与应用动态。</li><li>提出一种安全应用场景，试设计出相应的密码协议实现安全应用。</li><li>介绍一种安全应用场景，分析该安全场景应用了哪些密码技术，并简述如何保障了安全性。</li></ul><p><a href="https://baike.baidu.com/item/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E">https://baike.baidu.com/item/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E</a></p><h2 id="零知识证明"><a class="header-anchor" href="#零知识证明">¶</a>零知识证明</h2><h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3><p>零知识证明是在20世纪80年代初提出的。它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。</p><blockquote><p>要是太多这段可省略</p><p>零知识证明起源于最小泄露证明。设P表示掌握某些信息，并希望证实这一事实的实体，设V是证明这一事实的实体。假如某个协议向V证明P的确掌握某些信息，但V无法推断出这些信息是什么，我们称P实现了最小泄露证明。不仅如此，如果V除了知道P能够证明某一事实外，不能够得到其他任何知识，我们称P实现了零知识证明，相应的协议称作零知识协议。</p></blockquote><p>例如，A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有2个方法：</p><p>①A把钥匙出示给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。</p><p>②B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。</p><p>后面的②方法属于零知识证明。它的好处在于，在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p><h3 id="应用动态"><a class="header-anchor" href="#应用动态">¶</a>应用动态</h3><p>零知识证明在区块链里的应用非常广泛。最早使用零知识证明技术的区块链叫做 Zcash，这是许多零知识证明的做法之一，也是最有名的一个。V神就曾表示称，零知识证明能够被应用于以太坊区块链上几乎所有的场景。</p><p>相对于ZCash来说，比特币的转账并不是完全匿名的，只要知道了一个比特币地址，任何人都可以通过这个网站，查到这个地址的所有“消费”行为。比如给谁转了账，又从谁那里收到过转账，在以区块链技术为基础的“账本”上都详细地记录着。</p><p>例如A有3个BTC，要给B转账1个BTC，那么在账本上就会记录着：A转出了两笔BTC，一笔为1BTC，转给了B；另一笔为2BTC，转给了自己。</p><p>那么利用了“零知识证明”的ZCash是怎么做到的所谓匿名呢？</p><p>ZCash的代币为ZEC。同样假设A有3个ZEC，要给B转账1个ZEC。</p><p>首先，A会将自己的1个ZEC分成若干份随机投入一系列的“混合容器”中，指定接收方B的地址，同时混入的时候还有其他交易方输出的若干份ZEC。这些ZEC又被混合容器随机拆分，再从这些被拆分生成的所有的ZEC中取出合计为1ZEC的若干份，转移到B的地址中，同时在发送的时间上也可以设置一定的延迟。</p><p>其中的“混合容器”，就是一条“公有链”。经过这条公有链一系列的“混币”过程，就使得包括交易地址和具体金额在内的交易信息变得无从考证了。</p><p>零知识证明技术虽然会给区块链带来更强的匿名性，但同时会引起大量的监管问题，这是零知识证明技术无法回避的一个问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;本篇文章根据老师给的重点有针对性的快速复习。&lt;/p&gt;
&lt;p&gt;对于河南大学的学弟学妹们，如果你们任课老师是袁老师的话，他会给复习要点，跟着复习要点有针对性的复习就行。&lt;/p&gt;
&lt;h1&gt;判断题2*5&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;题型太杂无法预测，可能</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>实验六 查找和排序的实现</title>
    <link href="https://zss192.github.io/2020/06/12/%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zss192.github.io/2020/06/12/%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-12T04:13:00.000Z</published>
    <updated>2020-06-12T04:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>实验性质：综合性实验</h1><h1>要求：</h1><p>（1）采用邻接矩阵/邻接表建立图；<br>（2）采用深度优先/广度优先搜索方式遍历图；<br>（3）编程实现Dijkstra最短路径算法。</p><h1>目的：</h1><p>（1）掌握图的邻接矩阵和邻接表存储方式；<br>（2）掌握图的遍历算法；<br>（3）掌握图的实际应用——最短路径算法。</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//**折半查找**//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;<span class="comment">//查找表中每个数据元素的值</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;<span class="comment">//存放查找表中数据元素的数组</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//记录查找表中数据的总数量</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//**二叉排序树**//</span></span><br><span class="line"><span class="keyword">int</span> m=<span class="number">-1</span>;   <span class="comment">//二叉排序树初始化计数</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;    <span class="comment">//二叉排序树关键字序列下标和查找次数计数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    string key;<span class="comment">//查找表中每个数据元素的值</span></span><br><span class="line">    <span class="keyword">int</span> position;<span class="comment">//结点在关键字序列中的位置</span></span><br><span class="line">&#125;ElemType2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType2 data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br><span class="line"><span class="comment">//**排序**//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  key;   <span class="comment">//关键字项</span></span><br><span class="line">&#125;RedType;                     <span class="comment">//记录类型</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    RedType  r[MAXSIZE+<span class="number">1</span>]; <span class="comment">//r[0]闲置</span></span><br><span class="line">    <span class="keyword">int</span>  length;  <span class="comment">//顺序表长度</span></span><br><span class="line">&#125;SqList;  <span class="comment">//顺序表类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList</span><span class="params">(SSTable &amp;ST)</span></span>;   <span class="comment">//创建有序线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,<span class="keyword">int</span> key)</span></span>;   <span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(BSTree &amp;T)</span></span>; <span class="comment">//创建二叉链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BSTree T)</span></span>; <span class="comment">//中序遍历</span></span><br><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,  string key)</span></span>;<span class="comment">//二叉树的递归查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>;<span class="comment">//初始化及赋初始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputKey</span><span class="params">(SqList &amp;L)</span></span>;  <span class="comment">//输出当前顺序表数值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span></span>;<span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L)</span></span>;  <span class="comment">//折半插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    BSTree T;</span><br><span class="line">    SqList L;</span><br><span class="line">    <span class="built_in">Menu</span>();</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//输入的数字</span></span><br><span class="line">    <span class="keyword">int</span> key;string key2;    <span class="comment">//输入的待查元素</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">CreateList</span>(ST);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;请输入待查元素:&quot;</span>;</span><br><span class="line">                cin&gt;&gt;key;</span><br><span class="line">                <span class="built_in">Search_Bin</span>(ST,key);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">CreateTree</span>(T);</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;二叉排序树创建成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;其中序遍历结果为:&quot;</span>;</span><br><span class="line">                n=<span class="number">0</span>;    <span class="comment">//置二叉排序树关键字序列下标从0开始</span></span><br><span class="line">                <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;请输入待查元素:&quot;</span>;</span><br><span class="line">                cin&gt;&gt;key2;</span><br><span class="line">                n=<span class="number">0</span>;    <span class="comment">//置查找次数为0</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;待查元素为第&quot;</span>&lt;&lt;<span class="built_in">SearchBST</span>(T,key2)-&gt;data.position+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个元素,&quot;</span>;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;共查找了&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;次&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;顺序表初始化成功,&quot;</span>;</span><br><span class="line">                <span class="built_in">InitList</span>(L);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">InsertSort</span>(L);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="built_in">BInsertSort</span>(L);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;输入的位置非法，请重新输入&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**折半查找**//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList</span><span class="params">(SSTable &amp;ST)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ST.elem=<span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!ST.elem)    cout&lt;&lt;<span class="string">&quot;存储分配失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ST.length=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>]=&#123;<span class="number">5</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">27</span>,<span class="number">30</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">60</span>,<span class="number">67</span>,<span class="number">71</span>&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;有序线性表创建成功，其数值为:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=ST.length; i++)    <span class="comment">//从下标1开始存储</span></span><br><span class="line">    &#123;</span><br><span class="line">        ST.elem[i].key=a[i<span class="number">-1</span>];    <span class="comment">//设置初始顺序表数值</span></span><br><span class="line">        cout&lt;&lt;ST.elem[i].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">1</span>;<span class="keyword">int</span> high=ST.length;<span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">0</span>;<span class="keyword">bool</span> isHave=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        times++;    <span class="comment">//查找次数</span></span><br><span class="line">        <span class="keyword">if</span>(key==ST.elem[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;待查元素为第&quot;</span>&lt;&lt;mid&lt;&lt;<span class="string">&quot;个元素,共查找了&quot;</span>&lt;&lt;times&lt;&lt;<span class="string">&quot;次&quot;</span>&lt;&lt;endl;</span><br><span class="line">            isHave=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;ST.elem[mid].key)   high=mid<span class="number">-1</span>; <span class="comment">//在前面找</span></span><br><span class="line">        <span class="keyword">else</span> low=mid+<span class="number">1</span>; <span class="comment">//在后面找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isHave)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;待查元素不在有序表中，共查找了&quot;</span>&lt;&lt;times&lt;&lt;<span class="string">&quot;次&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**二叉排序树**//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(BSTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ch[<span class="number">13</span>]=&#123;<span class="string">&quot;45&quot;</span>,<span class="string">&quot;24&quot;</span>,<span class="string">&quot;12&quot;</span>,<span class="string">&quot;#&quot;</span>,<span class="string">&quot;#&quot;</span>,<span class="string">&quot;37&quot;</span>,<span class="string">&quot;#&quot;</span>,<span class="string">&quot;#&quot;</span>,<span class="string">&quot;53&quot;</span>,<span class="string">&quot;#&quot;</span>,<span class="string">&quot;93&quot;</span>,<span class="string">&quot;#&quot;</span>,<span class="string">&quot;#&quot;</span>&#125;;</span><br><span class="line">    m+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch[m]==<span class="string">&quot;#&quot;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="keyword">new</span> BSTNode;</span><br><span class="line">        T-&gt;data.key=ch[m];</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;lchild);    <span class="comment">//递归创建左子树</span></span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;rchild);    <span class="comment">//递归创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BSTree T)</span> <span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">        cout&lt;&lt;T-&gt;data.key&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//访问根节点</span></span><br><span class="line">        T-&gt;data.position=n;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,  string key)</span><span class="comment">//二叉树的递归查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">if</span>((!T) || key==T-&gt;data.key) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild,key); <span class="comment">//在左子树中继续查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild,key); <span class="comment">//在右子树中继续查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**排序**//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span><span class="comment">//初始化且赋初始值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>&#125;;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[i].key=a[i<span class="number">-1</span>];</span><br><span class="line">        L.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">OutputKey</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputKey</span><span class="params">(SqList &amp;L)</span> <span class="comment">//输出当前顺序表数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前顺序表值为:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;L.r[i].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span><span class="comment">//直接插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=L.length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( L.r[i].key&lt;L.r[i<span class="number">-1</span>].key)<span class="comment">//将L.r[i]插入有序子表</span></span><br><span class="line">        &#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i]; <span class="comment">// 复制为哨兵</span></span><br><span class="line">            L.r[i]=L.r[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-2</span>; L.r[<span class="number">0</span>].key&lt;L.r[j].key;--j)</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.r[j]; <span class="comment">// 记录后移</span></span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>]; <span class="comment">//插入到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;直接插入排序成功,&quot;</span>;</span><br><span class="line">    <span class="built_in">OutputKey</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L )</span>  <span class="comment">//折半插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=L.length; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">         L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">         <span class="keyword">int</span> low = <span class="number">1</span> ; <span class="keyword">int</span> high = i<span class="number">-1</span> ;</span><br><span class="line">         <span class="keyword">while</span> (low &lt;=high)</span><br><span class="line">         &#123;</span><br><span class="line">            m=( low + high )/<span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(L.r[<span class="number">0</span>].key &lt; L.r[m]. key)</span><br><span class="line">                high = m <span class="number">-1</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = m + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=high+<span class="number">1</span>; --j)</span><br><span class="line">            L.r[j+<span class="number">1</span>] = L.r[j];</span><br><span class="line">        L.r[high+<span class="number">1</span>] = L.r[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;折半插入排序成功,&quot;</span>;</span><br><span class="line">     <span class="built_in">OutputKey</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;********by 夏日********&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1-----创建有序线性表(折半查找前提)&quot;</span>&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2-----折半查找&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3-----创建二叉排序树 &quot;</span>&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4-----二叉排序树查找&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5-----顺序表初始化及赋初始值&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6-----直接插入排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;7-----折半插入排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;   退出,输入一个负数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>输出示例</h1><p>1.创建有序线性表<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612120802268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>2.折半查找<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612120920647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>3.创建二叉排序树<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612120943210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>4.二叉排序树查找<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612120953288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>5.顺序表初始化<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612121003104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>6.直接插入排序<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020061212101316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>7.折半插入排序<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612121020825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验性质：综合性实验&lt;/h1&gt;
&lt;h1&gt;要求：&lt;/h1&gt;
&lt;p&gt;（1）采用邻接矩阵/邻接表建立图；&lt;br&gt;
（2）采用深度优先/广度优先搜索方式遍历图；&lt;br&gt;
（3）编程实现Dijkstra最短路径算法。&lt;/p&gt;
&lt;h1&gt;目的：&lt;/h1&gt;
&lt;p&gt;（1）掌握图的邻接矩阵和</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zss192.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zss192.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理期末总结</title>
    <link href="https://zss192.github.io/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>https://zss192.github.io/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-09T14:32:00.000Z</published>
    <updated>2020-06-09T14:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>为迎接期末，总结了下知识点，供个人复习使用，仅供参考。</p><p>本文用到的复习资料：<a href="https://pan.baidu.com/s/1s4kU4UtgG7xiUyssDvuwKw">点我跳转</a>，提取码：1l49</p><p>若需要本文markdown文件下方评论留言看到即回</p><h1>计算机系统概论</h1><h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608144821042.png"  alt="image-20200608144821042" style="zoom: 67%;" /><p>1.时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。</p><p>2.主频(时钟频率)：每秒钟含有多少个时钟周期(1.2GHz即每秒钟含有1.2x10<sup>9</sup>个时钟周期)。</p><p>3.CPI：一条指令所需要的时钟周期个数。</p><p>4.MIPS：每秒钟能执行多少个==100万==条指令。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020021912112010.png"  alt=""></p><p>5.MFLOPS：每秒百万次浮点操作次数。</p><p>6.CPU执行时间：TCPU=In×CPI×TC (指令条数*一条指令需要几个时钟周期*时钟周期长度)</p><blockquote><p>In：执行程序中==指令==的==总数==</p><p>CPI(Clock Cycle Per Instruction)：执行每条==指令所需==的平均时钟==周期个数==<br>TC：时钟==周期时间==的长度</p></blockquote><p>7.吞吐量：计算机某一时间间隔内能够处理的信息量(能吞多少)</p><p>8.响应时间：从事件开始到事件结束的时间,也称执行时间.</p><p>7.冯●诺依曼型计算机设计思想主要有两项:</p><ul><li>将十进制改为二进制,从而太太简化了计算机的结构和运算过程;</li><li>存储程序的思想，将<strong>程序与数据</strong>一起存储在计算机内，使得计算机的全部运算成为真正的自动过程。</li></ul><blockquote><p>存储（程序）并按（地址）顺序执行，这是冯•诺依曼型计算机的工作原理。</p></blockquote><p>8.用嘴(一句一句最后生成目标程序)来解释，用手(一步到位最后不生成目标程序)来编译</p><p>编译程序将高级语言转换为机器代码再执行，解释程序用源程序直接解释，解释一句执行一句不用转换成机器代码。所以编译要比解释速度快</p><p>9.控制器可根据==不同的周期==(取指周期或者执行周期)来区分该地址的存储单元存储的是数据还是指令。</p><h2 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.假定机器M的时钟频率为200MHz，程序P在机器M上的执行时间为12s。对P优化，将所有乘4指令都换成了一条左移两位的指令，得到优化后的程序P’。若在M上乘法指令的CPI为102，左移指令的CPI为2，P的执行时间是P’执行时间的1.2倍，则P中的乘法指令条数为_______4x10<sup>6</sup>________</p><p>答：P’的执行时间为10s,比12少了2s，由时钟频率得每秒有2x10<sup>8</sup>个时钟周期，即少了4x10<sup>8</sup>个时钟周期</p><p>每条左移指令比乘法指令少了100个时钟周期，那么乘法指令个数即总共少的时钟周期/每条指令少的时钟周期</p><blockquote><p>p和p’的时间差是因为指令被替换了，而所有被替换的指令个数就是乘法指令个数</p></blockquote><p>2.此题MIPS为400</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608152105898.png"  alt="image-20200608152105898"></p><p>答：平均CPI=2x0.5+ 3x0.2+4x0.1+5x0.2=3，即执行一个指令平均需要3个周期</p><p>MIPS为每秒可执行的百万条指令数，1.2GHZ为1200MHZ即一秒有1.2*10<sup>9</sup>个周期，总周期=一个指令所需周期*有多少指令。1200/3=400（M=10<sup>6</sup>,G=10<sup>9</sup>）</p><p>3.程序P在机器M上的执行时间是20s，编译优化后，P执行的指令数减少到原来的70%，而CPI增加到原来的1.2倍，则P在M上的执行时间是_______16.8s____</p><p>答：CPI即执行一条指令所需的时钟周期数。假设M机器原时钟周期为x,原CPI为y, P程序的指令数为z，可得P程序执行时间为xyz= 20s。</p><p>编译优化后M机器的CPI变为1.2y, P程序的指令数变为0.7z,则P程序执行时间为1.2*0.7xyz,故其执行时间为<br>16.8s。</p><p>4.某工作站采用时钟频率f为15MHz，处理速率为10MIP/S的处理机来执行一个已知混合程序。假定每次存储器存取为1周期延迟，此计算机的有效CPI是_______1.5_____________，假定将处理机的时钟频率提高到30MHz，但存储器子系统速率不变。这样，每次存储器存取需要两个时钟周期，如果30%指令每条只需要一次存储存取，而另外5%每条需要两次存储存取，还假定已知混合程序的指令数不变，并与原工作站兼容，则改进后的处理机性能相比原来的_______提高_____________</p><p>答：CPI即每个指令需多少周期，已知每秒有15*10<sup>6</sup>个周期，每秒可以处理10*10<sup>6</sup>个指令，那么总周期数/总指令数即为CPI</p><p>15*10<sup>6</sup>/10*10<sup>6</sup>=1.5    (注意和后面那个1周期延迟没有关系，不要被他迷惑，这个周期延迟已经被计算在前面的10MIP/s中了)</p><p>处理性能是否提高就看处理速率是否提高了。30%需要一次存取，由于每次存取增加了1周期延迟，那么这30%就得增加一个周期，而同理另外5%需要增加两周期。则CPI<sub>new</sub>=CPI<sub>原</sub>+30%*1+5%*2=1.9  (原CPI已经包括原来的1周期延迟，只需将计算新增的即可)</p><p>又已知现在每秒有30*10<sup>6</sup>个周期，那么处理速率为总周期数/每指令所需周期数=30×10<sup>6</sup>/(1.9×10<sup>6</sup>)= 15.79MIP/S，所以提高了</p><p>5.假定计算机M1和M2具有相同的指令集体系结构，主频分别为1.5 GHz和1.2 GHz。在M1和M2_上运行某基准程序P，平均CPI分别为2和1，则程序P在M1和M2_上运行时间的比值是?</p><p>答：M1的CPI为2即2周/指，而M2为1周/指。同样的程序P即指令数相同。M1的周期T1=1/1.5*10<sup>9</sup>，M2的周期T1=1/1.2*10<sup>9</sup></p><p>那么每条指令所需时间分别为2×T1和1×T2，指令数相同，那时间比值就等于一条指令所需时间比值即(2×T1)/(1*T2)=8/5</p><h1>运算方法和运算器</h1><h2 id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609143207561.png"  alt="image-20200609143207561" style="zoom: 80%;" />1.数字0在原码反码补码的表示</p><p>[+0]原码=0000 0000，  [-0]原码=1000 0000</p><p>[+0]反码=0000 0000，  [-0]反码=1111 1111</p><p>[+0]补码=0000 0000，  [-0]补码=0000 0000   （补码中是唯一的）</p><p>0的移码也是唯一的1000 0000</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609151740827.png"  alt="image-20200609151740827" style="zoom:67%;" /><p>由于补码0是唯一的所以补码范围要多一个负数(总共都是256个数)</p><p>2.对于规格化的浮点数，尾数有三种形式：（小数点左边的是符号位）</p><ul><li><p>原码表示时尾数的小数点后第一数位为1，数符任意</p></li><li><p>补码和反码表示时尾数的符号位与小数点后第一数位不同</p></li><li><p>1.1xx……X(原码)</p></li><li><p>1.0XX……X(补码、反码)</p></li><li><p>0.1xx……x(原码、补码、反码)</p></li></ul><blockquote><p>原理是保证   1&gt; |M|≥ 0.5</p></blockquote><p>3.余3码就是8421码加3所得</p><p>4.奇偶校验码：加上校验码后1的个数为奇数就是奇校验。不具备纠错能力。</p><p>5.海明码：设有k个数据位，则应设r个校验位，r满足2<sup>r</sup>-1 ≥ k + r 。发现两位错误纠正一位错误。</p><p>6.循环冗余检验码(CRC)：k位校验位拼接在n位数据位后面，即为n+k，发现并纠正一位或多位错误</p><p>7.A的ascii码：65            a的ascii码：97</p><p>8.已知[x]<sub>补</sub>，求[-x]<sub>补</sub>：将[x]<sub>补</sub>连同符号位求反+1</p><p>9.移码就是补码的符号位求反</p><blockquote><p>由于负数的补码如-21(101011)看着好像大于21(010101)，实际正好是21更大，所以浮点数的阶码用移码表示能直观的看出大小便于加减运算</p></blockquote><p>10.-1的补码永远是全1(可理解为全1加1等于全0)</p><p>11.由于补码溢出无法看出是上溢(大于最大数)还是下溢，因此引入变形补码</p><ul><li>两个符号位不同时表溢出(01为正溢出，10为负溢出(看第一位))</li><li>最高位那个数代表真正的符号位</li><li>两个符号位均参与运算，若进位舍去</li></ul><p>12.IEEE754计算公式：真值x=(-1)<sup>S</sup><em>1.M</em>2<sup>e</sup>（S为符号位(正还是负)，E为阶码(转换成e代表多少次方)，M为尾数(小数点后面的数)，顺序为SEM）其中e=E-127(可记成大E大所以要减)</p><p>13.补码的1000 0000为什么代表-128</p><p><strong>补码就是同余</strong>，比如-3的原码是1011而它的反码是1100则补码为1101,无符号的1101是13和-3正好模2<sup>4</sup>同余</p><p>所以给出一个负数的补码将其看为无符号数减去2<sup>n</sup>(n为总位数)即代表真值</p><p>为什么会这样呢？4位二进制可表示16个数，那么想表示负数怎么办，就用同余的思想，-1就用15表示，-2就用14表示，-3就用13(1101)表示</p><p>回到本题，给出补码求真值，将其看成无符号数即为128，与128模2<sup>8</sup>同余的负数即为-128（也可用128-2<sup>8</sup>计算）</p><p>14.IEEE754的尾数用原码表示，阶码用指数的移码-1表示（所以E=e+127）</p><h2 id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.写出D=101101的海明码</p><p>答：:one:首先确定检验位的个数：k=6，2<sup>r</sup>-1 ≥ k + r即2<sup>r</sup> ≥7+r，所以r=4</p><p>:two:确定检验码的位置：检验码P<sub>i</sub>(i=1,2…)的位置为2<sup>i-1</sup>（2<sup>0</sup>,2<sup>1</sup>,2<sup>2</sup>…）</p><p>注意从M10到M1，从大到小且没有0</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609150117418.png"  alt="image-20200609150117418"></p><p>:three:求出检验码的值：校验位Pi的值即为所有需要Pi校验的数据位求异或。</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609150430484.png"  alt="image-20200609150430484" style="zoom:80%;" /><p>如P2对应M2，需要它的有D1即M3(2+1)、D3即M6(2+4)、D4即M7(2+4+1)…</p><p>所以最后的海明码为1011100100</p><p>2.已知x=11011，y=-10101，用变形补码计算x+y</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609154616627.png"  alt="image-20200609154616627" style="zoom:70%;" /><blockquote><p>注意一定要先转换成补码再添符号位运算</p></blockquote><p>3.假设M(x)=x<sup>3</sup>+1(发送信息的多项式)，G(x)=x<sup>3</sup>+x+1(生成多项式，代表校验位信息)。</p><p>:one: 那么M(x)代表的二进制码为: 1001(1*x<sup>3</sup>+1*x<sup>0</sup>)，G(x)代表的二进制码为: 1011</p><p>:two:将M(x)的多项式左移G(x)的最高次数，变为1001 000</p><p>:three:将1001 000对1011做模2除法得到余数为110,将其与被除数1001合并得到CRC码1001 110</p><blockquote><p>这里要注意第三步的模2除法和普通除法不同，模2除法不会向上一位借位也不比较被除数和除数的大小(位数相同即可)，如图中第三位商数(1101&gt;1000但仍可做减操作)<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609195155116.png"  alt="image-20200609195155116" style="zoom:80%;" /></p></blockquote><p>4.若浮点数x的754标准存储格式为(41360000)<sub>16</sub> ,求其浮点数的十进制数值。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609225853843.png"  alt="image-20200609225853843"></p><blockquote><p>注意阶码没有符号位</p></blockquote><p>5.将数(20. 59375)<sub>10</sub>转换成754标准的32位浮点数的二进制存储格式。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609230432591.png"  alt="image-20200609230432591"></p><p>6.某机器数为1000 0000B，若它代表0，则它是（原）码形式。若代表-128，则它是（补）码形式。若代表-127，则它是（反）码形式。</p><p>答：若是原码形式，就是-0。若是反码形式时，转换为原码就是1111 1111即-127(-(2<sup>7</sup>-1)) ，若是补码，1000 0000无符号时是2<sup>7</sup>=128，所以该补码代表-128（详情见上面知识点）</p><p>7.某机字长32位，其中1位符号位，31位表示尾数，若用定点小数表示，则最大正小数为多少？（B）</p><p>A.(1-2<sup>-32</sup>)B.(1- 2<sup>-31</sup> )C.2<sup>-32</sup>D.2<sup>-31</sup></p><p>答：这样的题就用4位的先试试。4位最大小数就是 0 111，也就是0.875  即1-2<sup>-3</sup>  所以可推出32位时最大是 1-2<sup>-31</sup></p><p>8.IEEE 754单精度浮点数格式表示的数中，最小的规范化正数为（A）</p><p>A.1.0x2<sup>-126</sup>B.1.0x2<sup>-127</sup>C.1.0x2<sup>-128</sup>D.1.0x2<sup>-149</sup></p><p>答：浮点数表示为1.M*2<sup>E</sup>，最小M为0,且E也要最小，这样往左移位越多数值越小，这样就转换成IEEE754中指数的最小值问题</p><p>对E来说，去除全1和全0(表0和无穷大)，E的范围为1~254，而e=E-127即e的范围为-126～+127，即指数最小为-126</p><p>所以本题答案为1.0*2<sup>-126</sup></p><p>9.若x=103,y=-25,则下列表达式采用8位定点补码运算实现时，会发生溢出的是 （ C ）</p><p>A.x+yB.-x+yC.x-yD.-x-y</p><p>答：不用转换成补码再算，直接算。四个选项中B的-128和C的128绝对值最大最可能溢出</p><p>而8位补码范围是-128~127，那就是C的128溢出了  (注意补码的0是唯一的所以多了个最大负数-128)</p><ol start="10"><li></li></ol><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620135418708.png"  alt="image-20200620135418708"></p><p>答：这题的关键点是计算机使用补码参与运算的。-9的原码是1000 1001，补码是1111 0111，扩展到16位高位补1(也可写完整的16位原码再转换成补码)            x = 127，原码：0111 1111，补码：0111 1111，扩展到32位高位补0       z=x+y=118同理高位补0</p><p>11.整数x的机器数为1101 1000,分别对x进行逻辑右移1位和算术右移1位操作得到的机器数为_____________<u>0110 1100、1110 1100</u>______________</p><p>答：逻辑右移就是右移一位，左边补零即可。算术右移需要考虑符号位(算术要算所以补符号位)，右移一位，左边补符号位。</p><p>12.已知x=10111，y=11011，用变形补码求x-y</p><p>答：[x-y]<sub>补</sub>=[x]<sub>补</sub>+[-y]<sub>补</sub>，[x]补=00 10111，[-y]补=11 00101</p><p>00 10111+11 00101  =11 11100，结果没溢出转换为原码为1 00100即-00100  (注意得到的是补码要转换为真值)</p><blockquote><p>[y]补=00 11011，[-y]补=[y]补连同符号位求反加1=11 00101，当然也可直接求-11011的补码</p></blockquote><p>13.假定有4个整数用8位补码分别 表示r1=FEH,r2=F2H, r3=90H, r4=F8H,若将运算结果存放在 一个8位寄存器中，则下列运算会发生溢出的是（ B ）</p><p>A.r1×r2B.r2×r3C.r1×r4D.r2×r4</p><p>答：这种判断是否溢出的题就算出真值看看是否溢出。r1真值为-2，r2真值为-14，r3真值为-112，r4真值为-8</p><p>而这是补码运算最后得到的结果也是补码，8位补码范围为-128~127，所以显然r2*r3得到的结果转换为补码大于8位补码最大值</p><h1>多层次的存储器</h1><h2 id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610135354300.png"  alt="image-20200610135354300" style="zoom:80%;" /><p>1.存储器按存取方式可分为</p><ul><li><p>随机存取存储器（RAM）可读可写，断电即失(也称易失性)</p><ul><li>静态RAM(SRAM)   常用做高速缓冲存储器</li><li>动态RAM(DRAM)  常用做主存</li></ul></li><li><p>只读存储器（ROM）只读不写，断电保留(也称非易失性)</p></li><li><p>串行访问存储器</p><ul><li><p>顺序存取存储器（如磁带）</p></li><li><p>直接存取存储器（如磁盘）</p></li></ul></li></ul><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610140643769.png"  alt="image-20200610140643769" style="zoom:80%;" /><p>2.这些存储器名称中带E的都表示可擦除（可能出选择题，Erasable：可擦）</p><p>3.为了解决存储器大容量、低价格、高速度三者之间的矛盾关系，常采用多级存储器结构</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610140844977.png"  alt="image-20200610140844977" style="zoom:67%;" /><p><strong>缓存</strong>-主存层次主要解决CPU和主存速度不匹配的问题，数据交换由硬件完成。</p><p>主存-<strong>辅存</strong>层次主要解决存储系统的容量问题，数据交换由硬件和操作系统共同完成</p><p>4.存储器带宽就是每秒存储器存储的信息量</p><p>5.SRAM存取速度快但容量不如DRAM（记住SRAM用作高速缓冲存储器，速度肯定快）</p><blockquote><p>DRAM需要刷新会影响速度，所以SRAM速度更快但是价格昂贵</p></blockquote><p>6.DRAM采用电容存储，由于电荷量会减少所以必须定期(若不说明则是2ms)刷新,可分为</p><ul><li>集中刷新（集中到一段时间，集中歼灭）死时间是刷新总时间</li><li>分散刷新（每存取一次就刷新一次，分散歼灭）加倍存取周期实现死时间为0</li><li>异步刷新（折中方案，有计划的刷新）死时间就是一个存取周期</li></ul><blockquote><p>刷新的实质就是读出数据再写入（对行刷新，若不说明刷新一行等于一个存储周期）</p></blockquote><p>7.ROM也是随机存取(像数组下标一样访问)，但随机存取<strong>存储器</strong>要求可读可写，ROM只读，所以把ROM和RAM分开（第一个随机存取只是取信息的方式和存储器的随机存取含义不一样）</p><p>8.如果要求将容量为axb的芯片组成容量为cxd的芯片，假设需要芯片的数量为n,则n=(cxd)/axb     （a是字线连接地址线，b是位线连接数据线）</p><p>9.命中率：CPU要访问的信息在Cache中的比例（cache存取次数/(cache存取+主存存取)）</p><p>10.平均访问时间：t<sub>a</sub>=命中率×访问cache的时间+(1-命中率)×访问主存时间 (t<sub>a</sub>=ht<sub>c</sub>+(1-h)t<sub>m</sub>)</p><p>11.访问效率：访问Cache时间/平均访问时间 (e=t<sub>c</sub>/t<sub>a</sub>)</p><p>12.CPU与Cache之间传送数据的基本单位是字，而主存与Cache之间传送数据的基本单位是块(一块包括多个字)。（可理解为CPU容量少传输的也少，主存容量大传输的也大）</p><p>13.为了把主存的部分内容放到Cache中要把主存地址转换为Cache地址（因为主存和Cache用块传输，所以主要是块号的转换）</p><ul><li>直接映射        根据行号指定特定行比（适合大容量Cache）</li><li>全相联映射   与Cache所有行全都比（适合小容量Cache）</li><li>组相联映射   先根据组号找到对应组，再在组中一个一个比(折中的方法)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610171302861.png"  alt="image-20200610171302861"></p><blockquote><p>可以看到直接映射因为要找特定行，所以多了行号地址，组相联因为要找特定组所以多了组号地址，而全相联因为是一行一行比所以啥也没有</p></blockquote><p>14.替换策略：当要放新的东西而Cache满时就要替换</p><ul><li>最不经常使用(LFU即Least Frequently Used)算法     首先淘汰一定时期内被访问次数最少的</li><li>近期最少使用(LRU即Least Recently Used)算法     首先淘汰最长时间未被使用的</li><li>随机替换                              随缘替换</li></ul><p>15.Cache要和主存内容保持一致(CPU对Cache的写入更改了它)，所以要用到写操作策略</p><ul><li>写回法    只修改Cache的内容而不立即写入主存，此行被换出时写入主存</li><li>全写法(直写法、写直达)    Cache和主存同时修改</li><li>写一次法  处理和写回法一致，只是第一次命中要同时写入主存（折中处理）</li></ul><p>16.TLB(快表)、页表和Cache之间的命中关系</p><p>记住只要TLB(页表分为快表和慢表)和Cache有一个命中，页表一定命中，但页表命中那俩不一定命中(数据在主存不在Cache时)，也可能都不命中       （<strong>即页表最大</strong>）</p><p>17.DRAM采用地址复用技术，地址线为正常的一半，例如你计算的用10根地址线实际用5根就行 （先送行地址再送列地址）</p><h2 id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2><p>1.RAM和ROM的区别</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610145652114.png"  alt="image-20200610145652114"></p><p>答：RAM断电会失去信息而ROM不会，二者访问信息的方式都是随机存取。Cache需要可读可写，而Rom只能读不能写，肯定不适合。DRAM(动态RAM)才需要刷新。</p><p>2.Flash存储器</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610150200185.png"  alt="image-20200610150200185"></p><p>3.假定用若干个2K×4位芯片组成一个8K×8位存储器，则地址0B1FH所在芯片的最小地址是</p><p>答：8k*8/2k*4=8，需要8个芯片，8k=2<sup>13</sup>，所以需要13位地址。2个4位的芯片构成一个8位的(存取数据一次最少8位)，所以需要4组，片选地址为2位(位扩展两个要选中都是同时选中，所以只看字扩展)，剩下的为片内地址</p><p>:one: 每组芯片是2k*8即11个地址线，4组需要2位片选信号，所以每组后11位是从全0到全1</p><p>第1组芯片地址范围：000==0 0==000 0000 0000 ~ 0000 0111 1111 1111（黄色的为片选信号）</p><p>第2组芯片地址范围：000==0 1==000 0000 0000 ~ 0000 1111 1111 1111</p><p>第3组芯片地址范围：000==1 0==000 0000 0000 ~ 0001 0111 1111 1111</p><p>第4组芯片地址范围：000==1 1==000 0000 0000 ~ 0001 1111 1111 1111</p><p>0B1FH的地址格式是0000 1011 0001 1111，可知是第二组中的一个地址，这个地址所在芯片最小的为地址为0000 1000 0000 0000，即0800H</p><p>4.某计算机存储器按字节编址，主存地址空间大小为64MB，现用4MB×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（26位）。</p><p>答：MAR要能寻址整个存储器，虽然题目说组成32MB的主存，但是剩余的32MB以后也会用，所以也要考虑，64MB=2<sup>26</sup>，所以最少26位</p><p>5.假设 Cache完成缓存的次数为 2000次，主存完成存取的次数为50次。已知Cache的存储周期为50ns，主存的存储周期为200ns，试求:命中率、平均访问时间、效率。</p><p>答：:one:命中率为  2000/(2000+50)=97%</p><p>:two:t<sub>a</sub>=ht<sub>c</sub>+(1-h)t<sub>m</sub>=0.97*50ns+(1-0.97)*200ns=54.5ns（a表average,c表cache,m表main）</p><p>:three:效率e=t<sub>c</sub>/t<sub>a</sub>=50/54.5=91.7%</p><p>6.一个组相联cache由64个行组成，每组4行。主存储器包含4K个块，每块128字。请表示内存地址的格式。</p><p>答：128字=2<sup>7</sup>，所以字地址位数为7</p><p>Cache共64行，每组4行，所以需要16组，16=2<sup>4</sup>，即只需4位组号地址即可表示16组</p><p>:one: 主存有4k个块，每块128字，所以总共4k*128=2<sup>19</sup>，19-4-7=8即8位标记位</p><p>:two: 主存有4K个块，4k=2<sup>12</sup>，12-4=8，所以标记位需要8位</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610172722721.png"  alt="image-20200610172722721"></p><blockquote><p>注意这些地址是存放在主存的，所以总位数和主存的容量保持一致</p></blockquote><p>7.某容量为256MB的存储器由若干4M×8位的DRAM芯片构成，该DRAM芯片的地址引脚和数据引脚总数是 __________<em><strong>19</strong></em></p><p>答：注意是DRAM采用地址复用，4M=2<sup>22</sup>，地址复用所以11根就行，11+8=19</p><blockquote><p>注意地址线是2<sup>n</sup>(译码器译码)，而数据线是一个线对应一位</p></blockquote><p>8.下列各类存储器中,不采用随机存取方式的是( B)<br>A.EPROM               B.CD-ROM           C.DRAM            D.SRAM</p><p>答：CD-ROM即光盘，采用串行存取方式，它是只读型光盘存储器，不属于只读存储器ROM</p><p>9.某存储器容量为64KB ,按字节编址,地址4000H-5FFFH位ROM区,其余为RAM区,若用8Kx4位的SRAM芯片设计,则需要该芯片的数量为_______14____</p><p>答：这题主要是计算ROM区的容量，4000~5FFFH有5FFF-4000+1=2000H，而2000H=2<sup>13</sup>=8k（转换成二进制1在从右到左第13位(0开始)可类比10是2即2<sup>1</sup>），剩下的56kb为RAM，(56k*8)/(8k*4)=7*2=14</p><p>10.某系统的存储器为2MB，每字块为8个字，每字32位，若Cache为16KB，采用字节编址方式。</p><p>(1)采用直接映射，主存地址格式是什么？</p><p>(2)采用全相联映射，主存地址格式是什么？</p><p>(3)采用16路组相联映射，主存地址格式是什么？</p><p>答：一般都只给每块多少字写字号地址就行，既然这题说明一个字多少位了那么就要有字节地址<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610231019657.png"  alt="image-20200610231019657" style="zoom:80%;" /></p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610231039381.png"  alt="image-20200610231039381" style="zoom:80%;" /><p>16路组相联即每组16块，16kb是2<sup>14</sup>是字节即有2<sup>14</sup>*2<sup>3</sup>=2<sup>17</sup>位，现在需要知道有多少组</p><p>组数=2<sup>17</sup>/2<sup>4</sup>(每组16块)*2<sup>3</sup>(每字块8个字)*2<sup>5</sup>(1个字32位)=2<sup>5</sup>，所以组地址为5位</p><blockquote><p>注意单位要一致，kb是字节，也可以32位换算成字节计算</p><p>注意行号和组号是Cache的，块号地址是主存的，根据Cache的行号或组号把主存的块号映射到Cache中，这也是上面根据Cache容量推行号位数的原因。</p><p>如全相联，给定一个地址，CPU先根据块内地址然后依次和Cache的每行比较(通过标记)，若命中则按块内地址读取相关内容，若未命中就得到主存去读了(Cache命中率)</p></blockquote><p>11.某计算机存储器按字节编址，采用<strong>小端方式存放数据</strong>。 假定编译器规定int型和short型长度分别为32位和16位 ，并且<strong>数据按边界对齐存储</strong>。 某C语言程序段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">  <span class="keyword">int</span> a；</span><br><span class="line">  <span class="keyword">char</span> b；</span><br><span class="line">  <span class="keyword">short</span> c；</span><br><span class="line">&#125;record；</span><br><span class="line">record.a=<span class="number">273</span>；</span><br></pre></td></tr></table></figure><p>若record变量的首地址为0XC008, 则低地址0XC008中内容为（）及record.c的地址是 （ ）</p><p>答：273 = 0X0000 0111(注意是十六进制不是二进制)，采用小端方式存放数据即高字节存放高地址，低字节存放低地址，273的低字节是11，所以低地址存11(往后依次是01,00,00)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610234723093.png"  alt="image-20200610234723093" style="zoom:80%;" /><p>由上图看到0xC00D空了下来，因为题目说数据按边界对齐存储，b后面的c是short2字节，所以c的首地址也得是2的倍数(这样存储器访问一次就可取到数据，若不这样可能存储器一次取的正好是c的一部分，需要再访问一次才能得到完整的c，2的倍数则保证每次都能一次取到)</p><p>所以答案为0X11、0XC00E。</p><p>12.某计算机主存地址空间大小为256 MB， 按字节编址。虚拟地址空间大小为 4 GB，采用页式存储管理，页面大小为 4 KB， TLB（快表）采用全相联映射，有 4 个页表项， 内容如下表所示。则对虚拟地址03FF F180H 进行虚实地址变换的结果是（ ）</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620230255835.png"  alt="image-20200620230255835" style="zoom:80%;" /><p>答：虚存地址空间4GB，则虚地址长度为32位。主存地址空间256MB，则主存地址长度为28位。页面大小4KB，则页内地址长度为<strong>12位</strong>。虚拟地址03FF F180H中<strong>180H</strong>为页内地址(十六进制的3位即二进制的12位和页内地址长度对应)，03FFFH(20位)为虚页号，查TLB(快表)发现，该页在主存中，其实页号为0153H，所以虚实地址变换后的结果为0153 180H(对应主存的28位)。</p><blockquote><p>TLB根据标记找若找到了但是有效位是0代表TLB缺失。若没找到去页表找若找到了但有效位是0代表缺页。</p></blockquote><p>13.某计算机的 Cache 共有 16 块，采用 2 路组相联映射方式，每个主存块大小为 32 字节，按字节编址。主存 129 号单元所在主存块应装入到 Cache 的组号是（ C ）</p><p>A.0B.2C.4D.6</p><p>答：采用2路组相联,所以一共是8组,从0开始,0 1 2 3 4 5 6 7.主存的某一字块按模8映像到Cache中的任一字块中.比如说主存中第0、8、16 字块是映像到Cache里第0组。每个主存块大小32字节，0-31号单元在第0块,32-63号单元在第1块,64-95号单元在第2块,96-127号单元在第3块.由此可见,主存129号单元位于主存中第4块的位置那么对应第4组</p><blockquote><p>注意块号和单元号都是从0开始</p></blockquote><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620233829884.png"  alt="image-20200620233829884" style="zoom:80%;" /><p>14.若数组a及变量k均为int型，int型数据占4B，数据Cache采用直接映射方式，数据区大小为1KB、块大小为16B，该程序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为 （ C ）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;<span class="number">1000</span>; k++)   </span><br><span class="line">a[k] = a[k]+<span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>A.1.25%B.2.5 %C.12.5%D.25%</p><p>答：块大小为16B而int数据4B即每块有4个int数据。a[k] = a[k]+32;首先读取a[k]需访问一次a[k]，之后将结果赋值给a[k]又需要访问一次，即一个int访问两次。第一次访问a[k]未命中，并将该字所在的主存块调入Cache对应的块中。4个整数的各两次访问中只在访问第一个的第一个次时发生缺失，所以缺失率约为1/8=12.5%</p><h1>指令系统</h1><h2 id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200611145349442.png"  alt="image-20200611145349442" style="zoom:80%;" /><p>1.CISC：复杂指令系统计算机  （常用的20%频率占80%）C表Complex</p><p>RISC：精简指令系统计算机        少、固定、小但是寄存器数量多</p><p>2.二地址指令中根据操作数的物理位置，可分为</p><ul><li>SS(存储器-存储器)        速度最慢</li><li>RS(寄存器-存储器)        速度中间</li><li>RR(寄存器-寄存器)       速度最快</li><li>助记：S表Storage即存储器，R表Register即寄存器</li></ul><p>3.指令字长：一条指令所占的存储空间大小即二进制代码位数</p><p>机器字长：计算机一次能直接处理的二进制位数</p><p>若指令字长 = 机器字长，则称它为单字长指令，类比还有半字长指令、双字长指令</p><p>4.数据字和指令字的区别：一个字如果表数据那就是数据字，如果表指令那就是指令字</p><p>5.定长操作码指令：指令字的高位部分固定位数表示操作码，n位操作码最多表示2<sup>n</sup>条指令</p><p>6.不定长操作码设计规则</p><ul><li>不允许较短的是较长的前缀（这样可根据前缀直接判断它是零地址还是一地址…）</li><li>频率较高的指令分配较短的指令</li></ul><p>7.不定长操作码中的扩展位可理解成一个标志，你看到这个标志就知道它是0地址还是1地址…</p><p>8.指令寻址：找到下一条将要执行指令的地址</p><ul><li>顺序寻址（按顺序来如1-&gt;2-&gt;3）</li><li>跳跃寻址            （发生跳跃如1-&gt;2-&gt;6）</li></ul><p>9.数据寻址：找到当前正在执行指令的数据地址   多种寻址方式是为了压缩地址码长度</p><ul><li>隐含寻址       操作数隐含在某寄存器中</li><li>立即寻址       指令字中给出立即数，如MOV AX,1234H                         操作数=A</li><li>直接寻址       指令字中直接给出操作数的有效地址，如MOV AX,[8054H]             EA=A</li><li>间接寻址       指令字中给出的是操作数有效地址<strong>的地址</strong>                                           EA=(A)</li><li>寄存器寻址   指令字中给出寄存器的编号，根据编号取寄存器的数值                    EA=R<sub>i</sub></li><li>寄存器间接寻址  与寄存器寻址不同的是寄存器存的数值是操作数的有效地址      EA=(R<sub>i</sub>)</li><li>偏移寻址     A由指令字给出，R隐含给出           A+R的内容                              EA=A+®<ul><li>相对寻址        PC：程序计数器                                                                      EA=A+(PC)</li><li>基址寻址        BR：基址寄存器   形式地址A可控，(BR)不可控                   EA=A+(BR)</li><li>变址寻址        IX：变址寄存器    形式地址A不可控，IX的内容可控            EA=A+(IX)</li></ul></li></ul><blockquote><p>A表指令字给出的形式地址，(A)表A的内容，EA表有效地址</p></blockquote><p>10.低字节地址为字地址：低位字节的地址是字的起始地址</p><p>0X1234（左边是高字节，右边是低字节(可理解成右面是个位所以小)）</p><p>如0X4000：0X34             0X4001：0X12   即先存字符低位</p><h2 id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2><p>1.假设指令字长固定为16位，试设计一套指令系统满足以下要求:</p><p>1)有15条三地址指令。                             2)有12条二地址指令。<br>3)有62条一地址指令。                             4)有30条零地址指令。</p><p>答：三地址操作码15条用4位操作码即可，剩下的1111用作扩展(即只要看见前四个是1111那它就肯定是二地址指令)</p><p>12条二地址指令又需要4位操作码，即<strong>1111</strong> 0000 ~ <strong>1111</strong> 1011（12条）</p><p>剩余的1111 1100 ~ 1111 1111可用来扩展一地址指令(即看到前缀是它就代表是一地址指令)</p><p>1111 1100 ~ 1111 1111有4种情况后面加4位可达2<sup>4</sup>*4=64，大于一地址的62条，所以</p><p><strong>1111 1100</strong> 0000 ~ <strong>1111 1100</strong> 1111（16条）<strong>1111 1101</strong> 0000 ~ <strong>1111 1101</strong> 1111（16条）</p><p><strong>1111 1110</strong> 0000 ~ <strong>1111 1110</strong> 1111（16条）<strong>1111 1111</strong> 0000 ~ 1111 1111 1101（14条）</p><p>剩余的1111 1111 1110 ～ 1111 1111 1111可用来扩展零地址指令</p><p>再加4位可表示16位，两种拓展码总共表示32种情况而题目0地址只有30条舍去最后两条即可</p><p>1111 1111 1110 0000 ～ 1111 1111 1110 1111（16条）</p><p>1111 1111 1111 0000 ～ 1111 1111 1111 1101（14条）</p><blockquote><p>拓展码代表这个指令是0地址还是1地址，后面的才代表这种地址码有多少条指令</p><p>多地址指令操作码要最短(存放的地址多)，0地址操作码占满16位，而三地址操作码仅占4位，剩下的12位用来存放三个地址</p></blockquote><p>2.设相对寻址的转移指令占两个字节，第一节是操作码，第二字节是相对位移量（用补码表示），若CPU每当从存储器中取出一个字节时，即自动完成PC+1 -&gt; PC。设当前PC的内容为2009H，要求转移到2000H地址，则该转移指令的第二字节的内容是（F5H）</p><p>答：当前PC为2009H，取指令后变为200BH（要先取指令再执行，取两次所以加2）</p><p>2000H-200BH=-11  (相对寻址都是加偏移量，只有偏移量是负的才能使PC数值减小)</p><p>-11的原码为1000 1011，反码为1111 0100，补码为1111 0101即F5H (题目说了用补码表示)</p><p>3.CISC和RISC的区别</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200611173134098.png"  alt="image-20200611173134098"></p><p>答：由于RISC比较简单，因此大多都是在一个时钟周期内完成。特殊的是RISC寄存器此CISC多，因此更能提高计算机速度。CISC更复杂因此种类啥的都比较多。RISC采用组合逻辑控制CISC才会用到微程序控制(可理解为RISC比较简单用不到那么复杂的微程序控制用逻辑电路即可)</p><p>4.某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令29条，二地址指令107条，每个地址字段为6位，则指令字长至少应该是____________24_________</p><p>答：三地址指令有29条，所以它的操作码至少为5位。2<sup>5</sup>=32，它剩余32-29=3种操作码给二地址。而二地址比三地址少了一个地址的位数多了6位给操作码，因此它数量最大达3*64=192。所以指令字长最少为23位（ 6 + 6 +6 + 5 = 23），因为计算机按字节编址，<strong>需要是8的倍数</strong>，所以指令字长至少应该是24位</p><blockquote><p>同样是24位，3地址时是3个地址位+操作码5位，而2地址时是11位操作码和两个地址位</p></blockquote><p>5.某计算机存储器按字编址(16位)读取这条指令后，PC的值自动加1,则说明该指令的长度是( 2 )个字节</p><p>答：主要看按字节编址还是按字编址。按字寻址可理解为把字编上号然后去找编号。PC加1的目的是自动指向下一条指令的地址即加了一个编号也就是16位，而16位占了2个字节</p><p>6.假设变址寄存器R 的内容为1000H，指令中的形式地址为 2000 H；地址 1000H 中的内容为2000H，地址    2000H 中的内容为 3000H，地址 3000 H 中的内容为 4000H， 则变址寻址方式下访问到的操作数是（ D ）。</p><p>A.1000HB.2000HC.3000HD.4000H</p><p>答：变址寻址中EA=A+®。这里的A即形式地址也就是指令中直接给出的，®表寄存器R的内容。EA=2000H+1000H=3000H，而这个3000H代表的是有效地址，根据地址取值即4000H</p><p>7.某计算机有16个通用寄存器，采用32位定长指令字操作码字段（含寻址方式位）为8位，Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式，若基址寄存器可使用任一通用寄存器，且偏移量用补码表示，则Store指令中偏移量的取值范围是  （ A ）</p><p>A.-32768~+32767B.-32767~+32768C.-65536~+65535D.-65535~+65536</p><p>答：采用32位定长指令字,其中操作码为8位,两个地址码一共占用32-8=24位。</p><p>而Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址,有 16 个通用寄存器，则寻址一个寄存器需要4 位。</p><p>源操作数中的寄存器直接寻址用掉4位, 而目的操作数采用基址寻址也要指定一个寄存器,同样用掉 4 位,则留给偏移址的位数为24-4-4=16 位。而偏移址用补码表示,16 位补码的表示范围为-32768~+32767</p><blockquote><p>可类比8位补码表示范围是 -128～ +127，注意负数多一位</p></blockquote><p>8.假定编译器将赋值语句“x=x+3;”转换为指令“add xaddr, 3”，其中xaddr是x对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的TLB，且Cache使用直写（Write Through）方式，则完成该指令功能需要访问主存的次数至少是（ B ）</p><p>A.0B.1C.2D.3</p><p>答：上述指令的执行过程可分为取数、运算和写回过程，取数时读取xaddr可能不需要访问主存而直接访问Cache，但直写方式也即全写法必须要把数据同时写入Cache和主存，因此至少访问1次。</p><h1>中央处理器</h1><h2 id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616172236584.png"  alt="image-20200616172236584"></p><p>1.CPU = 运算器(对数据加工) + 控制器(协调控制各指令序列) + Cache</p><p>2.CPU主要有如下5种功能</p><ul><li><p>指令控制：控制器自动形成指令的地址，并发出取指令的命令，将对应的指令取到控制器中。</p></li><li><p>操作控制：取指令后，产生完成每条指令所需的控制命令</p></li><li><p>时间控制：控制命令产生后，需要对各种控制命令加以时间上的控制</p></li><li><p>数据加工：在执行的过程中，可能需要进行算术运算和逻辑运算</p></li><li><p>中断处理：就是处理中断的能力</p></li></ul><p>3.CPU至少需要六类寄存器，它们分别为</p><ul><li>数据缓冲寄存器(DR)：暂存数据</li><li>指令寄存器(IR)：保存正在执行的一条指令</li><li>程序计数器(PC)：存放第一条指令的地址，每次加一更换成下条指令地址</li><li>数据地址寄存器(AR)：保存当前CPU访问的Cache中单元的地址</li><li>通用寄存器(R<sub>0</sub><sub>R</sub>3~)：存放操作数和各种地址信息（如AX，BX等）</li><li>状态字寄存器(PSW)：保存各种状态条件控制标志，如进位标志、中断标志等</li></ul><p>4.指令周期：CPU取出并执行一条指令的时间，由若干机器周期组成</p><p>机器周期： 完成某个独立操作的时间，由若干时钟周期组成</p><p>时钟周期： 最基本时间单位，由主频决定</p><p>5.指令执行方案：</p><ul><li>单指令周期                  所有指令用相同的执行时间</li><li>多指令周期                  不同类型的指令用不同的步骤完成</li><li><strong>流水线</strong>方案                  指令之间并行执行</li></ul><p>6.CPU主频(时钟频率)对应的是时钟周期，每个机器周期(CPU周期)包含好几个时钟周期</p><p>7.大小顺序为：机器程序=微<strong>程序</strong> &gt; 微<strong>指令</strong> &gt; 微<strong>命令</strong>=微操作</p><p>微<strong>命令</strong>：控制部件向执行部件发出的各种控制命令。而微操作是微命令的执行过程。</p><p>微<strong>指令</strong>：若干微命令的集合</p><p>微<strong>程序</strong>：若干微指令的有序集合，而一条机器指令对应着一个微程序</p><blockquote><p>机器指令由微程序解释执行，微程序由微指令构成，微指令由微命令构成</p></blockquote><p>8.微操作分为相容性和相斥性</p><ul><li>相容性：同一个CPU周期可以并行执行微操作（也叫兼容性）</li><li>相斥性：同一CPU周期不能并行执行微操作</li></ul><p>9.微命令编码</p><ul><li><p>直接控制法：每一位代表一个微命令。</p></li><li><p>直接编码法：相斥的n个微命令可以采用编码法表示，占log<sub>2</sub><sup>(n+1)</sup>位。</p></li><li><p>混合编码法：相斥微命令采用直接编码法，相容微命令采用直接控制法。</p></li></ul><p>10.数据相关分为以下三类，注意读后写(WAR)啥的英文缩写是从后往前读！</p><ul><li><p>RAW(写后读)：应该先写入再读，但现在没写入就读了，出现错误</p></li><li><p>WAR(读后写)：应该先读再写，但现在是写入后再读了，出现错误</p></li><li><p>WAW(写后写)：应该先一个写入另一个再写入，但现在写入的顺序反了，出现错误</p></li></ul><blockquote><p>数据旁路是解决数据相关的一种方法(不用等前一条指令把结果写回寄存器组，结果直接作为输入给下一个指令)</p></blockquote><h2 id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2><p>1.XXX对程序员是透明的表示程序员看不见XXX（不可见就是不可改变）<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616192930989.png"  alt="image-20200616192930989"></p><p>2.判断RAW、WAR…<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617152100918.png"  alt="image-20200617152100918"></p><p>答：:one: 先将结果送到R1，再取出R1参与运算。先写再读即写后读（RAW注意顺序）</p><p>:two: 先读R2再将结果送到R2。先读再写即读后写（WAR）</p><p>:three: 先将第一条指令结果送入R3再将第二条指令结果送到R3，先写后写即写后写</p><p>3.某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有___________________15位___</p><p>答：33个微命令构成5个互斥类，分别包含7、3、12、5和6个微命令，另外每组必须<strong>增加一种不发命令的情况</strong>，则5个段分别需要8、4、13、6和7种状态，分别对应3(2<sup>3</sup>=8)、2、4、3和3位，共15位。</p><p>4.CPU中跟踪指令<strong>后继地址</strong>的寄存器是_______程序计数器______</p><p>5.在微程序控制器中,构成控制信号序列的最小单位是（ B ）</p><p>A.机器指令          B.微命令                       C.微指令                D.微程序</p><p>答：可以看到这几个选项中微命令最小所以选它</p><p>6.在微程序控制器中，执行指令微程序的首条微指令地址是(  D  )得到的。</p><p>A．程序计数器          B．前条微指令          C．μPC          D．指令操作码映射</p><p>答：执行指令微程序的首条微指令地址由指令操作码译码的结果，通过专门的硬件提供。后续地址才会用到程序计数器。</p><p>7.指令流水线有取指(IF)、译码( ID)、执行(EX)、访存(MEM)、写回寄存器堆(WB)五个过程段,共有20条指令连续输人此流水线。</p><p>(1)画出流水处理的时空图，假设时钟周期为100ns。<br>(2)求流水线的实际吞吐率(单位时间里执行完毕的指令数)。<br>(3)求流水线的加速比。</p><p>答：(2)中20条指令花了24个时钟周期的时间直接计算即可（注意时间的单位）</p><p>(3)中的加速比指的是不使用流水线和使用流水线时间的比值也就是所需时钟周期个数之比。</p><blockquote><p>不用流水线就是顺序执行，一个一个来即20*5（一个取值等过程需要一个时钟周期）</p></blockquote><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200622154629411.png"  alt="image-20200622154629411" style="zoom:80%;" /><h1>总线系统</h1><h2 id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617162846524.png"  alt="image-20200617162846524" style="zoom:80%;" /><p>1.总线：是连接多个部件的信息传输线，是各部件共享的传输介质。</p><p>2.总线大致分为三类：</p><ul><li>内部总线：CPU内部各寄存器与运算部件之间的总线</li><li>系统总线：连接其他高速功能部件的总线<ul><li>数据总线：传送各功能部件之间的数据，为双向传输</li><li>地址总线：指定主存和I/O设备接口电路地址，为单向传输</li><li>控制总线：发出各种控制信号</li></ul></li><li>I/O总线：中、低速I/O设备之间互相连接的总线</li></ul><p>3.地址线和数据线复用：地址线和数据线用一条线，一个周期传地址，一个周期传数据</p><p>4.总线宽度：通常指数据总线的根数</p><p>总线带宽：单位时间内总线传输的位数    （可理解为数据传输速率）</p><p>5.总线结构可分为</p><ul><li>单总线结构：将CPU、主存、IO设备连接在一组总线上</li><li>多总线结构：高速、中速、低速设备连接在不同的总线上同时工作，提高效率</li></ul><p>6.CPU-PCI：北桥       PCI-ISA：南桥</p><p>CPU总线：也称CPU-存储器总线</p><p>PCI总线：连接高速的I/O设备</p><p>ISA总线：连接低速I/O设备</p><p>7.串行传送：每次一位传送，不管传多少数据只用一条线</p><p>并行传送：若有32条线，一次就能传送32位，快但是成本高</p><p>8.共享的总线会出现同一时刻多个设备竞争主线控制权，就要从中选择一个</p><ul><li>集中式仲裁 （重点）<ul><li>链式查询：离总线设备越近优先级越高</li><li>计数器查询：地址线的计数值和请求总线的设备地址一致，该设备获得总线控制权</li><li>独立请求：每个设备均有总线请求信号和总线同意信号，根据排队电路判定</li></ul></li><li>分布式仲裁</li></ul><p>9.总线定时指事件出现在总线上的时序</p><ul><li>同步定时：采用统一的时钟信号协调发送和接收方的传送定时关系</li><li>异步定时：同步是在各模块速度一致的情况使用，异步没有公共时钟，采用应答(握手)方式，主模块发请求信号待从模块反馈后开始通信</li></ul><blockquote><p>同步定时比异步定时传输频率高的原因正是其具有统一的公共时钟信号进行同步</p></blockquote><p>10.系统总线标准分为：ISA、EISA、VESA、PCI、PCI-Express（可能出选择题）</p><h2 id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2><p>1.假设某系统总线在一个总线周期中并行传输4B信息，一个总线周期占用两个时钟周期，总线时钟频率为10MHz，则总线带宽是(  20MB/s   )。</p><p>答：总线宽度是单位时间内传输的位数，通常用每秒钟传输的字节数表示。4B即4字节。总线时钟周期为1/10MHz=0.1us，由题意得每0.2us可传输4B。那么每秒可以传输4B/0.2us=4B/0.2*10<sup>-6</sup>s=20MB/s</p><p>2.答：CRT是纯平显示器     CPI是一条指令所需时钟周期个数     RAM是随机存储器<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617182657948.png"  alt="image-20200617182657948"></p><p>3.下列关于多总线结构的叙述中，错误的是 ____<em><strong>D</strong></em></p><p>A.靠近CPU的总线速度较快B.存储器总线可支持突发传送方式</p><p>C.总线之间须通过桥接器相连D.PCI-Express×l6采用并行传输方式</p><p>答：突发传送方式把多个数据单元作为一个独立传输处理，从而最大化设备的吞吐量。一般用支持突发传送方式的总线提高存储器的读写效率。各总线通过桥接器相连，后者起流量交换作用PCI-Express总线都采用串行数据包传输数据</p><p>4.关于提高总线传输率的问题</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200617184609687.png"  alt="image-20200617184609687"></p><p>答：传输率就是每秒传输的数据。增加宽度、提高效率、突发传输(多个单元当做一个传送)都可以提高传输率。地址/数据线复用就是地址和数据线用一个线和每秒传输多少数据没关系。</p><p>5.某同步总线采用数据线和地址线复用方式，其中地址/数据线有32根，总线时钟频率为66MHz，每个时钟周期传送两次数据（上升沿和下降沿各传送一次数据），该总线的最大数据传输率（总线带宽）是 ___<em><strong>C</strong></em></p><p>A.132MB/s       B.264MB/s             C.528MB/s             D.1056MB/s</p><p>答：数据线32根代表一次传输32位即4字节(4B)，66MHz即一秒有66M个时钟周期，而每个周期传两次(上下各一次)，即66M/s×2×4B=528MB/s</p><p>6.下列关于总线设计的叙述中，错误的是 ___<em><strong><strong>A</strong></strong></em></p><p>A.并行总线传输比串行总线传输速度快         B.采用信号线复用技术可减少信号线数量</p><p>C.采用突发传输方式可提高总线数据传输率 D.用分离事务通信方式可提高总线利用率</p><p>答：通常并行一次能传多位数据看着是比串行的速度快，但时钟频率达到一定程度时并行之间的导线会互相影响所以A不是绝对的。</p><p>信号线复用就是线复用不同周期传不一样的信息确实可以减少数量(注意复用)。</p><p>突发传输是一个总线周期可以传输多个存储地址连续的数据也可提高传输率。</p><p>分离事务通信即通过在不传送数据期间释放总线，使得其他申请者能使用总线，以此来提高总线利用率</p><p>7.在集中式总线仲裁中，（B）方式相应时间最快，（A）方式对（C）最敏感</p><p>A.菊花链方式B.独立请求方式C.电路故障D.计数器定时查询</p><p>答：独立请求有请求信号和同意信号最快但也最贵。菊花链(链式)若a<sub>i</sub>位置发生故障则其之后的都不能工作</p><p>8.采用串行接口进行7位ASCII码传送，带有1位奇/偶校验位为1位起始位和1位停止位，当波特率为9600b/s时，字符传送速率为（A）</p><p>A．960 B．873C．1371 D．480</p><p>答：波特率可理解为比特率，即每秒9600比特。7位ASCII和3位起始停止校验共10位，也就是1个字符要占10位。那传输率就等于总比特除1个字符所占比特即9600/10=960</p><h1>外存与IO设备</h1><h2 id="知识点-v7"><a class="header-anchor" href="#知识点-v7">¶</a>知识点</h2><p>1.磁道：就是磁盘的一个同心圆，每个磁道又分为多个扇区(磁道的某个弧段)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200622202745718.png"  alt="image-20200622202745718" style="zoom: 80%;" /><p>2.<strong>道</strong>密度：单位长度有多少个磁<strong>道</strong>数(同心圆)           多少道</p><p>3.<strong>位</strong>密度：单位<strong>磁道</strong>长度能记录的二进制的<strong>位</strong>数      多少位</p><p>4.磁盘容量：面数×每面磁道数×每条磁道的二进制位数</p><p>5.磁盘平均存取时间：T<sub>a</sub>=寻道(找哪一圈)+延迟(找圈中哪个扇区)+传输(读写扇区时间)</p><p>6.数据传输速率：磁盘单位时间向主机传送的字节数（字节/秒）</p><ul><li>D<sub>r</sub>=rN      r为转速即每秒转多少圈(磁道)，N为每个磁道的容量</li><li>D<sub>r</sub>=D*v   D为位密度即单位磁道的位数，v为线速度即每秒能沿着圈走多长</li></ul><p>7.一个磁盘片有两个面，一个磁盘组有很多片(n)，但最上面和最下面的面不能用(即2n-2可用)</p><p>8.显示器刷存带宽=分辨率×每个像素点颜色深度×刷新速率(帧频)</p><h2 id="习题-v7"><a class="header-anchor" href="#习题-v7">¶</a>习题</h2><p>1.磁盘组有6片磁盘， 每片有两个记录面，最上最下两个面不用。存储区域内径(直径)22cm,外径33cm,道密度为40道/cm，内层位密度400位/cm，转速6000转/分。问:</p><p>(1) 共有多少柱面?<br>(2)盘组总存储容量是多少?<br>(3)数据传输率多少?<br>(4)采用定长数据块记录格式，直接寻址的最小单位是什么?寻址命令中如何表示磁盘地址?<br>(5) 如果某文件长度超过一一个磁道的容量，应将它记录在同一个存储面上，还是记录在同一个柱面上?</p><p>答：(1)：有效存储区域为16.5-11=5.5(cm)，道密度为40道/cm，所以共40*5.5=220道即220个圆柱面（就是一面有多少圈）</p><blockquote><p>要用半径而不是直径因为总圈数用半径算即可，另一半和这一半用的是同一个圈</p></blockquote><p>(2)：内层磁道周长为2πR=2X3.14X11= 69.08(cm)     因为给的是内径密度所以算内径周长<br>每道信息量=400位/cmX 69.08cm=27632 位= 3454B    即一圈信息量  位密度×圈长度<br>每面信息量= 3454BX 220= 759880B     一面一共220圈     道信息×道数<br>盘组总容量= 759880BX10=7 598 800B    6片可用的面为10  面信息×面数</p><p>(3)：磁盘数据传输率D<sub>r</sub>= rN                 N为每条磁道容量，N=3454B<br>r为磁盘转速，r=6000转/60秒=100转/秒   （注意换算单位!!!）<br>D,=rN= 100X 3454B= = 345400B/s         每条磁道容量×磁道数量</p><blockquote><p>注意如果要转换成KB/s，除1024而不是除1000</p></blockquote><p>(4)：最小单位是一个记录块（一个扇区）</p><p>此地址格式表示有4台磁盘，每台有16个记录面，每面有256个磁道，每道有16个扇区</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610184101789.png"  alt="image-20200610184101789"></p><blockquote><p>台号(一般为2)—&gt;磁道—&gt;面数—&gt;扇区(一般为4)</p></blockquote><p>(5)：如果某文件长度超过一个磁道的容量，应将它记录在同一个柱面上，因为不需要重新找道，数据读/写速度快。</p><blockquote><p>同一柱面同时读的是多个存储面相同位置的那一圈，同一面那就得在不同圈，需要找道也就是找到那一圈的位置。</p></blockquote><p>2.若磁盘转速为7200 转/分，平均寻道时间为 8ms,每个磁道包含 1000 个扇区，则访问一个扇区的平均<strong>存取</strong>时间大约是（ B ）</p><p>A.8.1msB.12.2msC.16.3msD.20.5ms</p><p>答：存取时间=寻道时间+延迟时间+传输时间</p><p>延迟时间等于旋转半圈的时间，1分钟7200圈，那半圈时间为 (60/7200)/2=4.17ms</p><p>传输时间等于转过一个扇区的时间即为(60/7200)/1000=0.01ms</p><p>所以为4.17+0.01+8=12.18ms，保留一位小数则为 12.2ms</p><p>3.假定一台计算机的显示存储器用DRAM芯片实现，若要求显示分辨率为1600×1200，颜色深度为24位，帧频为85Hz，显存总带宽的50%用来刷新屏幕，则需要的显存总带宽至少约为（ D ）</p><p>A.245Mbit/sB.979Mbit/sC.1958Mbit/sD.7834Mbit/s</p><p>答：刷新所需带宽=分辨率×色深×帧频=1600×1200×24bit×85/s=3916.8Mbit/s</p><p>因为显存总带宽的50%用来刷新屏幕，所以显存总带宽为3916.8Mbit/s×2=7834Mbit/s</p><p>4.磁盘的盘面上有很多半径不同的同心圆，这些同心圆称为( B )</p><p>A、扇区B、磁道C、柱面D、磁表面</p><p>答：可以把磁盘想象成一摞蚊香。磁道就是蚊香的一圈，扇区就是蚊香一圈的某个弧段。而柱面相当于在一摞蚊香中间插个柱子那个圆柱就是柱面。读取信息时同时读取一摞蚊香的同一圈(像老式留音机一样)</p><p>5.已知某磁盘存储器转速为2400转/分，每个记录面道数为200道，平均找道时间为60ms,每道存储容量为96Kb，求磁盘的存取时间与数据传输率。</p><p>答：存取时间=平均查找时间+平均等待时间(半圈时间)=60+(60/2400)*1/2*1000=72.5ms</p><p>Dr=96*(2400/60)=3840Kb/s=480KB/s</p><blockquote><p>注意b是位，B是字节，1B=8b</p></blockquote><h1>输入输出系统</h1><h2 id="知识点-v8"><a class="header-anchor" href="#知识点-v8">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618151509519.png"  alt="image-20200618151509519"></p><p>1.CPU管理外围设备大致有三种方式   下面类比成让10个孩子分别吃两个雪糕的问题</p><ul><li>程序查询方式：先盯着甲吃完一个再给一个然后盯着乙吃完，以此类推</li><li>程序中断方式：每人发一根，谁吃完举手报告再发第二根,等待过程可干其他的事</li><li>直接内存访问(DMA)方式：每人拿两根，都吃完再报告</li></ul><p>2.程序查询方式下，CPU和外围设备之间的传送完全靠计算机程序控制，需要输入输出时，CPU暂停主程序转去执行设备的输入输出服务程序。简单经济但浪费时间。</p><p>DMA方式传送数据，每传送一个数据就要占用一个<strong>存储周期</strong>时间</p><p>DMA方式下DMA控制器从CPU完全接管对总线的控制，数据交换不用经过CPU，直接在内存和I/O设备之间进行。</p><p>3.中断处理过程由硬件和软件完成</p><ul><li>响应中断：有请求就得有响应</li><li>关中断：不再受理其它中断   （要用到状态条件寄存器PSW）</li><li>保存PC：即保存断点，使得中断服务子程序处理完后可以返回原主程序</li><li>保存现场：中断服务子程序修改的寄存器可能会与原寄存器冲突所以先保存 （栈实现）</li><li>设备服务：也就是中断处理程序，该咋处理咋处理</li><li>开中断：表示CPU现在可以受理中断了</li><li>中断返回：先恢复现场(恢复原保存的寄存器和标志位)再恢复断点(返回原主程序)</li></ul><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618154711318.png"  alt="image-20200618154711318" style="zoom:80%;" /><p>从图中我们也可以看出CPU是在结束一个指令周期后检测中断请求信号</p><p>4.中断屏蔽触发器(IM)置0表示CPU可受理外界中断请求，为1表不受理外界中断(1为真即屏蔽)</p><p>单级中断：所有中断源处于同一级，排成一行，离CPU近的优先权高</p><p>多级中断：把中断源分成若干级别，级别高的可以打断级别低的(同级的不行)</p><p>5.中断向量地址是指<strong>中断服务程序入口地址</strong></p><h2 id="习题-v8"><a class="header-anchor" href="#习题-v8">¶</a>习题</h2><p>1.某机器有 4个中断源，中断响应优先级按1→2→3→4降序排列，若想将中断处理<br>次序改为3→1→4→2，则1、2、3、4中断源对应的屏蔽字分别是为___________________</p><p>答：屏蔽字为1表示真即屏蔽了，就是不能打断它的意思，那为0就是可以打断它</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200618160111614.png"  alt="image-20200618160111614"></p><blockquote><p>主要是看中断处理次序，比如1的屏蔽字，1前面有3，即只有3可以打断它，那么把响应优先级的第三位置为0其他均为1。也可看1后面有4和2，意味着1、4、2不能打断他，即把第1、2、4位置1其他置0即可    （两种思想一个结果）</p><p>以后统一用第一种置0的不容易错</p></blockquote><p>2.屏蔽字问题不要被迷惑，只看响应和处理优先级就行<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618161107440.png"  alt="image-20200618161107440"></p><p>答：本题给了中断屏蔽字格式为M<sub>4</sub>M<sub>3</sub>…，那么屏蔽字的第一位到底代表L<sub>4</sub>还是L<sub>0</sub>呢</p><p>M<sub>4</sub>对应L<sub>4</sub>级别也就是最高级别，而最高级别是L<sub>0</sub>，所以第一位代表的是L<sub>0</sub></p><p>其实这种题只看优先级顺序就行，优先级为L<sub>0</sub><sub>L</sub>4<sub>那么屏蔽字每位对应的也是L</sub>0<sub>～L</sub>4~</p><p>可以打断L1的为L4、L0和L2那么把优先级中这些位置置为0即可</p><p>3.某计算机处理器主频为50MHz,采用定时查询方式控制设备A的I/O,查询程序运行一次所用的时钟周期至少为500。在设备A工作期间，为保证数据不丢失，每秒需对其查询至少200次，则CPU用于设备A的I/O时间占整个CPU时间的百分比至少是（  0.2%  ）</p><p>答：每次查询需要500个周期，每秒要查询200次即需要200*500=10<sup>5</sup>个周期</p><p>而主频为50MHz即每秒有50*10<sup>6</sup>个周期</p><p>那么占比为  10<sup>5</sup>/50*10<sup>6</sup>=1/500=0.002= 0.2%</p><p>4.中断服务程序执行过程<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618164623663.png"  alt="image-20200618164623663"></p><p>答：此题选A。注意本题问的是中断服务程序的顺序也就是知识点中图片的右半部分，而保存断点(区别保存现场)和关中断都是中断隐指令的操作，由硬件完成</p><p>5.I/O总线：主机和I/O设备之前通过这个总线连接</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618183826339.png"  alt="image-20200618183826339"  /><p>答：I/O总线即输入输出总线。肯定就得有指出啥指令的命令字。判断其状态的状态字。而且也得有中断，比如键盘输入引起的中断那肯定也得有中断类型号。</p><p>6.下列选项中，能引起外部中断的事件是（ A ）</p><p>A.键盘输入B.除数为0C.浮点运算下溢D.访存缺页</p><p>答：服务于自己就是内中断，服务于别人就是外中断</p><p>A：键盘输入属于外部事件，CPU要想读取外部的输入就得执行中断暂停主程序转而去读取外部键盘输入</p><p>B：除数为0属于异常，也就是内中断，发生在CPU内部。</p><p>C：浮点运算下溢将按机器零处理，不会产生中断。</p><p>D：访存缺页属于CPU执行指令时产生的中断，也不属于外部中断。</p><blockquote><p>此题只需看外部这两个字就可快速选择键盘，其他仨都是CPU内部的东西</p></blockquote><p>7.中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调用不需 要保存其内容的是____________B_________</p><p>A.程序计数器B.程序状态字寄存器C.通用数据寄存器D.通用地址寄存器</p><p>答：程序计数器即PC二者都需要，因为都要返回原主程序。而程序状态字寄存器(PSW)里面保存中断允许标志位和系统工作状态(如进位标志等)等信息。执行中断隐指令时，需要关中断，保护PC需要PC和PSW。所以子程序调用和PSW无关</p><p>8.中断I/O和DMA的比较</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618192202277.png"  alt="image-20200618192202277"></p><p>答：中断处理方式：在I/O设备输入每个数据的过程中，由于无需CPU干预，因而可使CPU与I/O设备并行工作。仅当输完一个数据时，才需CPU花费极短的时间去做些中断处理。因此中断申请使用的是CPU处理时间，发生的时间是在一条指令执行结束之后，数据是在软件的控制下完成传送。而DMA方式与之不同。DMA方式：数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；DMA方式每次申请的是总线的使用权，所传送的数据是从设备直接送入内存的，或者相反；仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。答案D的说法不正确。</p><p>9.某同步总线的时钟频率为100MHz，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发（猝发）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是（ C ）。</p><p>A.20nsB.40nsC.50nsD.80ns</p><p>答：总线频率为100MHz，则时钟周期为10ns。由于支持突发传送可以连续传送地址连续的数据。传送地址10ns，传送128位数据即4个数据40ns，共需50ns。</p><blockquote><p>平常传送一个数据需要两个时钟周期，先传地址再传数据。突发传输下可将多个连续的数据看成一个数据(不是一周期传完是不用专门一个一个传地址)，也就是先传首地址，之后就可每一个周期传一次数据</p></blockquote><p>10.周期挪用方式常用于___________A___方式的输入/输出中。</p><p>A.DMAB.中断C.程序传送D.通道</p><p>答：周期挪用是指利用CPU不访问存储器的那些周期来实现DMA操作，此时DMA可以使用总线而不用通知CPU也不会妨碍CPU的工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;为迎接期末，总结了下知识点，供个人复习使用，仅供参考。&lt;/p&gt;
&lt;p&gt;本文用到的复习资料：&lt;a href=&quot;https://pan.baidu.com/s/1s4kU4UtgG7xiUyssDvuwKw&quot;&gt;点我跳转&lt;/a&gt;，提取码：1l49&lt;/p</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>实验五 图的操作</title>
    <link href="https://zss192.github.io/2020/05/31/%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://zss192.github.io/2020/05/31/%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-05-31T10:00:00.000Z</published>
    <updated>2020-05-31T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>实验性质：综合性实验</h1><h1>要求：</h1><p>（1）采用邻接矩阵/邻接表建立图；<br>（2）采用深度优先/广度优先搜索方式遍历图；<br>（3）编程实现Dijkstra最短路径算法。</p><h1>目的：</h1><p>（1）掌握图的邻接矩阵和邻接表存储方式；<br>（2）掌握图的遍历算法；<br>（3）掌握图的实际应用——最短路径算法。</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***邻接矩阵***//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767                 <span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100                   <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">bool</span> visited[MVNum],visited2[MVNum];    <span class="comment">//初始化标志数组，值为false</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VertexType;         <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType;                  <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  VertexType vexs[MVNum];               <span class="comment">//顶点表</span></span><br><span class="line">  ArcType arcs[MVNum][MVNum];       <span class="comment">//邻接矩阵</span></span><br><span class="line">  <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***邻接表***//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>  //边结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex; <span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span>   <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="keyword">int</span> info; <span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>    //顶点信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    ArcNode * firstarc; <span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VNode,AdjList [MVNum]; <span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的当前顶点数和边数</span></span><br><span class="line"></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph G,<span class="keyword">int</span> u)</span></span>; <span class="comment">//返回顶点u在图G中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDG</span><span class="params">(ALGraph &amp;G)</span></span>;<span class="comment">//邻接表建立无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AL</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span>;<span class="comment">//邻接表表示图的深度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G2)</span></span>;  <span class="comment">//邻接矩阵法建立有向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AM</span><span class="params">(AMGraph &amp;G2,<span class="keyword">int</span> v)</span></span>; <span class="comment">//邻接矩阵深度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(AMGraph G, <span class="keyword">int</span> v0)</span></span>;   <span class="comment">//Dijkstra算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    AMGraph G2;</span><br><span class="line">    <span class="built_in">Menu</span>();</span><br><span class="line">    <span class="keyword">int</span> v=<span class="number">0</span>,v0=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//输入的数字</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">CreateUDG</span>(G);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">DFS_AL</span>(G,v);</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">CreateUDN</span>(G2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">DFS_AM</span>(G2,v);</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">ShortestPath_DIJ</span>(G2,v0);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;输入的位置非法，请重新输入&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph G,<span class="keyword">int</span> u)</span> <span class="comment">//返回顶点u在图G中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == G.vertices[i].data)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(AMGraph G2,<span class="keyword">int</span> u)</span> <span class="comment">//返回顶点u在图G中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G2.vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span>(u==G2.vexs[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>  <span class="comment">//邻接表法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入总顶点数，总边数:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;G.vexnum&gt;&gt;G.arcnum;    <span class="comment">//总顶点数，总边数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入顶点值:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++) <span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;G.vertices[i].data;    <span class="comment">//输入顶点值</span></span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;    <span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入每条边依附的两个顶点:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;G.arcnum;++k) <span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        cin&gt;&gt;v1&gt;&gt;v2;    <span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="built_in">LocateVex</span>(G,v1); <span class="keyword">int</span> j=<span class="built_in">LocateVex</span>(G,v2);</span><br><span class="line">        <span class="comment">//确定v1和v2在G中位置，即顶点在G.vertices中的序号</span></span><br><span class="line">        ArcNode *p1=<span class="keyword">new</span> ArcNode; <span class="comment">//生成一个新的边结点</span></span><br><span class="line">        p1-&gt;adjvex=j;   <span class="comment">//邻接点序号为j</span></span><br><span class="line">        p1-&gt;nextarc=G.vertices[i].firstarc; G.vertices[i].firstarc=p1;</span><br><span class="line">        <span class="comment">//将新节点*p1插入v1的边表头部</span></span><br><span class="line">        ArcNode *p2=<span class="keyword">new</span> ArcNode; <span class="comment">//生成另一个对称的新节点*p2</span></span><br><span class="line">        p2-&gt;adjvex=i;   <span class="comment">//邻接点序号为i</span></span><br><span class="line">        p2-&gt;nextarc=G.vertices[j].firstarc; G.vertices[j].firstarc=p2;</span><br><span class="line">        <span class="comment">//将新节点p2插入顶点v1的边表头部</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;创建成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AL</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//图G为邻接表类型，从第v个顶点出发深度优先搜索遍历图G</span></span><br><span class="line">    cout&lt;&lt;v;visited[v]=<span class="literal">true</span>; <span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true</span></span><br><span class="line">    ArcNode *p=G.vertices[v].firstarc;   <span class="comment">//p指向v的第一个边结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)  <span class="comment">//边结点非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w=p-&gt;adjvex;    <span class="comment">//表示w是v的邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            <span class="built_in">DFS_AL</span>(G,w); <span class="comment">//如果w未访问，则递归调用DFS_AL</span></span><br><span class="line">        p=p-&gt;nextarc;   <span class="comment">//p指向下一个边结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G2)</span>  <span class="comment">//邻接矩阵法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入总顶点数，总边数:&quot;</span>;</span><br><span class="line">    cin&gt;&gt;G2.vexnum&gt;&gt;G2.arcnum;  <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入顶点值:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G2.vexnum; ++i)</span><br><span class="line">       cin&gt;&gt;G2.vexs[i];                         <span class="comment">//依次输入顶点的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G2.vexnum;++i) <span class="comment">//初始化邻接矩阵，边的权值均为极大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;G2.vexnum;++j)</span><br><span class="line">            G2.arcs[i][j] = MaxInt;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输入每条边依附的顶点及权值:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;G2.arcnum;++k)</span><br><span class="line">    &#123; <span class="comment">//构造邻接矩阵</span></span><br><span class="line">      <span class="keyword">int</span> v1,v2,w;</span><br><span class="line">      cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; <span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">      <span class="keyword">int</span> i = <span class="built_in">LocateVex</span>(G2, v1);</span><br><span class="line">      <span class="keyword">int</span> j = <span class="built_in">LocateVex</span>(G2, v2);  <span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">      G2.arcs[i][j] = w;  <span class="comment">//边&lt;v1, v2&gt;的权值置为w2</span></span><br><span class="line">      <span class="comment">//取消下面注释即建立无向图</span></span><br><span class="line">      <span class="comment">//G2.arcs[j][i] = G2.arcs[i][j]; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;创建成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AM</span><span class="params">(AMGraph &amp;G2, <span class="keyword">int</span> v)</span></span>&#123;  <span class="comment">//图G2为邻接矩阵类型</span></span><br><span class="line">  cout&lt;&lt;v;</span><br><span class="line">  visited2[v] = <span class="literal">true</span>;   <span class="comment">//访问第v个顶点</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w&lt; G2.vexnum; w++) <span class="comment">//依次检查邻接矩阵v所在的行</span></span><br><span class="line">        <span class="keyword">if</span>((G2.arcs[v][w]!=MaxInt) &amp;&amp; (!visited2[w]))</span><br><span class="line">            <span class="built_in">DFS_AM</span>(G2, w);</span><br><span class="line">      <span class="comment">//w是v的邻接点，如果w未访问，则递归调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(AMGraph G, <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> S[MVNum];<span class="keyword">int</span> D[MVNum],Path[MVNum];</span><br><span class="line">    <span class="comment">//用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径</span></span><br><span class="line">    <span class="keyword">int</span> n=G.vexnum;                         <span class="comment">//n为G中顶点的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v&lt;n; ++v)</span><br><span class="line">    &#123;               <span class="comment">//n个顶点依次初始化</span></span><br><span class="line">       S[v] = <span class="literal">false</span>;                    <span class="comment">//S初始为空集</span></span><br><span class="line">       D[v] = G.arcs[v0][v];            <span class="comment">//将v0到各个终点的最短路径长度初始化</span></span><br><span class="line">       <span class="keyword">if</span>(D[v]&lt; MaxInt)  Path [v]=v0; <span class="comment">//v0和v之间有弧，将v的前驱置为v0</span></span><br><span class="line">       <span class="keyword">else</span> Path [v]=<span class="number">-1</span>;                <span class="comment">//如果v0和v之间无弧，则将v的前驱置为-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    S[v0]=<span class="literal">true</span>;                     <span class="comment">//将v0加入S</span></span><br><span class="line">    D[v0]=<span class="number">0</span>;                        <span class="comment">//源点到源点的距离为0</span></span><br><span class="line">    <span class="comment">/*―开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/</span></span><br><span class="line">    <span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n; ++i)</span><br><span class="line">    &#123;<span class="comment">//对其余n?1个顶点，依次进行计算</span></span><br><span class="line">        <span class="keyword">int</span> min= MaxInt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">0</span>;w&lt;n; ++w)</span><br><span class="line">          <span class="keyword">if</span>(!S[w]&amp;&amp;D[w]&lt;min)</span><br><span class="line">              &#123;v=w; min=D[w];&#125; <span class="comment">//选择一条当前的最短路径，终点为v</span></span><br><span class="line">        S[v]=<span class="literal">true</span>; <span class="comment">//将v加入S</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">0</span>;w&lt;n; ++w)</span><br><span class="line">           <span class="comment">//更新从v0出发到集合V?S上所有顶点的最短路径长度</span></span><br><span class="line">            <span class="keyword">if</span>(!S[w]&amp;&amp;(D[v]+G.arcs[v][w]&lt;D[w]))</span><br><span class="line">            &#123;</span><br><span class="line">                D[w]=D[v]+G.arcs[v][w];     <span class="comment">//更新D[w]</span></span><br><span class="line">                Path [w]=v;                     <span class="comment">//更改w的前驱为v</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;以v0为起点的图的最短路径为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v0-&gt;v&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(D[i]!=MaxInt) <span class="comment">//可以到达</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;D[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;不可达，无最短路径&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;****by 夏日****&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1-----邻接表建立无向图 &quot;</span>&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2-----邻接表表示图的深度优先搜索遍历&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3-----邻接矩阵建立有向图 &quot;</span>&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4-----邻接矩阵表示图的深度优先搜索遍历&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5-----迪杰斯特拉算法计算最短路径(先用邻接矩阵建立有向图)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;   退出,输入一个负数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>输出示例</h1><p>1.邻接表建立无向图<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200531175649148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>2.邻接表表示图的深度优先搜索遍历<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200531175714907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>3.邻接矩阵建立有向图<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020053117573588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>4.邻接矩阵的深度优先搜索遍历<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200531175756163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>5.迪杰斯特拉算法<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200531175821830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验性质：综合性实验&lt;/h1&gt;
&lt;h1&gt;要求：&lt;/h1&gt;
&lt;p&gt;（1）采用邻接矩阵/邻接表建立图；&lt;br&gt;
（2）采用深度优先/广度优先搜索方式遍历图；&lt;br&gt;
（3）编程实现Dijkstra最短路径算法。&lt;/p&gt;
&lt;h1&gt;目的：&lt;/h1&gt;
&lt;p&gt;（1）掌握图的邻接矩阵和</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zss192.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zss192.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构期末总结</title>
    <link href="https://zss192.github.io/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>https://zss192.github.io/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-31T08:02:00.000Z</published>
    <updated>2020-05-31T08:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>为迎接期末，总结了下知识点，供个人复习使用，仅供参考。</p><p>本文用到的复习资料：<a href="https://pan.baidu.com/s/1M5zHduugp_MMGL9VuNNxYg">点我跳转</a>，提取码：6q5q</p><p>若需要本文markdown文件下方评论留言看到即回</p><h1>绪论</h1><h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><p>1.逻辑结构：数据之间的相互关系。（与计算机无关）</p><ul><li>集合 结构中的数据元素除了同属于一种类型外，别无其它关系。</li><li>线性结构 数据元素之间一对一的关系</li><li>树形结构 数据元素之间一对多的关系</li><li>图状结构或网状结构 结构中的数据元素之间存在多对多的关系</li></ul><p>也可分为线性结构(可理解成一条直线能串起来)和非线性结构</p><p>2.存储结构分为顺序存储结构和链式存储结构（散列、索引）  （与计算机有关）</p><p>3.算法<strong>五个特性</strong>： 有穷性、确定性、可行性、输入、输出</p><p>4.算法设计要求：正确性、可读性、健壮性、高效性。  (好的算法)</p><p>5.typedef可以理解成给现有数据类型起个别名</p><p>例如：typedef struct{…}SqList，即给struct{…}起了个名字叫SqList</p><p>也用于类似于typedef int ElemType; 给int 起个别名叫ElemType即ElemType a;等价于int a;</p><p>这样做的好处是代码中用ElemType定义变量，如果想修改变量类型只需修改typedef ** ElemType即可，而不用一一修改。</p><blockquote><p>我们注意到有时候会有typedef struct LNode{…}LNode，即struct后有个LNode,这是因为如果结构体内部有指向结构体的指针则必须在struct后面加上LNode(单链表里有next指针struct LNode *next)</p></blockquote><p>6.时间复杂度：基本操作的执行次数（可以理解成就看执行了多少次）</p><p>7.研究数据结构就是研究数据的逻辑结构、存储结构及其基本操作</p><p>8.抽象数据类型的三个组成部分为数据对象、数据关系、基本操作。</p><p>9.数据：描述客观事物的符号</p><p>数据元素：是数据的基本单位（元素、结点）</p><p>数据项：组成数据元素的最小单位  （如学生信息表中的学号、姓名等）</p><p>数据对象：相同性质的数据元素的集合（如大写字母）</p><blockquote><p>大小关系为：数据=数据对象 &gt; 数据元素 &gt; 数据项</p></blockquote><p>10.数据结构：相互之间存在一种或多种特定<strong>关系</strong>的数据元素的集合</p><p>11.数据的运算包含：插入、删除、修改、查找、排序</p><p>12.算法：解决某类问题而规定的一个有限长的操作序列</p><p>13.算法的空间复杂度：算法在运行时所需存储空间的度量</p><h2 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.通常要求同一逻辑结构中的所有数据元素具有相同的特性， 这意味着( B )。<br>A. 数据具有同一特点<br>B. 不仅数据元素所包含的数据项的个数要相同， 而且对应数据项的类型要一致<br>C. 每个数据元素都一样<br>D. 数据元素所包含的数据项的个数要相等</p><p>2.以下说法正确的是(  D )。<br>A. 数据元素是数据的最小单位<br>B. 数据项是数据的基本单位<br>C. 数据结构是带有结构的各数据项的集合<br>D. 一些表面上很不相同的数据可以有相同的逻辑结构</p><p>答：数据元素是数据的基本单位，数据项是数据的最小单位，数据结构是带有结构的各数据元素的集合</p><p>3.算法的时间复杂度取决于（ D  ）。<br>A．问题的规模 B．待处理数据的初态C．计算机的配置 D． A 和 B</p><p>答：肯定与问题规模(难和简单的问题)有关，不过也与初态有关，比如某些排序算法，若初始已经排好序可能时间复杂度就会降低。</p><p>4.下列算法时间复杂度为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k*=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j+=<span class="number">1</span>)</span><br><span class="line">        count++;</span><br></pre></td></tr></table></figure><p>答：最外层循环数值为2<sup>0</sup>,2<sup>1</sup>,2<sup>2</sup>…所以假设执行m次即2<sup>m</sup>=n所以外层执行了log<sub>2</sub><sup>n</sup>次</p><p>内层执行了n次，所以时间复杂度为nlog<sub>2</sub><sup>n</sup>（可理解为log<sub>2</sub><sup>n</sup>个n相加）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：第一次是n*fact(n-1)，然后是n*(n-1)*fact(n-2)…一直到n(n-1)(n-2)…2*1</p><p>但是我们要看执行了多少次，也就是函数fact调用了多少次，从n到1也就是n次，所以时间复杂度为O(n)</p><h1>线性表</h1><h2 id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2><p>1.线性结构：第一个无前驱，最后一个无后继，其他都有前驱和后继</p><p>2.顺序表插入一个元素平均移动n/2个元素，删除平均移(n-1)/2个</p><blockquote><p>插入的那一位置需要向后移，删除的位置那一位不用移(直接覆盖)所以删除少1</p></blockquote><p>3.首元结点：存储第一个有效数据元素的结点</p><p>头结点：首元结点之前指向首元结点的结点，为处理方便而设</p><p>头指针：指向第一个结点(有头结点指头结点没有指首元结点)的指针</p><blockquote><p>单链表通常用头指针命名</p></blockquote><p>4.随机存取：可以像数组一样根据下标直接取元素</p><p>顺序存取：只能顺藤摸瓜从前往后一个一个来</p><p>5.单链表加一个前驱指针prior就变成了双向链表</p><p>6.单链表最后一个元素的next指针指向第一个结点即为循环链表  (属于线性表！)</p><p>7.线性表和有序表合并的时间复杂度</p><p>线性表的合并时间复杂度为O(m*n)</p><p>A=(7,5,3,11)，B=(2,6,3)，结果为A=(7,5,3,11,2,6)</p><p>算法需要循环遍历B(O(n))且LocateElem(A)(判断是否与B重复为O(m))所以为O(m*n)</p><p>有序表的合并时间复杂度为O(m+n)</p><p>A=(3,5,8,11)，B=(2,6,8)，结果为A=(2,3,5,6,8,11)</p><p>算法只需同时遍历A和B，然后将还没遍历完的那个直接插到最后就行，所以是相加</p><p>8.顺序表和单链表的比较</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619160333275.png"  alt="image-20200619160333275"></p><p>9.单链表也是线性表(一对一的关系，用绳子可以穿起来)的一种</p><p>10.顺序表存储密度(数据占比/结点占比)等于1，单链表的小于1(因为要存指针)</p><h2 id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.线性表只能用顺序存储结构实现  （X）也可用链式如单链表</p><p>2.在双向循环链表中，在 p指针所指的结点后插入 q所指向的新结点，其修改指针的操作是（ C ）。</p><p>A. p-&gt;next = q; q-&gt;prior = p; p-&gt;next-&gt;prior = q; q-&gt;next = q;</p><p>B. p-&gt;next = q; p-&gt;next-&gt;prior = q; q-&gt;prior=p; q-&gt;next = p-&gt;next;</p><p>C. q-&gt;prior = p; q-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = q; p-&gt;next = q;</p><p>D. q-&gt;prior = p; q-&gt;next = p-&gt;next; p-&gt;next = q; p-&gt;next-&gt;prior = q;</p><p>答：这样的题只能画图看看对不，但是我们可以看到在p的后面插入，那么p-&gt;next就不能非常早的更改否则就会出现找不到的情况，所以排除A,B。C和D画个图试下</p><p>3.在一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的元素个数为（ B）。<br>A. 8 B. 63.5C. 63 D. 7</p><p>答：插入平均移动n/2即63.5，注意不用取整</p><h1>栈和队列</h1><h2 id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2><p>1.栈和队列是操作受限的线性表（1对1）</p><p>2.栈后进先出，只能在栈顶(表尾)插入删除</p><p>3.队列先进先出，队头删除，队尾插入(和平常排队一样排后面)</p><p>4.顺序栈栈空时：S.top=S.base     栈顶指针等于栈底指针</p><p>栈满时：S.top-S.base=S.stacksize   栈顶-栈底等于最大空间</p><p>5.链栈在栈顶操作，用链表头部作为栈顶即可，不需要头结点</p><p>栈空：S=NULL   (指向第一个结点的指针为空)</p><p>6.栈的应用：括号匹配，表达式求值(中缀式求值)，递归转非递归、函数调用</p><p>7.中缀表达式：符号在中间，如a+b，前缀就是+ab（前缀中缀指的是符号的位置）</p><p>8.循环队列队空：Q.front=Q.rear</p><p>队满：(Q.rear+1)%MAXSIZE==Q.front</p><p>队列元素个数：(Q.rear-Q.front+MAXSIZE)<strong>%MAXSIZE</strong></p><p>入队：Q.rear=(Q.rear+1)<strong>%MAXSIZE</strong></p><p>出队：Q.front=(Q.front+1)<strong>%MAXSIZE</strong></p><h2 id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2><p>1.若一个栈以向量V[1…n]存储，初始栈顶指针 top设为n+1, 则元素x进栈的正确操<br>作 是（ C ）。<br>A. top++; V[top]=x;    B. V[top]=x; top++;   C. top–; V[top]= x;    D. V[top]=x; top–;</p><p>答：注意初始top为n+1，而存储下标为v[1]~v[n]，所以就不存在ABD中的v[n+2]或者v[n+1]。应该先让top减一使得指向最后一个地址v[n]，可以把它看成是倒过来的栈，然后存v[n-1]，v[n-2]…</p><p>2.用链接方式存储的队列，在进行删除运算时（  D  ）。<br>A. 仅修改头指针 B. 仅修改 尾指针 C. 头、尾指针都要修改 D. 头、尾指针可能都要修改</p><p>答：由于只能在队头删除，一般只需修改头指针(head=head-&gt;next)即可。但当删最后一个元素时(此时head=rear)删除后(delete p)尾指针就丢失了也得修改</p><p>3.一个递归算法必须包括( B )。</p><p>A. 递归部分C. 迭代部分B. 终止条件和递归部分D. 终止条件和迭代</p><p>答：算法有穷形所以都得有终止条件，递归算法那肯定得有递归部分</p><p>4.最不适合用作队列的链表是( A )。<br>A.只带队首指针的非循环双链表B.只带队首指针的循环双链表<br>C.只带队尾指针的循环双链表    D.只带队尾指针的循环单链表</p><p>答：就看找头尾指针好不好找，A只有头指针还非循环只能从头到尾遍历找到尾指针</p><p>5.表达式a*(b+c)-d的后缀表达式是( B )。<br>A. abcd*±B. abc+*d-C. abc*+d-D. -+*abcd</p><p>答：前缀后缀指的是运算符号位置，先看原运算顺序，先算(b+c)后缀表达式是bc+</p><p>原式然后算*，a*(bc+)后缀表达式是abc+*，然后是abc+*d-</p><p>6.已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第1个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ B ）。</p><p>A.0，0B.0，n-1C.n-1，0D.n-1，n-1</p><p>答：平常入队时先在rear位置赋值，再把rear+1，即rear指向的是队尾元素的下一位置，所以入队时先赋值再加一。但是此题说的是rear指向队尾。也即第一个入队后队尾指向的是第一个元素的位置也即0，所以入队前rear那就是0前面的n-1而front默认都为0</p><h1>串、数组和广义表</h1><h2 id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2><p>1.求next数组和nextval数组</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530144018875.png"  alt="image-20200530144018875"></p><p>当j=1(即第一个字符)时为特殊情况next和nextval均为0</p><p>:one: <strong>next数组</strong>：其值为当前字母前方的最大前后缀+1</p><p>例如：j=3(A)，前面有A，B。没有前后缀即为0，0+1=1</p><p>j=4(B)，前面有ABA，有前缀和后缀A，即前后缀为1，1+1=2</p><p>j=5(A)，前面有ABAB，前后缀为AB，2+1=3//ABA和BAB不等，所以AB为最大前后缀</p><blockquote><p>next[j]=k,它的意思是，当模式串的第j位与主串的第i位失配时，这时主串的位置不回退，而是将模式串退到第k位，再次与主串的第i位进行匹配。</p></blockquote><p>比如主串为ABAA，不匹配时next[4]=2，将模式串中的2位置即B与主串的最后A比较也就达到了不匹配时直接根据前后缀移动的目的</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200619_224917.jpg"  alt="IMG_20200619_224917" style="height:200px;width:400px" /><p>:two: <strong>nextval数组</strong>：两种情况</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530144018875.png"  alt="image-20200530144018875"></p><p>若是不匹配就看next[j]数值，若当前字母和next[j]字母==不等==时，nextval等于上面落下来的next[j]</p><p>若是不匹配就看next[j]数值，若当前字母和next[j]字母==相等==时，nextval值为前面的那个nextval[]</p><blockquote><p>不等就用自家的，相等直接拿过来</p></blockquote><p>例如：j=2，next[2]为1表不匹配时退到下标为1的位置，1的位置是A和当前2对应的B不等用自家的所以next[2]落下来成为nextval[2]</p><p>j=3，next[3]=1表不匹配时模式串回退到下标为1的位置，1的位置是A和当前3对应的A相等，所以把前面的nextval数值拿过来即为nextval[3]</p><p>2.行优先和列优先</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530152310875.png"  alt="image-20200530152310875"></p><p>其实就是行优先就是从上到下先一行一行的存，列优先就是从左到右一列一列的存</p><p>无论是哪个其元素如a[2][3]位置不变(但顺序变了)，行优先就是先存上面2行再到它，列优先就是先存左面3列再存它</p><p>3.广义表是线性表的推广，也称列表（暂时理解成python里的列表）</p><p>4.广义表元素可为原子或子表</p><p>广义表长度：即元素个数(最外层括号里的小括号算一个元素)</p><p>广义表深度：就看有多少对括号就行(注意要将里面的子表全部展开)</p><p>5.表头(Head)和表尾(Tail)：当表非空时，第一个元素为表头其余均为表尾</p><blockquote><p>注意表头是第一个元素所以不带最外层的那个括号，表尾带最外层的括号</p></blockquote><p>例如A=((a,b),c)，表头为(a,b)而表尾为©</p><p>6.串的子串个数为n(n+1)/2+1（1+1+2+…+n，空串也算所以加1）</p><p>7.主串长度为n，模式串长度为m，KMP算法时间复杂度为O(m+n)</p><h2 id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2><p>1.求子串数目</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530201544055.png"  alt="image-20200530201544055"></p><p>2.串 “ababaabab” 的 nextval 为（A）</p><p>A. 010104101 B. 010102101C. 010100011 D0101010</p><p>3.设有数组 A[i,j], 数组的每个元素长度为 3 字节， i 的值为 1~8 , j的值为 1~10 ,<br>数组从内存首地址 BA 开始顺序存放， 当用以列为主存放时， 元素 A[5,8]的存储首地址为（B）</p><p>A. BA+ 141 B. BA+ 180C. BA+222 D. BA+225</p><p>答：以列为主那就是一列一列的存，[5,8]表示这是第8列，前面有7列是存满的，所以这是第(7*8)+5=61个元素，而其地址为BA+(61-1)*3=BA+180</p><blockquote><p>注意要不要减1的问题，可先试下，假如是第二个元素只需要加一倍的3即BA+3所以要减1</p></blockquote><p>4.二维数组 A 的每个元素是由 10 个字符组成的串，其行下标 i=0,1, …,8，列下标j=1,2, , ,10 。若 A 按行先存储，元素 A[8,5] 的起始地址与当 A 按列先存储时的元素（B）的起始地址相同。设每个字符占一个字节。</p><p>A． A[8,5] B ． A[3,10] C. A[5,8] D ． A[0,9]</p><p>答：一定要注意下标是否从0开始，这里共有9行</p><p>行优先，[8,5]前面有8行(0,1,2,3,4,5,6,7共8行)所以是第8*10+5=85个元素</p><p>列优先，[3,10]前面有9列，所以是第9*9+4=85个元素  （注意行标从0开始）</p><blockquote><p>计算总数记住行乘列，列乘行</p></blockquote><p>5.广义表 ((a,b,c,d)) 的表头是（ C ），表尾是（ B ）</p><p>A． a B ． ( ) C． (a,b,c,d) D． (b,c,d)</p><p>答：第一个元素为表头其余均为表尾，所以表尾要带个外层的括号</p><p>6.设广义表 L=((a,b,c)) ，则 L 的长度和深度分别为（ 1和2 ）。</p><p>答：长度就看有多<strong>长</strong>(元素个数)，深度就看有多<strong>深</strong>（括号层数）</p><p>7.以行序为主序方式，将n阶对称矩阵A的下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B［1…(n(n+1))/2-1］中，则在B中确定a<sub>ij</sub> (i&lt;j) 的位置k的关系为(  B   )  。</p><p>A.i*(i-1)/2+jB.j*(j-1)/2+iC.i*(i+1)/2+jD.j*(j+1)/2+i</p><p>答：注意题目说的是确定a<sub>ij</sub> (i&lt;j) ，i要小于j，但存的是下三角元素，假如a<sub>13</sub>=5，确定a<sub>13</sub>的位置就是确定5的位置，而a<sub>13</sub>=a<sub>31</sub>也就是根据i,j (i=1,j=3) 确定a<sub>31</sub>的位置，B中代入即3*1+1=4，而a<sub>31</sub>位置正是4(前面是1+2)</p><h1>树和二叉树</h1><h2 id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2><p>1.满二叉树(最完美最满的状态)   完全二叉树(编号是连续的即最右面缺而且是最后一层缺)</p><p>完全二叉树度为1的结点个数为0或1</p><p>当前结点编号为i，它的左孩子编号为2i，右孩子为2i+1（从1开始时）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604171747502.png"  alt="image-20200604171747502"></p><p>2.二叉树常用性质</p><ul><li>n<sub>0</sub> = n<sub>2</sub>+1 即叶子节点个数为度为2的结点个数加1</li><li>有 n 个结点的完全二叉树的深度为⎣log<sub>2</sub> <sup>n</sup>⎦+1 (没记住可以一个一个试)</li><li>深度为k的二叉树最多有2<sup>k</sup>-1个结点(满二叉树)</li></ul><p>3.二叉树遍历</p><ul><li>先序遍历NLR：根节点-&gt;左子树-&gt;右子树。</li><li>中序遍历LNR：左子树-&gt;根节点-&gt;右子树。必须要有中序遍历才能画出相应二叉树</li><li>后续遍历LRN：左子树-&gt;右子树-&gt;根节点。</li><li>助记：先后中遍历指的是根结点在先还是中还是右，且时间复杂度均为O(n)</li><li>层次遍历：一层一层从上到下，从左到右</li></ul><p>4.二叉树线索化目的是加快查找结点的前驱或后继的速度。实质上就是遍历一次二叉树，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点</p><p>5.哈夫曼树即带权路径最短树，也称最优树。</p><p>树的带权路径长度=树根到各==叶子==结点的路径(树根到该结点要走几步)乘对应权值；通常记作 WPL=∑wi×li</p><p>6.哈夫曼编码是最优前缀编码(任一个编码都不是其他编码的前缀，便于通信减少数据传输)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604205104233.png"  alt="image-20200604205104233" style="zoom: 50%;" /><p>哈夫曼树没有度为1的结点，且不一定是完全二叉树</p><p>7.树的存储结构有三种:双亲表示法、孩子表示法、孩子兄弟表示法,其中孩子兄弟表示法是最常用的表示法,任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。</p><p>8.含有n个节点的二叉树共有(2n)!/(n!*(n+1)!)(常考3个节点共5种)</p><p>9.二叉树的高度是最大层次数(根节点为第一层)</p><p>10.树和二叉树均可以为空(注意树可为空是在严蔚敏教材中可空，有的地方规定不能为空)</p><p>11.树的先序对应二叉树的先序，树的后序对应二叉树的中序(这里的二叉树一般指经孩子兄弟法转换的树)</p><p>12.哈弗曼树属于二叉树有左右子树之分</p><h2 id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2><p><strong>1.</strong></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604180443957.png"  alt="image-20200604180443957"></p><p>答：n<sub>0</sub>= n<sub>2</sub>+1              ==n<sub>1</sub>=0或n<sub>1</sub>=1==        n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>=1001</p><p>**2.**注意题目说的是存储树，而树的存储结构中，孩子兄弟表示法又称二叉链表表示法</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604181448145.png"  alt="image-20200604181448145"></p><p><strong>3</strong>.在一颗度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是______82_。</p><p>答：==任何树中，分支数(度数之和)比节点数少1==</p><p>题目中，分支数为20*4+10*3+1*2+10*1=122，所以有123个节点</p><p>度为0的节点为123-20-10-1-10=82</p><p>也可用公式n<sub>0</sub>=1*n<sub>2</sub>+2*n<sub>3</sub>+3*n<sub>4</sub>+1=1+2*10+3*20+1=82</p><p>**4.**设哈夫曼树中有199 个结点,则该哈夫曼树中有_100__个叶子结点</p><p>答：哈弗曼树没有度为1的结点,n0=n2+1,n0+n2=199,所以n0=100</p><p>**5.**一棵高度为4的完全二叉树至少有______8_个结点</p><p>答：前三层是满二叉树，最后一层只有一个即1+2+4+1=8</p><p><strong>6.</strong></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200605151226555.png"  alt="image-20200605151226555"></p><p>后是左右根，所以C是根，根据中序(左根右)得到DEBA均是C左子根</p><p>根据后序的DABE得到E是DABE的根，再由中序的DEBA得到D是E的左字根，BA是E的右子根</p><p>后序是左右根是AB，而中序是左根右是BA，正好相反则当没有左时正好是右根和根右，即B是根A是右</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200605151625428.png"  alt="image-20200605151625428" style="zoom:50%;" /><p>7.一颗高度为h的完全二叉树至少有_____2<sup>h-1</sup>__个结点</p><p>答：最少的情况就是前h-1层是满的，第h层只有一个。</p><p>即2<sup>h-1</sup>-1(前h-1层)+1(第h层)</p><p>8.有n个结点，高度为n的二叉树的数目为_____2<sup>n-1</sup>__</p><p>答：结点数和高度相同，那么每层都只有一个结点。对于除根节点以外的结点都可能是左子树或右子树，即有两种可能，n-1个2相乘即为2<sup>n-1</sup></p><p>9.二叉树遍历</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607144152588.png"  alt="image-20200607144152588" style="zoom: 50%;" /><p>注意中序先访问C的左而不是先访问W的左</p><p>10.树与森林之间的转换（左孩子右兄弟）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607160958011.png"  alt="image-20200607160958011"></p><p>11.只要LTag为1表明线索为真即它肯定没左子树，为0表示一定有左子树<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200622224221397.png"  alt="image-20200622224221397"></p><h1>图</h1><h2 id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2><p>1.完全图：任意两个顶点都有边，都可达，有向完全图的边数(n*(n-1))是无向完全图的2倍</p><p>2.子图：一个图的一部分称为其子图</p><p>3.回路或环：简单来说就是转个圈</p><p>4.简单回路：转圈的过程不能有重复的点</p><p>5.连通图：图的每两个顶点都有一个到另一个的路径，若都互相可达就是强连通(不一定是完全图)</p><p>6.生成树：含图的全部顶点但只有n-1条边而且是连通图(就是用线串起来所有顶点)</p><p>7.邻接矩阵存储图，若没权值1代表有边，0代表没边。若有权值，有边存权值，没边存无穷大</p><p>8.图中度数之和为边数之和的2倍(一条边被两个顶点共用所以是2倍)</p><p>9.完全图要求每两个顶点都有一条边(无向时)，连通图只要求两个顶点之间存在路径就行(可能是多条边)</p><p>10.深度优先(DFS)即越深越好,直到不能再深了这时退到上一层继续深度优先。类似先序借助于栈(递归)</p><p>广度优先(BFS)就是越广越好类似层次遍历，而且先被访问的节点其子节点也先被访问。借助于队列(存放被访问的结点)</p><p>广度和深度若用邻接矩阵实现时间复杂度为O(n<sup>2</sup>)，邻接表是O(n+e)即O(顶点+边)</p><p>层次遍历就是一层一层从左到右遍历</p><p>树的先序，中序，后序遍历用栈，层次遍历用队列。</p><p>11.最小生成树：加权连通图的最小权值生成树，常用于修一条路使得可到所有顶点且花费最小</p><p>普里姆(Prim)算法：加点不构成回（选可达的最小的点）适合稠密图</p><p>克鲁斯卡尔(Kruskal)算法：加边不构成回（选现有的最小的边）适合稀疏图</p><p>12.v(vertex)是顶点，e(edge)是边</p><p>13.求某个点到其余各点的最短路径：迪杰斯特拉(Dijkstra)算法O(n<sup>2</sup>)（必考）</p><p>求每对顶点的最短路径：弗洛伊德(Floyd)算法O(n<sup>3</sup>)（不常考）</p><p>Floyd：比如求v0到其他顶点，在邻接矩阵中，v0这一行这一列这一主对角线划掉，剩下的中间经过v0看是否比原来路径短，若短则更新</p><p>14.拓扑排序：对有向无环图的顶点的一种排序</p><p>15.AOV网：在有向图中，用顶点表示活动，弧表示活动间的优先关系，则称此有向图为用顶点表示活动的网络（Activity On Vertex Network翻译即在顶点上的活动）</p><p>16.拓扑排序可以解决先决条件问题，比如学院有的课是其他课的基础，怎样排课的问题</p><p>找到入度为0的点输出，删除该点的所有出边，找到剩余点中入度为0的点输出，删除所有出边，重复操作(借用队列实现，若入度为0则入队，当前没有入度为0的点则出队，也可用栈二者结果不同)</p><p>17.AOE网：用顶点表示事件，弧表示活动(注意和AOV网相反)，弧上的权值表示活动持续时间(Activity On Edge Network)。其用于研究 1.完成工程最短时间      2.哪些活动是影响工程的关键</p><p>18.关键路径：即从源点(起始点)到汇点(最终点)最长的路径，路径上的活动称为关键活动</p><p>19.事件的最早发生时间：从前往后找前驱节点到当前节点的最大时间   前面的都完成就发生就是最早</p><p>事件的最迟发生时间：从后往前，后继节点的最迟-边的权值（找其中最小的）超过最迟后面就无法完成</p><p>源点和汇点的最早(都为0)和最晚(路径最大值)相同</p><p>20.有向图的极大强连通子图，称为强连通分量</p><h2 id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2><p>1.<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606154540943.png"  alt="image-20200606154540943"></p><p>答：若要让顶点最少，就是顶点之间的边尽可能的多，最好每两个点都有边，又说是非连通，那么可以一个连通图加一个点。8个顶点有(8*7)/2=28条边加一个点就是非连通，所以是9个点</p><p>2.一个有n个结点的图,最少有(1 )个连通分量,最多有(n )个连通分量</p><p>答：最少就是整体是连通图时，最多就是每个顶点都是孤立的点，那么每个点都是连通分量，注意不可能有0个连通分量，只要有点(哪怕一个)就得是连通分量</p><p>3.N个顶点的无向连通图用邻接矩阵表示时,该矩阵 至少有 2(n-1) 个非零元素。</p><p>答：邻接矩阵非零元素的个数即图的边数之和的2倍(因为无向一条边会被存两次)，图最少有n-1条边，那么矩阵最少有2(n-1)个非零元素</p><p>4.深度优先和广度优先遍历结果均不唯一</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606163156758.png"  alt="image-20200606163156758" style="zoom: 33%;" /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606163249031.png"  alt="image-20200606163249031" style="zoom:67%;" /><p>5.最小生成树问题</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606170558929.png"  alt="image-20200606170558929"  /><p>若是Kruskal算法即加边，第一次选取最小的一条边即(v1,v4)第二次最小的边是8即图中所示三个边</p><p>若是Prim算法即加点法，从V4开始，v4可到达的点中到达v1最小，然后v1和v4所能到达的其他点中(v1,v3)和(v4,v3)最小，所以答案为(v2,v3)</p><p>6.下图共有3种拓扑排序P</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606201807076.png"  alt="image-20200606201807076" style="zoom: 33%;" /><p>7.判断一个图是否有回路除了用拓扑排序还可以用深度优先遍历（若遍历转一圈回到自身即存在回路）</p><p>8.有向图可拓扑排序的判别条件是____不存在环____(拓扑排序的定义就是对有向无环图定义的)</p><p>9.邻接表示例 ，注意存的是顶点的数组下标，即使有权值也是存下标</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220207579.png"  alt="image-20200606220207579" style="zoom:67%;" /><p>10最小生成树计算过程(加边不构成回)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220547569.png"  alt="image-20200606220547569" style="zoom:50%;" /><p>11.最短路径问题</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220836613.png"  alt="image-20200606220836613" style="zoom:50%;" /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220910729.png"  alt="image-20200606220910729" style="zoom:50%;" /><p>12.AOE网问题</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606223846889.png"  alt="image-20200606223846889"></p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606223938221.png"  alt="image-20200606223938221" style="zoom:80%;" /><p>13.由邻接矩阵写成深度优先和广度优先遍历结果</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607110925173.png"  alt="image-20200607110925173" style="zoom: 80%;" /><p>深度优先：要求越深越好。第一行1和7有边，然后由7出发，7和3有边，然后由3出发，3和4有边…</p><p>广度优先：要求越广越好。第一行1和7,1和9有边(所以7和9是1的左右孩子)，然后7和9同时出发…</p><p>14.由邻接表写成深度优先和广度优先遍历结果</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607111541381.png"  alt="image-20200607111541381" style="zoom: 80%;" /><p>广度优先：0出发，0后面有1，2，3。所以遍历结果为0 1 2 3</p><p>深度优先：0出发，0后面第一个为1，由1出发，1后面第一个0访问过了，所以访问2，由2出发。2后面0和1都被访问过了，所以访问3也是 0 1 2 3</p><p>注意深度优先给出邻接表不能画图求，画图比如0后面的1 2 3是没有次序的，先访问哪个都行。但是若给出邻接表那么一定先访问1，所以邻接表求深度优先遍历是唯一的</p><p>虽然这题二者结果相同，但思想不同(越深越好和越广越好)</p><p>15.用DFS遍历一个无环有向图，并在DFS算法退栈返回时打印相应的顶点，则输出的顶点序列是____逆拓扑有序___</p><p>答：比如有A-&gt;B-&gt;C。A先入栈，然后A可到B所以B入栈，B可到C所以C入栈，C没有可达的所以C出栈，然后是BA出栈。而拓扑排序先是A，删除A的出边，B入度为0所以是B，以此类推得到ABC</p><p>这题说的退栈返回打印顶点不是按照深度优先搜索的顺序输出，最先访问的在栈底最后才能弹出</p><p>16.假设一个有n个顶点和e条弧的有向图用邻接表表示，则删除与某个顶点V1相关的所有弧的时间复杂度是（C）</p><p>A.O(n)B.O(e)C.O(n+e)D.O(n*e)</p><p>答：要找到所有指向这个顶点的边，必须得遍历邻接表所有顶点然后遍历每个顶点的边看是否和V1相连，相当于对邻接表遍历，而邻接表遍历深度优先和广度优先都是O(n+e)，注意不是O(n*e)</p><h1>查找</h1><h2 id="知识点-v7"><a class="header-anchor" href="#知识点-v7">¶</a>知识点</h2><p>1.线性表的查找（静态查找表）</p><ul><li>顺序查找   （就是最简单的按顺序一个一个比较）<ul><li>算法简单对表结构无要求</li></ul></li><li>折半查找(二分查找)     （要求是顺序存储有序表）<ul><li>data[mid] == k    找到元素，返回下标mid</li><li>data[mid] &gt; k      high=mid-1 (k比中间值小，要向中间值左边继续找)</li><li>data[mid] &lt; k      low=mid+1 (k比中间值大，要向中间值右边继续找)</li><li>助记：就是找到中间值比较待查元素和中间值，再换个中间值再比较</li><li>优点：比较次数少查找效率高，但不适于经常变动</li></ul></li><li>分块查找   块之间有序(左块最大小于右块最小)，块内任意，另建索引表放每块最大关键字<ul><li>适用于既要快速查找又经常动态变化</li></ul></li></ul><p>2.折半查找的判定树：把中间位置的值作为树根，左边和右边的记录作为根的左子树和右子树</p><p>判定树的中序遍历(左根右)得到的是有序的序列(判定树左子树比根节点小，右子树比根节点大)</p><p>3.加入监视哨(存待查元素)    免去每一步查找都要判断是否查找完的情况，只要读到监视哨就说明没查到</p><p>4.树表的查找（动态(可插入删除)查找表）</p><ul><li>二叉排序树（判定树就是二叉排序树，左比根小右比根大）<ul><li>时间复杂度最好为O(log<sub>2</sub><sup>n</sup>),最差退化成O(n)的顺序查找(如都只有1个分支)</li></ul></li><li>平衡二叉树（AVL） 左右子树高度差绝对值不超过1<ul><li>平衡因子：左子树的高度减去右子树的高度只能为0、-1、+1</li><li>由于后人发现树越矮查找效率越高因此发明了AVL，时间复杂度为O(log<sub>2</sub><sup>n</sup>)</li></ul></li><li>B-树       适合外存文件系统索引</li><li>B+树      适合做文件系统的索引</li></ul><p>5.二叉排序树的删除：缺右补左，缺左补右，不缺左(左子树)中(中序)后(最后一个)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612201608844.png"  alt="image-20200612201608844"></p><p>6.平衡调整：当插入一个结点破坏了平衡性就要调整</p><ul><li>LL型调整</li><li>LR型调整</li><li>RR型调整</li><li>LR型调整</li></ul><p>LL、LR等是对不平衡状态的描述</p><p>若是LL和RR型就把画圈的中间的那个掂起来（想想有重量，另外俩即自己落下去了）</p><p>若是LR和RL型就把画圈的最下面那个掂起来（另外俩也落到它两边）</p><p>若新插入结点在最小不平衡根节点的左(L)孩子的左(L)子树上即为LL型调整</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612205757079.png"  alt="image-20200612205757079" style="zoom:67%;" /><p>若新插入结点在最小不平衡根节点的右®孩子的右左(L)子树上即为RL型调整</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612210339673.png"  alt="image-20200612210339673" style="zoom:67%;" /><p>7.B-树（B树）           m阶B-树，阶数其实就是树的度数  适合外存文件系统索引</p><ul><li>根结点最少有两个分支 （叶子节点除外）</li><li>非终端结点最少有(m/2)<sub>上限</sub>个分支（根节点除外）</li><li>有n个分支的结点有n-1个关键字递增从左到右排列</li><li>叶子结点(失败结点)在同一层可用空指针表示，是查找失败到达的位置</li></ul><p>8.B-树的查找    (类似于二叉树的查找，但是可以有三个或多个方向)</p><p>如查找关键字42。首先在根结点查找，因为42&gt;30，则沿着根结点中指针p[1](下标从0开始)往右下走;因为39&lt;42&lt;45,则沿着子树根结点中指针p[1]往下走，在下层结点中查找关键字42成功，查找结束。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612212801669.png"  alt="image-20200612212801669"></p><p>9.B+树是B-树的变型树，更适合做文件系统的索引。</p><ul><li>叶子结点包含所有关键字从左到右递增且顺序连接</li><li>可从根节点随机查找也可从叶子结点顺序查找  （严格来讲，不算是树了）</li></ul><p>10.散列表：根据给定的关键字计算关键字在表中的地址</p><p>负载(装载因子)：表中结点/表的空间，所以表越满越容易发生冲突</p><p>冲突：不相等的关键字计算出了相同的地址</p><p>同义词：发生冲突的两个关键字</p><p>11.散列表的构造方法</p><ul><li>数字分析法        取关键字的若干位或其组合做哈希地址<ul><li>适用于事先知道关键字集合且关键字位数比散列地址位数多</li></ul></li><li>平方取中法       关键字平方后取中间若干位<ul><li>适用于不了解关键字或难从关键字找到取值较分散的几位</li></ul></li><li>折叠法               分割关键字后将这几部分叠加(舍去进位)<ul><li>适用于散列地址位数少，关键字位数多</li></ul></li><li>除留取余法       取模运算（最常用）</li></ul><p>12.处理冲突的方法</p><ul><li>开放地址法<ul><li>线性探测法        看下一个元素是否为空，当成一个循环表来看  (可能二次聚集)</li><li>二次探测法        原基础加1<sup>2</sup>、-1<sup>2</sup>、2<sup>2</sup>、-2<sup>2</sup>、3<sup>2</sup>…         (可避免二次聚集)</li><li>伪随机探测法    原基础加个伪随机数                                  (可避免二次聚集)</li></ul></li><li>链地址法            相同地址的记录放到同一个单链表中       (可避免二次聚集)</li></ul><h2 id="习题-v7"><a class="header-anchor" href="#习题-v7">¶</a>习题</h2><p>1.折半查找求判定树</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612154158673.png"  alt="image-20200612154158673">答：先找中间的值，(1+20)/2=10，所以1-9为10的左子树(比根小)，11-20为10的右子树。</p><p>比较时先和10比较，若比10小，则比较1-9，那先和谁比较呢，1-9中的中间值为(1+9)/2=5，所以先和5比较(即5和10相连)。如果还比5小，那就要和1-4比了，同样1-4先和谁比呢，1-4的中间值(1+4)/2=2，所以先和2比较(即2和5相连比5小在左边)，其他依次类推</p><p>查找为4的有1、3、6、8、11、13、16、19(依次和10,15,18,19比较所以4次)</p><p>2.用顺序表和单链表表示的有序表均可使用折半查找方法来提高查找速度。 （错）</p><p>答：单链表无法使用折半查找必须是顺序存储，因为要取中间值</p><p>3.二叉排序树序列判定<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612170421688.png"  alt="image-20200612170421688"></p><p>答：二叉排序树序列可理解为一个元素与二叉排序树比较的记录构成的序列。A中91后面是24说明待查元素X比91小所以后面是24，而24后面是94，说明X比24大，但是24前面已经比较过91了(说明已经肯定比91小了)，现在后面又来了个94显然是错的</p><p>4.<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612221437829.png"  alt="image-20200612221437828"></p><p>答：装填因子越大就越满越可能发生冲突。冲突少减少不必要的查找。</p><p>不能完全避免聚集(不是同义词却抢相同地址)只能减少但可避免二次聚集</p><p>5.n个元素的表做顺序查找时,若查找每个元素的概率相同，则平均查找长度为_______(n+1)/2______</p><p>答：总查找次数为1+2+3+…+n=n(n+1)/2，则平均查找长度为N/n=(n+1)/2</p><p>6.如果要求一个线性表既能较快的查找，又能适应动态变化的要求，最好采用 （C）</p><p>A.顺序查找           B.折半查找            C.分块查找                  D.哈希查找</p><p>答：分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块， 就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。严版P198</p><p>7.对22个记录的有序表作折半查找，当查找失败时，至少需要比较 ( 4 ) 次关键字。</p><p>答：4层的满二叉树有2<sup>4</sup>-1=15个结点，5层的有31。题目是22个结点，所以是前4层是满二叉树，第五层不是满的，因此最少4次，最多5次。</p><p>8.下面关于 B- 和 B+ 树的叙述中，不正确的是（ C）。</p><p>A． B- 树和 B+ 树都是平衡的多叉树                    B． B- 树和 B+ 树都可用于文件的索引结构</p><p>C． B- 树和 B+ 树都能有效地支持顺序检索        D． B- 树和 B+ 树都能有效地支持随机检索</p><p>答：B+树支持顺序(从最小的关键字叶子起从左到右)，而B-树因为其叶子结点互相没连接只支持从根节点起随机检索</p><p>9.假定对有序表: (3， 4，5，7，24，30，42，54，63，72，87，95) 进行折半查找,<br>①画出描述折半查找过程的判定树;<br>②若查找元素90，需依次与哪些元素比较?<br>③假定每个元素的查找概率相等，求查找成功时的平均查找长度。</p><p>答：:one: 画判定树一般先画出坐标的判定树，再根据坐标填值即可，注意取下界及low和high的变化<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200616_150334.jpg"  alt="IMG_20200616_150334" style="zoom:80%;" /></p><p>:two: 需要与30、63、87、95比较</p><p>:three: 前3层：1+2*2+4*3=17           第四层：5*4=20</p><p>ASL=（17+20）/ 12 = 3.08            即总查找次数除总个数</p><p>10.设哈希函数 H(K) =3 K mod 11 ，哈希地址空间为 0～ 10 ，对关键字序列（ 32， 13 ，49， 24 ， 38， 21 ， 4， 12），按下述两种解决冲突的方法构造哈希表，并分别求出等概率下查找成功时和查找失败时的平均查找长度 ASLsucc 和 ASLunsucc 。<br>① 线性探测法；<br>② 链地址法。</p><p>答：:one: 散列地址就是若算的关键字为空就放里面，不为空就往后找<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616151221999.png"  alt="image-20200616151221861"></p><p>ASLsucc = （ 1+1+1+2+1+2+1+2 ） /8=11/8</p><p>ASLunsucc =（ 1+2+1+8+7+6+5+4+3+2+1 ） /11=40/11</p><blockquote><p>因为最多成功查8个元素，所以查找成功时分母为8，分子就是每个元素查找的次数之和</p><p>而查找失败时可能计算得到的地址有11种，即分母为11，而关键字为空的查一次就知道失败了(要是有也不会为空)，若不为空要往后找直到找到第一个空元素(说明确实没有这个元素不然该放到这个空着的位置了)</p></blockquote><p>:two: 链地址就是要是地址被占了放后面挂着就行</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200616151916346.png"  alt="image-20200616151916346" style="zoom:80%;" /><p>ASLsucc = （ 1*5+2*3 ） /8=11/8        第一列查一次就知道了第二列要查两次</p><p>ASLunsucc =（ 1+2+1+2+3+1+3+1+3+1+1 ） /11=19/11</p><blockquote><p>失败的情况：查一次若为空说明肯定不存在，若不为空继续向下查直到为空说明到底了查找失败(比如第二行需要查两次，第一次查到为4，第二次查到了空，记住不是查一次就行)</p></blockquote><p>总结：查找成功看位置，查找失败就找空</p><p>11.适宜于对动态查找表进行高效率查找的组织结构是 （C）</p><p>A.有序表 B. 分块有序表C. 三叉排序表 D. 线性</p><p>答：如果线性表既要快速查找又要经常动态变化，则可采用分块查找。而这里说的是动态查找表，分块查找属于静态查找表。动态即要进行修改。有序表和线性不适合修改操作</p><h1>排序</h1><h2 id="知识点-v8"><a class="header-anchor" href="#知识点-v8">¶</a>知识点</h2><p>1.稳定性：排序前和排序后相同关键字的相对位置不发生变化就是稳定的</p><p>若关键字都不重复稳定与否无关紧要，若重复就得具体分析</p><p>2.排序算法的分类                     （以下均是非递减排序的情况）</p><ul><li>插入排序：一个有序的序列，新来的一个插入后仍然有序<ul><li>直接插入排序：第n趟将第n个待排序关键字插入到前面(前n个有序)</li><li>折半插入排序：与直接插入不同的是查找插入位置时用的是折半查找</li><li>希尔排序：对间隔为n的元素排序，缩小间隔直至为1后简单插入排序</li></ul></li><li>交换排序：核心在于交换，比如排高低，每倆换一下后，可能还得换<ul><li>冒泡排序：1号与2号比较然后2号与3号比较…，可确定最大的元素放在最后</li><li>快速排序：选一枢轴，两边指针往中间移(先移右)使得比枢轴小的移到其左边</li></ul></li><li>选择排序：核心是选择，每趟选最大或最小与第一个或最后一个元素交换<ul><li>简单选择排序：第n趟<strong>选择</strong>最小和第n个位置元素<strong>交换</strong></li><li>树形选择(锦标赛)排序：对树如8个选4个最小,4个选倆,2选1,置最小无穷大</li><li>堆排序：调整成堆，根和末尾编号交换输出(每趟得到一个最大值)，重复操作</li></ul></li><li>归并排序：比如每两个归并成一组有序序列，再每两组归并成一大组有序序列</li><li>基数排序：选个位放到对应桶中再选十位放到对应桶中，依次类推</li></ul><p>3.各方法时间空间复杂度和稳定性比较</p><table><thead><tr><th>排序方法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n<sup>2</sup>)  n比较×n移动</td><td>O(1)  插入排序都为1</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n<sup>2</sup>)  n比较×n移动</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td><strong>O(n<sup>1.3</sup>)</strong>  研究证明</td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td>简单选择排序</td><td><strong>O(n<sup>2</sup>)</strong></td><td>O(1)</td><td>不稳定</td></tr><tr><td>锦标赛排序</td><td>O(nlog<sub>2</sub><sup>n</sup>)</td><td><strong>O(n)</strong></td><td>稳定</td></tr><tr><td>快速排序</td><td><strong>O(nlog<sub>2</sub><sup>n</sup>)</strong></td><td><strong>O(log<sub>2</sub><sup>n</sup>)</strong></td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog<sub>2</sub><sup>n</sup>)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog<sub>2</sub><sup>n</sup>)</td><td><strong>O(n)</strong></td><td>稳定</td></tr><tr><td>基数排序</td><td><strong>O(d(n+rd))</strong> 每个记录d个关键字</td><td><strong>O(n+rd)</strong>  n个记录</td><td>稳定</td></tr></tbody></table><p>稳定性：希尔快速选择堆不稳，其他都稳</p><p>时间：</p><ul><li><p>除特例外插入和交换类时间都是O(n<sup>2</sup>)，剩下的时间都是O(nlog<sub>2</sub><sup>n</sup>)</p></li><li><p>可记忆为因为简单所以时间长，快速是最快的不可能是O(n<sup>2</sup>)，希尔是最怪的，基数是最长的</p></li></ul><p>空间：</p><ul><li>树形(锦标赛)分叉多或赛道多而归并要一级一级选占空间最多，快速去掉n，基数去掉d</li><li>其他都是O(1)</li></ul><p>4.关键字较少  ，选取简单的：</p><ul><li>直接插入排序    （最简单，性能最佳）</li><li>冒泡排序</li></ul><p>关键字较多，就用先进的：</p><ul><li>关键字较乱，不要求稳定性：快速排序</li><li>关键字基本有序，就用堆排序或归并排序<ul><li>不要求稳定性：堆排序</li><li>要求稳定性：归并排序</li></ul></li></ul><p>关键字多但都较小：基数排序</p><h2 id="习题-v8"><a class="header-anchor" href="#习题-v8">¶</a>习题</h2><p>1.设待排序的关键字序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}, 试分别写出使用以下排序方法， 每趟排序结束后关键字序列的状态</p><p>①直接插入排序    (第n趟将第n个待排序关键字插入到前面已排序的序列)</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>[2] 12 16 30 28 10 16* 20 6 18    第一趟第一个有序</p><p>[2 12] 16 30 28 10 16* 20 6 18    第2个即12与前面的排序<br>[2 12 16] 30 28 10 16* 20 6 18    第3个即16与前面的排序<br>[2 12 16 30] 28 10 16* 20 6 18    前4个有序<br>[2 12 16 28 30] 10 16* 20 6 18    前5个有序<br>[2 10 12 16 28 30] 16* 20 6 18<br>[2 10 12 16 16* 28 30] 20 6 18<br>[2 10 12 16 16* 20 28 30] 6 18<br>[2 6 10 12 16 16* 20 28 30] 18<br>[2 6 10 12 16 16* 18 20 28 30]    最后一个与前面的排序  (查找插入位置是依次比)</p><p>②折半插入排序</p><p>排序过程同①，只不过查找插入位置用的是折半查询</p><p>③希尔排序   (增量选取5,3,1)</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>10 2 16 6 18 12 16* 20 30 28 （增量选取 5）第1个和第6个排序，第2和第7…</p><p>6 2 12 10 18 16 16* 20 30 28 （增量选取 3）第1和第4，第2和第5…</p><p>2 6 10 12 16 16* 18 20 28 30 （增量选取 1)   就是直接插入排序</p><p>④冒泡排序     （1号与2号比较然后2号与3号比较…，可确定最大的元素放在最后）</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>2 12 16 28 10 16* 20 6 18 [30]    12与2比较交换，12和16比较，16和30比较…<br>2 12 16 10 16* 20 6 18 [28 30]     每一趟确定一个最大的放最后<br>2 12 10 16 16* 6 18 [20 28 30]     第3趟确定3个最大<br>2 10 12 16 6 16* [18 20 28 30]     确定4个最大</p><p>2 10 12 6 16 [16* 18 20 28 30]<br>2 10 6 12 [16 16* 18 20 28 30]<br>2 6 10 [12 16 16* 18 20 28 30]<br>2 6 10 12 16 16* 18 20 28 30]</p><p>⑤快速排序  （选一枢轴，两边指针往中间移使得比枢轴小的移到其左边,先移右指针）</p><blockquote><p>原序列为{12,2,16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p><u>12</u>      [6 2 10] 12 [28 30 16* 20 16 18]   先让右指针往左移<br><u>6</u>        [2] 6 [10] 12 [28 30 16* 20 16 18 ] 一般选第一个为枢轴<br><u>28</u>      2 6 10 12 [18 16 16* 20 ] 28 [30 ]<br><u>18</u>      2 6 10 12 [16* 16] 18 [20] 28 30<br><u>16*</u>    2 6 10 12 16* [16] 18 20 28 30<br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200618_230219.jpg"  alt="IMG_20200618_230219"></p><p>⑥简单选择排序         （第n趟<strong>选择</strong>最小和第n个位置元素交换）</p><blockquote><p>原序列为{12,2,16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>[2] 12 16 30 28 10 16* 20 6 18    最小的2和第一个12交换<br>[2 6 ]16 30 28 10 16* 20 12 18    最小的6和第二个12交换<br>[2 6 10 ]30 28 16 16* 20 12 18    最小的10和第三个16交换<br>[2 6 10 12] 28 16 16* 20 30 18    最小的12和第四个30交换<br>[2 6 10 12 16] 28 16* 20 30 18<br>[2 6 10 12 16 16* ]28 20 30 18<br>[2 6 10 12 16 16* 18 ]20 30 28<br>[2 6 10 12 16 16* 18 20 ]28 30<br>[2 6 10 12 16 16* 18 20 28] 30</p><p>⑦堆排序</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>18 12 16 20 28 10 16* 2 6 [30]        得到最大值30，继续调整交换</p><p>6 20 16 18 12 10 16* 2  [28 30]       得到两个最大值，继续调整交换</p><p>…        由于此题没有答案，下面类似</p><p>建堆(按编号即层次遍历)然后调整堆(从最后面的非叶子结点向前选择最大的放到根，可能不止调整一趟)。</p><p>然后交换根和最后一个编号(注意不是最小)，再重新调整交换重复操作</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200623_154830.jpg"  alt="IMG_20200623_154830"></p><p>⑧二路归并排序   (每两个归并成一组有序序列，再每两组归并成一组有序序列)</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>[2 12]  [16 30]  [10 28]  [16 * 20]  [6 18]     每两个合为一组<br>[2 12 16 30]   [10 16* 20 28]   [6 18]           每两组即四个合为一组<br>[2 10 12 16 16* 20 28 30]   [6 18]                每两组即八个合为一组<br>[2 6 10 12 16 16* 18 20 28 30 ]</p><p>2.树形选择(锦标赛)排序</p><blockquote><p>原序列为{49,38, 65, 97, 76, 13, 27, 49*}</p></blockquote><p>对树8个选4个最小,4个选倆,2选1,选中13为最小输出，置最下面13为无穷大，重复操作</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619124723912.png"  alt="image-20200619124723912" style="zoom:80%;" /><p>3.基数排序</p><blockquote><p>原序列为{278,109,063,930,589,184,505,269,008,083}</p></blockquote><p>准备10个桶，第一趟收集按个位放到对应桶中</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619125123102.png"  alt="image-20200619125123102"></p><p>即结果为：930 063 083 184 505 278 008 109 589 269   (个位已经有序)</p><p>第二趟收集按十位放到对应桶中</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619125230169.png"  alt="image-20200619125230169"></p><p>即结果为：505 008 109 930 063 269 278 083 184 589</p><p>我们可以看到最低2位已经有序了，只需再来一趟收集即可，就不写了</p><p>4.根据结果写排序方法</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619130413770.png"  alt="image-20200619130413770"></p><p>5.对 n 个不同的排序码进行冒泡排序， 在元素无序的情况下比较的次数最多为( )</p><p>答：比较次数最多时，第一趟比较 n-1 次，第二趟比较 n-2 次, 最后一趟比较 1<br>次，即 (n-1)+(n-2)+…+1= n(n-1)/2</p><p>6.若一组记录的排序码为（ 46, 79 ， 56，38 ， 40，84），则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为（）</p><p>答：左右设两指针，右指针先移，84比46大不移动，40比46小所以40覆盖46的位置，然后该左边的指针移动了，79比46大，所以移到空着的原40的位置。然后该右指针移了，38比46小所以38覆盖空着的原79位置，左边的56比46大移到空着的原38，然后将46放到空着的原56即可。结果为：40,38,46,56,79,84</p><p>7.数据表中有 10000 个元素，如果仅要求求出其中最大的 10 个元素，则采用 (  D  )<br>算法最节省时间</p><p>A．冒泡排序 B ．快速排序 C．简单选择排序 D．堆</p><p>答：堆用大根堆一趟选取一个最大的最快</p><p>冒泡每两个比较，有10000个肯定慢。快速是选枢轴，再左右移动也慢</p><p>简单选择每一趟都几乎快遍历一遍也肯定慢</p><p>8.下列排序算法中， （ A ）不能保证每趟排序至少能将一个元素放到其最终的位置上</p><p>A．希尔排序 B ．快速排序 C. 冒泡排序 D．堆</p><p>答：快速排序的每趟排序能将作为枢轴的元素放到最终位置；冒泡排序的每趟排序能将最大或最小的元素放到最终位置；堆排序的每趟排序能将最大或最小的元素放到最终位置。而希尔排序只是对间隔为n的元素排序所以不确定。</p><blockquote><p>这种让选择哪个排序的需要知道每个排序大致是咋排的就很好选择</p></blockquote><h1>各类型存储结构</h1><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200531145418964.png"  alt="image-20200531145418964"></p><h2 id="顺序表"><a class="header-anchor" href="#顺序表">¶</a>顺序表</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171311253.png"  alt="image-20200529171311253" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100<span class="comment">//顺序表可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *elem;<span class="comment">//存储空间的基地址(例如用L.elem[0]取元素)</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>L.elem[i]取值 //L.length-1=&gt;i&gt;=0，如元素为1,2,3，L.length=3，i=0,1,2</p><h2 id="单链表"><a class="header-anchor" href="#单链表">¶</a>单链表</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170625502.png"  alt="image-20200529170658268" style="zoom: 67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//结点的指针域，指向下一结点</span></span><br><span class="line">&#125;LNode,*LinkList;<span class="comment">//LinkList为指向结构体LNode的指针类型(相当于LNode *)</span></span><br></pre></td></tr></table></figure><p>若带头结点，空表条件为L-&gt;next==NULL（L为头指针指向头结点永不为空）</p><p>若不带头结点，空表条件为L==NULL</p><h2 id="双向链表"><a class="header-anchor" href="#双向链表">¶</a>双向链表</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170658268.png"  alt="image-20200529170625502" style="zoom: 67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span><span class="comment">//指向直接前驱</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span><span class="comment">//指向直接后继</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure><h2 id="顺序栈"><a class="header-anchor" href="#顺序栈">¶</a>顺序栈</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171934385.png"  alt="image-20200529172642776" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100<span class="comment">//顺序栈存储空间的初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base;<span class="comment">//栈底指针</span></span><br><span class="line">    SElemType *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;<span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>栈空：S.top==S.base//首尾指针相同</p><p>栈满：S.top-S.base==S.stacksize//尾-首等于最大容量即为满</p><h2 id="链栈"><a class="header-anchor" href="#链栈">¶</a>链栈</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171646363.png"  alt="image-20200529171934385" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类似，类似操作受限的单链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span><span class="comment">//指向下一结点</span></span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure><p>链栈一定是没有头结点，所以栈空的条件为：S==NULL</p><h2 id="循环队列"><a class="header-anchor" href="#循环队列">¶</a>循环队列</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172331805.png"  alt="image-20200529171646363" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">//队列可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;<span class="comment">//存储空间的基地址</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">//头指针（只是有指针的作用,例如用Q.base[Q.front]取元素）</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>队空：Q.front==Q.rear//首尾指针相同</p><p>//尾指针指向的为最后一个元素的下一个地址(永远为空)，所以+1</p><p>队满：(Q.rear+1)%MAXSIZE==Q.front</p><h2 id="链队"><a class="header-anchor" href="#链队">¶</a>链队</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172642776.png"  alt="image-20200529172331805" style="zoom: 67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只看第一个定义和单链表类似，不同的是第二个设了队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span><span class="comment">//指向下一结点</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front;<span class="comment">//队头指针(相等于QNode *front)</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p>队空：Q.front=Q.rear</p><p>由于串、数组、广义表的存储结构不是重点在这里就不再列出其存储结构</p><h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2><p>栈和队列除了链栈都有头尾指针</p><h2 id="顺序二叉树-不常用"><a class="header-anchor" href="#顺序二叉树-不常用">¶</a>顺序二叉树(不常用)</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-100.png"  alt="image-100" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100<span class="comment">//二叉树的最大结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSIZE]<span class="comment">//0号存储根结点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><h2 id="二叉链表-常用"><a class="header-anchor" href="#二叉链表-常用">¶</a>二叉链表(常用)</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-102.png"  alt="image-102" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;<span class="comment">//结点数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a class="header-anchor" href="#线索二叉树">¶</a>线索二叉树</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-103.png"  alt="image-103" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="keyword">int</span> LTag,RTag;<span class="comment">//左右标志</span></span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure><h2 id="孩子兄弟二叉树"><a class="header-anchor" href="#孩子兄弟二叉树">¶</a>孩子兄弟二叉树</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-104.png"  alt="image-104" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tyrpedef <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>//又称二叉链表表示，本质存的是树用类似存二叉树的方法存</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span><span class="comment">//即左是孩子右是兄弟</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h2 id="邻接矩阵"><a class="header-anchor" href="#邻接矩阵">¶</a>邻接矩阵</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606155925297.png"  alt="image-20200606155925297" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767   <span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100       <span class="comment">//最大顶点数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;   <span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType;       <span class="comment">//假设边的权值类型为整型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">  VertexType vexs[MVNum];       <span class="comment">//顶点表 </span></span><br><span class="line">  ArcType arcs[MVNum][MVNum];   <span class="comment">//邻接矩阵 </span></span><br><span class="line">  <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的顶点数和边数 </span></span><br><span class="line">&#125;AMGraph; </span><br></pre></td></tr></table></figure><h2 id="邻接表"><a class="header-anchor" href="#邻接表">¶</a>邻接表</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606160127426.png"  alt="image-20200606160127426" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意存的是顶点数组下标不是存的顶点本身</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">ArcNode</span> &#123;</span>   <span class="comment">//边结构</span></span><br><span class="line">      <span class="keyword">int</span>  adjvex;                              <span class="comment">//该边所指向的顶点位置</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span>  <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>   <span class="comment">//指向下一条边的指针</span></span><br><span class="line">      OtherInfo    info;                     <span class="comment">//和边相关的信息</span></span><br><span class="line">&#125; ArcNode；</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100</span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>  <span class="title">VNode</span>&#123;</span> <span class="comment">//顶点结构</span></span><br><span class="line">     VertexType   data;              <span class="comment">//顶点信息</span></span><br><span class="line">     ArcNode   * firstarc;         <span class="comment">//指向依附该顶点的第一条弧的指针</span></span><br><span class="line">&#125; VNode, AdjList[MVNum];  </span><br><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span> &#123;</span>                 <span class="comment">//图结构</span></span><br><span class="line">      AdjList   vertics ;           <span class="comment">//邻接表</span></span><br><span class="line">      <span class="keyword">int</span>  vexnum, arcnum;  <span class="comment">//顶点数和弧数</span></span><br><span class="line">      <span class="keyword">int</span>  kind;                       <span class="comment">//图的种类</span></span><br><span class="line">&#125;  ALGraph;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;为迎接期末，总结了下知识点，供个人复习使用，仅供参考。&lt;/p&gt;
&lt;p&gt;本文用到的复习资料：&lt;a href=&quot;https://pan.baidu.com/s/1M5zHduugp_MMGL9VuNNxYg&quot;&gt;点我跳转&lt;/a&gt;，提取码：6q5q&lt;/p</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zss192.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数据结构" scheme="https://zss192.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>实验四 二叉树的操作</title>
    <link href="https://zss192.github.io/2020/04/23/%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://zss192.github.io/2020/04/23/%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-23T09:07:00.000Z</published>
    <updated>2020-04-23T09:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>实验性质：综合性实验</h1><h1>要求：</h1><p>(1) 采用二叉链表结构建立二叉树；<br>(2) 编程实现二叉树的先序、中序、后序和层序遍历；<br>(3) 编程实现非递归中序遍历<br>(3) 编程实现：求二叉树的高度和叶子结点个数；</p><h1>目的：</h1><p>（1）掌握二叉树的二叉链表存储方式及二叉树的特征；<br>（2）验证二叉树在二叉链表存储结构下遍历操作的实现；</p><h1>示例</h1><ul><li><p>创建<br>输入 ：ABC##DE#G##F###<br>该输入对应的树如图所示<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423170621698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p></li><li><p>先序   屏幕输出  A B C D E G F</p></li><li><p>后序   屏幕输出  C G E F D B A</p></li><li><p>中序   屏幕输出  C B E G D F A</p></li><li><p>(中序非递归还需看源代码)</p></li><li><p>层序   屏幕输出  A B C D E F G</p></li><li><p>深度   屏幕显示 深度为5</p></li></ul><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QElemType BiTree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SElemType BiTree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义二叉链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//循环队列类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="comment">//顺序栈定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>;    <span class="comment">//构造空二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span>;<span class="comment">//先序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>; <span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>; <span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>;   <span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BiTree T)</span></span>;  <span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse2</span><span class="params">(BiTree T)</span></span>;    <span class="comment">//非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span>; <span class="comment">//计算二叉树深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree bt)</span></span>;  <span class="comment">//计算叶子节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>; <span class="comment">//顺序栈的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>;<span class="comment">//顺序栈的入栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>; <span class="comment">//删除栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>;</span><br><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(SqStack S)</span></span>; <span class="comment">//取栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;<span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span></span>;<span class="comment">//元素入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,QElemType &amp;e)</span></span>;<span class="comment">//元素出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;<span class="comment">//销毁队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>;<span class="comment">//队列判空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    <span class="built_in">InitBiTree</span>(T);</span><br><span class="line">    <span class="built_in">Menu</span>();</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//输入的数字</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入字符序列,#代表空：&quot;</span>;</span><br><span class="line">            <span class="built_in">CreateBiTree</span>(T);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;创建成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;先序遍历结果为：&quot;</span>;</span><br><span class="line">            <span class="built_in">PreOrderTraverse</span>(T);</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;中序遍历结果为：&quot;</span>;</span><br><span class="line">            <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;后序遍历结果为：&quot;</span>;</span><br><span class="line">            <span class="built_in">PostOrderTraverse</span>(T);</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;层序遍历结果为：&quot;</span>;</span><br><span class="line">            <span class="built_in">LevelOrderTraverse</span>(T);</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;非递归中序遍历结果为：&quot;</span>;</span><br><span class="line">            <span class="built_in">InOrderTraverse2</span>(T);</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;二叉树深度为：&quot;</span>&lt;&lt;<span class="built_in">Depth</span>(T)&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;二叉树叶子结点个数为：&quot;</span>&lt;&lt;<span class="built_in">LeafCount</span>(T)&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;输入的位置非法，请重新输入&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="keyword">new</span> BiTNode;</span><br><span class="line">    T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;data = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> <span class="comment">//先序遍历建立二叉链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);    <span class="comment">//递归创建左子树</span></span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);    <span class="comment">//递归创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> <span class="comment">//先序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;T-&gt;data;  <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild); <span class="comment">//先序遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> <span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">        cout&lt;&lt;T-&gt;data;  <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span>   <span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">        cout&lt;&lt;T-&gt;data;  <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BiTree T)</span>  <span class="comment">//层序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//将每一层的节点分别入队列，然后分别读取，读取后继续将它们的子节点入队，所以保证是按照一层一层来遍历的</span></span><br><span class="line">    BiTree P=T;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);   <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">if</span>(P)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">EnQueue</span>(Q,P);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DeQueue</span>(Q,P);   <span class="comment">//出队列</span></span><br><span class="line">            cout&lt;&lt;P-&gt;data;</span><br><span class="line">            <span class="keyword">if</span>(P-&gt;lchild)</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,P-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span>(P-&gt;rchild)</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,P-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DestroyQueue</span>(Q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse2</span><span class="params">(BiTree T)</span>    <span class="comment">//非递归中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack S;<span class="built_in">InitStack</span>(S);</span><br><span class="line">    BiTree p=T;BiTree q=<span class="keyword">new</span> BiTNode;</span><br><span class="line">    <span class="keyword">while</span>(p||!<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Push</span>(S,p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=<span class="built_in">GetTop</span>(S);</span><br><span class="line">            <span class="built_in">Pop</span>(S,q);</span><br><span class="line">            cout&lt;&lt;q-&gt;data;</span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m=<span class="built_in">Depth</span>(T-&gt;lchild);</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">Depth</span>(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)</span><br><span class="line">            <span class="keyword">return</span>(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span>(n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)          <span class="comment">//结点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!T-&gt;lchild&amp;&amp;!T-&gt;rchild)      <span class="comment">//没有子节点了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LeafCount</span>(T-&gt;lchild)+<span class="built_in">LeafCount</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> <span class="comment">//顺序栈的初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        S.top=S.base;   <span class="comment">//top初始化为base,空栈</span></span><br><span class="line">        S.stacksize=MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span><span class="comment">//顺序栈的入栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base==S.stacksize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *S.top++=e;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType e)</span> <span class="comment">//删除栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e=*--S.top;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=S.base)</span><br><span class="line">        <span class="keyword">return</span> *(S.top<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//构造一个空队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base=<span class="keyword">new</span> QElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span><span class="comment">//元素入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXSIZE==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q.base[Q.rear]=e;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,QElemType &amp;e)</span><span class="comment">//元素出队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e=Q.base[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span><span class="comment">//判断队列是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//销毁队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q.rear=Q.front;</span><br><span class="line">    <span class="keyword">delete</span> Q.base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;****by 夏日****&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1-----创建二叉链表 &quot;</span>&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2-----先序遍历&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3-----中序遍历&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4-----后序遍历&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5-----层序遍历&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6-----非递归中序遍历&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;7-----二叉树深度&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;8-----二叉树叶子结点个数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;   退出,输入一个负数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>输出示例</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423170805868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1>写在最后</h1><p>本文章仅供个人复习使用，如有错误，请联系我更正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实验性质：综合性实验&lt;/h1&gt;
&lt;h1&gt;要求：&lt;/h1&gt;
&lt;p&gt;(1) 采用二叉链表结构建立二叉树；&lt;br&gt;
(2) 编程实现二叉树的先序、中序、后序和层序遍历；&lt;br&gt;
(3) 编程实现非递归中序遍历&lt;br&gt;
(3) 编程实现：求二叉树的高度和叶子结点个数；&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zss192.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zss192.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zss192.github.io/2020/04/07/%E5%AE%9E%E9%AA%8C%E4%B8%89%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://zss192.github.io/2020/04/07/%E5%AE%9E%E9%AA%8C%E4%B8%89%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-07T07:17:00.000Z</published>
    <updated>2020-04-07T07:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>实验性质：验证性实验</h1><h1>要求：</h1><p>（1）编程实现栈的以下基本操作：建栈，取栈顶元素，入栈，出栈。<br>（2）编程实现队列的以下基本操作：建队列，取队头元素，入队，出队。</p><h1>目的：</h1><p>（1）掌握栈的顺序存储结构、链式存储结构及其基本操作；<br>（2）掌握队列的顺序存储结构、链式存储结构及其基本操作。</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>; <span class="comment">//顺序栈的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> v)</span></span>;<span class="comment">//顺序栈的入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S)</span></span>; <span class="comment">//删除栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTop</span><span class="params">(SqStack S)</span></span>; <span class="comment">//取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayS</span><span class="params">(SqStack S)</span></span>;    <span class="comment">//显示顺序栈元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>; <span class="comment">//循环队列的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="keyword">int</span> v)</span></span>; <span class="comment">//循环队列的入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;   <span class="comment">//循环队列的出队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetHead</span><span class="params">(SqQueue Q)</span></span>;    <span class="comment">//取循环队列的队头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayQ</span><span class="params">(SqQueue Q)</span></span>;    <span class="comment">//显示循环队列元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    <span class="built_in">Menu</span>();</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">int</span> v,i;    <span class="comment">//插入元素的数值和操作代码</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要插入的值：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;v;</span><br><span class="line">            <span class="built_in">Push</span>(S,v);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">Pop</span>(S);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">GetTop</span>(S);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">DisplayS</span>(S);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要插入的值：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;v;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q,v);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">DeQueue</span>(Q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">GetHead</span>(Q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">DisplayQ</span>(Q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">            <span class="built_in">Menu</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;输入的位置非法，请重新输入&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> <span class="comment">//顺序栈的初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;存储分配失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        S.top=S.base;   <span class="comment">//top初始化为base,空栈</span></span><br><span class="line">        S.stacksize=MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,<span class="keyword">int</span> v)</span><span class="comment">//顺序栈的入栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base==S.stacksize)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈已满&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *S.top++=v;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;入栈成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S)</span> <span class="comment">//删除栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈为空栈,无法出栈&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        --S.top;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;出栈成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetTop</span><span class="params">(SqStack S)</span> <span class="comment">//取栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=S.base)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈顶元素为:&quot;</span>&lt;&lt;*(S.top<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈为空栈&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayS</span><span class="params">(SqStack S)</span>    <span class="comment">//显示顺序栈元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前栈为空栈&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈中元素为&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(S.top!=S.base)</span><br><span class="line">            cout&lt;&lt;*--S.top&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> <span class="comment">//循环队列的初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base=<span class="keyword">new</span> QElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;存储分配失败&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="keyword">int</span> v)</span> <span class="comment">//循环队列的入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXSIZE==Q.front)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;循环队列已满，无法插入&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q.base[Q.rear]=v;</span><br><span class="line">        Q.rear=(Q.rear+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;入队成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q)</span>   <span class="comment">//循环队列的出队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;循环队列为空，无法出队&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q.front=(Q.front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;出队成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetHead</span><span class="params">(SqQueue Q)</span>    <span class="comment">//取循环队列的队头</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front!=Q.rear)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;队头为：&quot;</span>&lt;&lt;Q.base[Q.front]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayQ</span><span class="params">(SqQueue Q)</span>    <span class="comment">//显示循环队列元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front!=Q.rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(((Q.front+i)%MAXSIZE)!=Q.rear)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;Q.base[(Q.front+i)%MAXSIZE]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;循环队列为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;**by 夏日 https://blog.csdn.net/zss192**&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1-----顺序栈入栈&quot;</span>&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2-----顺序栈出栈&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3-----取栈顶元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4-----显示顺序栈元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5-----循环队列入队&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6-----循环队列出队&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;7-----取循环队列队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;8-----显示循环队列元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;9-----清屏&quot;</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;   退出,输入一个负数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>写在最后</h1><p>本文章仅供个人复习使用，如有错误，请联系我更正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1&gt;实验性质：验证性实验&lt;/h1&gt;
&lt;h1&gt;要求：&lt;/h1&gt;
&lt;p&gt;（1）编程实现栈的以下基本操作：建栈，取栈顶元素，入栈，出栈。&lt;br&gt;
（2）编程实现队列的以下基本操作：建队列，取队头元素，入队，出队。&lt;/p&gt;
&lt;h1&gt;目的：&lt;/h1&gt;
&lt;p&gt;（1）掌握栈的顺序</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zss192.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zss192.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zss192.github.io/2020/03/30/%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://zss192.github.io/2020/03/30/%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-03-30T08:45:00.000Z</published>
    <updated>2020-03-30T08:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1>实验性质：设计性实验</h1><h1>要求</h1><p>（1）编程实现单链表的以下基本操作：建立单链表，查找单链表，插入单链表，删除单链表。<br>（2）采用单链表结构编程实现：两个有序单链表的归并运算。</p><h1>目的：</h1><p>（1）掌握线性表的链式存储结构；<br>（2）掌握单链表及其基本操作的实现。</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结点存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>; <span class="comment">//单链表的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> x,<span class="keyword">bool</span> y)</span></span>;<span class="comment">//单链表的插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i)</span></span>; <span class="comment">//删除指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(LinkList &amp;L)</span></span>; <span class="comment">//显示单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LocateElem</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> x)</span></span>;   <span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTwoList</span><span class="params">(LinkList &amp;LA,LinkList &amp;LB)</span></span>;  <span class="comment">//生成两个单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;LA,LinkList &amp;LB,LinkList &amp;LC)</span></span>;   <span class="comment">//合并有序单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;LinkList LA;LinkList LB;LinkList LC;</span><br><span class="line">    <span class="built_in">Menu</span>();</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    <span class="keyword">int</span> h,k;    <span class="comment">//获取输入的指定位置和插入数据的元素</span></span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//输入的数字</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的位置：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要插入的值：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">InsertList</span>(L,h,k,<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的位置：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            <span class="built_in">DeleteList</span>(L,h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">Display</span>(L);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的值：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">LocateElem</span>(L,k);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">CreateTwoList</span>(LA,LB);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">MergeList</span>(LA,LB,LC);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;输入的位置非法，请重新输入&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> x,<span class="keyword">bool</span> y)</span><span class="comment">//插入单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p=L; <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; (j&lt;i<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置非法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LNode *s;</span><br><span class="line">        s=<span class="keyword">new</span> LNode;</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next=s;</span><br><span class="line">        <span class="keyword">if</span>(y)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;插入元素成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i)</span><span class="comment">//删除指定元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p=L;<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next) &amp;&amp; (j&lt;i<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||(j&gt;i<span class="number">-1</span>))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置非法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LNode *q=p-&gt;next;</span><br><span class="line">        p-&gt;next=q-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;元素删除成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(LinkList &amp;L)</span><span class="comment">//显示单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前单链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;单链表元素为：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LocateElem</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data!=x)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;成功找到元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;元素不存在&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTwoList</span><span class="params">(LinkList &amp;LA,LinkList &amp;LB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitList</span>(LA);</span><br><span class="line">    <span class="built_in">InitList</span>(LB);</span><br><span class="line">    <span class="built_in">InsertList</span>(LA,<span class="number">1</span>,<span class="number">2</span>,<span class="literal">false</span>);<span class="built_in">InsertList</span>(LA,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">false</span>);<span class="built_in">InsertList</span>(LA,<span class="number">3</span>,<span class="number">5</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">InsertList</span>(LB,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">false</span>);<span class="built_in">InsertList</span>(LB,<span class="number">2</span>,<span class="number">5</span>,<span class="literal">false</span>);<span class="built_in">InsertList</span>(LB,<span class="number">3</span>,<span class="number">7</span>,<span class="literal">false</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;成功创建两个单链表&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LA为&quot;</span>;<span class="built_in">Display</span>(LA);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LB为&quot;</span>;<span class="built_in">Display</span>(LB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;LA,LinkList &amp;LB,LinkList &amp;LC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *pa=LA-&gt;next;LNode *pb=LB-&gt;next;</span><br><span class="line">    LC=LA;</span><br><span class="line">    LNode *pc=LC;</span><br><span class="line">    <span class="keyword">while</span>(pa&amp;&amp;pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pa;</span><br><span class="line">            pc=pa;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pb;</span><br><span class="line">            pc=pb;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next=pa?pa:pb;</span><br><span class="line">    <span class="keyword">delete</span> LB;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;合并成功,LC&quot;</span>;</span><br><span class="line">    <span class="built_in">Display</span>(LC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1-----在单链表指定位置插入元素 &quot;</span>&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2-----删除单链表指定位置元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3-----显示单链表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4-----查找元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5-----自动创建两个单链表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6-----合并两个单链表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;   退出,输入一个负数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>写在最后</h1><p>本文章仅供个人复习使用，如有错误，请联系我更正。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1&gt;实验性质：设计性实验&lt;/h1&gt;
&lt;h1&gt;要求&lt;/h1&gt;
&lt;p&gt;（1）编程实现单链表的以下基本操作：建立单链表，查找单链表，插入单链表，删除单链表。&lt;br&gt;
（2）采用单链表结构编程实现：两个有序单链表的归并运算。&lt;/p&gt;
&lt;h1&gt;目的：&lt;/h1&gt;
&lt;p&gt;（1）掌</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zss192.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zss192.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zss192.github.io/2020/03/19/%E5%AE%9E%E9%AA%8C%E4%B8%80%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://zss192.github.io/2020/03/19/%E5%AE%9E%E9%AA%8C%E4%B8%80%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-03-19T06:45:00.000Z</published>
    <updated>2020-03-19T06:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="实验性质：设计性实验"><a class="header-anchor" href="#实验性质：设计性实验">¶</a>实验性质：设计性实验</h2><h2 id="要求"><a class="header-anchor" href="#要求">¶</a>要求</h2><p>编程实现顺序表的以下基本操作：建立顺序表，修改顺序表，插入顺序表，删除顺序表。<br>采用顺序表结构编程实现：两个集合的运算：交集/并集/差集。</p><h2 id="实验目的"><a class="header-anchor" href="#实验目的">¶</a>实验目的</h2><p>通过该实验，深入理解顺序表的逻辑结构、物理结构等概念，掌握顺序表基本操作的编程实现，注意顺序表插入、删除等操作过程中数据元素的移动现象，学生编写程序时，要考虑程序的健壮性，熟练掌握通过函数参数返回函数结果的办法。</p><h2 id="实验内容"><a class="header-anchor" href="#实验内容">¶</a>实验内容</h2><p>编程实现顺序表下教材第二章定义的线性表的基本操作，最好用菜单形式对应各个操作，使其变成一个完整的小软件。</p><h2 id="参考界面"><a class="header-anchor" href="#参考界面">¶</a>参考界面</h2><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319172016748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h2 id="验收-测试用例"><a class="header-anchor" href="#验收-测试用例">¶</a>验收/测试用例</h2><p>通过菜单调用各个操作，测试点：</p><ul><li><p>插入数据(位置， 数据)，要测插入位置不合法的情况（0,1）、（2,1），正确插入4个数据（1，2）、（1，1）、（3,3）</p></li><li><p>显示顺序表中的数据，屏幕输出1， 2， 3；</p></li><li><p>判空，屏幕输出顺便表非空；</p></li><li><p>顺便表长度，屏幕输出3；</p></li><li><p>获取指定位置元素，要测指定位置在【1，3】范围之外的情况和之内的情况；</p></li><li><p>定位，输入：4， 输出：不存在，输入2，输出位置为2；</p></li><li><p>求直接前驱，要测求第一个元素的前驱、不存在顺序表中的元素的直接前驱，其他元素的直接前驱；</p></li><li><p>求直接后继，要测最后一个元素的后继、不存在顺序表中的元素的直接后继，其他元素的直接后继；</p></li><li><p>删除，要测位置在【1，3】范围之外的情况和之内的情况；</p></li><li><p>清空操作后再测长度；</p></li></ul><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  //定义结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line">SqList L; <span class="comment">//声明变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">//顺序表的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListLength</span><span class="params">(SqList &amp;L)</span></span>;  <span class="comment">//顺序表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmptyList</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">//清空顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PointList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span>;   <span class="comment">//获取指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BeforList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span>;   <span class="comment">//求前驱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AfterList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span>;   <span class="comment">//求后继</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>;<span class="comment">//顺序表的插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span>; <span class="comment">//删除指定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(SqList &amp;L)</span></span>;  <span class="comment">//显示顺序表的结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postion</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span>;   <span class="comment">//定位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Menu</span>();</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    <span class="keyword">int</span> h,k;    <span class="comment">//获取输入的指定位置和插入数据的元素</span></span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//输入的数字</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">ClearList</span>(L);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">EmptyList</span>(L);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">ListLength</span>(L);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的位置：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            <span class="built_in">PointList</span>(L,h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的位置：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            <span class="built_in">BeforList</span>(L,h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的位置：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            <span class="built_in">AfterList</span>(L,h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的位置：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要插入的值：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">InsertList</span>(L,h,k);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的位置：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;h;</span><br><span class="line">            <span class="built_in">DeleteList</span>(L,h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="built_in">Display</span>(L);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入要操作的值：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">Postion</span>(L,k);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;输入的位置非法，请重新输入&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.elem = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span>(!L.elem)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;初始化有误&quot;</span>&lt;&lt;endl;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListLength</span><span class="params">(SqList &amp;L)</span><span class="comment">//顺序表的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;顺序表的长度为&quot;</span>&lt;&lt;L.length&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmptyList</span><span class="params">(SqList &amp;L)</span><span class="comment">//判断顺序表是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;顺序表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;顺序表非空，长度为&quot;</span>&lt;&lt;L.length&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span><span class="comment">//清空顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;顺序表已清空&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PointList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||i&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的数字非法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素为&quot;</span>&lt;&lt;L.elem[i<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BeforList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span><span class="comment">//求前驱</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||i&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入数字非法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第一个元素不存在前驱&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素的前驱为&quot;</span>&lt;&lt;L.elem[i<span class="number">-2</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AfterList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span><span class="comment">//求后继</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||i&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入数字非法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;最后一个元素不存在后继&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;个元素的后继为&quot;</span>&lt;&lt;L.elem[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span><span class="comment">//插入顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置非法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">            L.elem[j+<span class="number">1</span>]=L.elem[j];  <span class="comment">//从第i+1个元素开始都往后移一位</span></span><br><span class="line">        L.elem[i<span class="number">-1</span>]=x;  <span class="comment">//第i个元素设为x</span></span><br><span class="line">        ++L.length;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;插入元素成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span><span class="comment">//删除指定元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||i&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置非法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=L.length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            L.elem[j<span class="number">-1</span>]=L.elem[j];  <span class="comment">//从第i+1个元素起依次往前移一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        --L.length;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;成功删除元素&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(SqList &amp;L)</span><span class="comment">//显示顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前顺序表为空表&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;顺序表为：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;L.length<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;L.elem[j]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;L.elem[L.length<span class="number">-1</span>];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postion</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> a = <span class="literal">false</span>;<span class="comment">//判断是否能找到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;L.length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==L.elem[j])</span><br><span class="line">        &#123;</span><br><span class="line">             a=<span class="literal">true</span>;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;元素所在位置为：&quot;</span>&lt;&lt;j+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!a)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;不存在&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1-----清空线性表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2-----判断线性表是否为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3-----求线性表长度&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4-----获取线性表指定位置元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5-----求前驱&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6-----求后继&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;7-----在线性表指定位置插入元素 &quot;</span>&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;8-----删除空线性表指定位置元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;9-----显示线性表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;10----定位&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;   退出,输入一个负数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a class="header-anchor" href="#写在最后">¶</a>写在最后</h2><p>本文章仅供个人复习使用，如有错误，请联系我更正。</p><blockquote><p>参考：<a href="https://blog.csdn.net/qq_41998273/article/details/88695510">实验一 顺序表的操作（数据结构实验）</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;实验性质：设计性实验&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#实验性质：设计性实验&quot;&gt;¶&lt;/a&gt;实验性质：设计性实验&lt;/h2&gt;
&lt;h2 id=&quot;要求&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#要求&quot;&gt;¶&lt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://zss192.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zss192.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
