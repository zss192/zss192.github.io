<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>计算机组成原理期末总结 | 夏日 の blog</title><meta name="description" content="计算机组成原理期末总结"><meta name="keywords" content="计算机专业课"><meta name="author" content="夏日"><meta name="copyright" content="夏日"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="计算机组成原理期末总结"><meta name="twitter:description" content="计算机组成原理期末总结"><meta name="twitter:image" content="https://zss192.github.io/img/post/7.jpg"><meta property="og:type" content="article"><meta property="og:title" content="计算机组成原理期末总结"><meta property="og:url" content="https://zss192.github.io/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="夏日 の blog"><meta property="og:description" content="计算机组成原理期末总结"><meta property="og:image" content="https://zss192.github.io/img/post/7.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://zss192.github.io/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"><link rel="prev" title="实验六 查找和排序的实现" href="https://zss192.github.io/2020/06/12/%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"><link rel="next" title="实验五 图的操作" href="https://zss192.github.io/2020/05/31/%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"欢迎你,来到,我的博客","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><script src="/js/sakura.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="夏日 の blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">计算机系统概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">运算方法和运算器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-v2"><span class="toc-number">3.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-v2"><span class="toc-number">3.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">多层次的存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-v3"><span class="toc-number">4.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-v3"><span class="toc-number">4.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-v4"><span class="toc-number">5.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-v4"><span class="toc-number">5.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">中央处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-v5"><span class="toc-number">6.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-v5"><span class="toc-number">6.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">总线系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-v6"><span class="toc-number">7.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-v6"><span class="toc-number">7.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">外存与IO设备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-v7"><span class="toc-number">8.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-v7"><span class="toc-number">8.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">输入输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-v8"><span class="toc-number">9.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-v8"><span class="toc-number">9.2.</span> <span class="toc-text">习题</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post/7.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">夏日 の blog</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">计算机组成原理期末总结</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-09 22:32:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-09</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-09 22:32:00"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">16.2k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 53 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1>写在前面</h1>
<p>为迎接期末，总结了下知识点，供个人复习使用，仅供参考。</p>
<p>本文用到的复习资料：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1s4kU4UtgG7xiUyssDvuwKw">点我跳转</a>，提取码：1l49</p>
<p>若需要本文markdown文件下方评论留言看到即回</p>
<h1>计算机系统概论</h1>
<h2 id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608144821042.png"  alt="image-20200608144821042" style="zoom: 67%;" />
<p>1.时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。</p>
<p>2.主频(时钟频率)：每秒钟含有多少个时钟周期(1.2GHz即每秒钟含有1.2x10<sup>9</sup>个时钟周期)。</p>
<p>3.CPI：一条指令所需要的时钟周期个数。</p>
<p>4.MIPS：每秒钟能执行多少个==100万==条指令。<br>
<img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020021912112010.png"  alt=""></p>
<p>5.MFLOPS：每秒百万次浮点操作次数。</p>
<p>6.CPU执行时间：TCPU=In×CPI×TC (指令条数*一条指令需要几个时钟周期*时钟周期长度)</p>
<blockquote>
<p>In：执行程序中==指令==的==总数==</p>
<p>CPI(Clock Cycle Per Instruction)：执行每条==指令所需==的平均时钟==周期个数==<br>
TC：时钟==周期时间==的长度</p>
</blockquote>
<p>7.吞吐量：计算机某一时间间隔内能够处理的信息量(能吞多少)</p>
<p>8.响应时间：从事件开始到事件结束的时间,也称执行时间.</p>
<p>7.冯●诺依曼型计算机设计思想主要有两项:</p>
<ul>
<li>将十进制改为二进制,从而太太简化了计算机的结构和运算过程;</li>
<li>存储程序的思想，将<strong>程序与数据</strong>一起存储在计算机内，使得计算机的全部运算成为真正的自动过程。</li>
</ul>
<blockquote>
<p>存储（程序）并按（地址）顺序执行，这是冯•诺依曼型计算机的工作原理。</p>
</blockquote>
<p>8.用嘴(一句一句最后生成目标程序)来解释，用手(一步到位最后不生成目标程序)来编译</p>
<p>编译程序将高级语言转换为机器代码再执行，解释程序用源程序直接解释，解释一句执行一句不用转换成机器代码。所以编译要比解释速度快</p>
<p>9.控制器可根据==不同的周期==(取指周期或者执行周期)来区分该地址的存储单元存储的是数据还是指令。</p>
<h2 id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2>
<p>1.假定机器M的时钟频率为200MHz，程序P在机器M上的执行时间为12s。对P优化，将所有乘4指令都换成了一条左移两位的指令，得到优化后的程序P’。若在M上乘法指令的CPI为102，左移指令的CPI为2，P的执行时间是P’执行时间的1.2倍，则P中的乘法指令条数为_______4x10<sup>6</sup>________</p>
<p>答：P’的执行时间为10s,比12少了2s，由时钟频率得每秒有2x10<sup>8</sup>个时钟周期，即少了4x10<sup>8</sup>个时钟周期</p>
<p>每条左移指令比乘法指令少了100个时钟周期，那么乘法指令个数即总共少的时钟周期/每条指令少的时钟周期</p>
<blockquote>
<p>p和p’的时间差是因为指令被替换了，而所有被替换的指令个数就是乘法指令个数</p>
</blockquote>
<p>2.此题MIPS为400</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608152105898.png"  alt="image-20200608152105898"></p>
<p>答：平均CPI=2x0.5+ 3x0.2+4x0.1+5x0.2=3，即执行一个指令平均需要3个周期</p>
<p>MIPS为每秒可执行的百万条指令数，1.2GHZ为1200MHZ即一秒有1.2*10<sup>9</sup>个周期，总周期=一个指令所需周期*有多少指令。1200/3=400（M=10<sup>6</sup>,G=10<sup>9</sup>）</p>
<p>3.程序P在机器M上的执行时间是20s，编译优化后，P执行的指令数减少到原来的70%，而CPI增加到原来的1.2倍，则P在M上的执行时间是_______16.8s____</p>
<p>答：CPI即执行一条指令所需的时钟周期数。假设M机器原时钟周期为x,原CPI为y, P程序的指令数为z，可得P程序执行时间为xyz= 20s。</p>
<p>编译优化后M机器的CPI变为1.2y, P程序的指令数变为0.7z,则P程序执行时间为1.2*0.7xyz,故其执行时间为<br>
16.8s。</p>
<p>4.某工作站采用时钟频率f为15MHz，处理速率为10MIP/S的处理机来执行一个已知混合程序。假定每次存储器存取为1周期延迟，此计算机的有效CPI是_______1.5_____________，假定将处理机的时钟频率提高到30MHz，但存储器子系统速率不变。这样，每次存储器存取需要两个时钟周期，如果30%指令每条只需要一次存储存取，而另外5%每条需要两次存储存取，还假定已知混合程序的指令数不变，并与原工作站兼容，则改进后的处理机性能相比原来的_______提高_____________</p>
<p>答：CPI即每个指令需多少周期，已知每秒有15*10<sup>6</sup>个周期，每秒可以处理10*10<sup>6</sup>个指令，那么总周期数/总指令数即为CPI</p>
<p>15*10<sup>6</sup>/10*10<sup>6</sup>=1.5    (注意和后面那个1周期延迟没有关系，不要被他迷惑，这个周期延迟已经被计算在前面的10MIP/s中了)</p>
<p>处理性能是否提高就看处理速率是否提高了。30%需要一次存取，由于每次存取增加了1周期延迟，那么这30%就得增加一个周期，而同理另外5%需要增加两周期。则CPI<sub>new</sub>=CPI<sub>原</sub>+30%*1+5%*2=1.9  (原CPI已经包括原来的1周期延迟，只需将计算新增的即可)</p>
<p>又已知现在每秒有30*10<sup>6</sup>个周期，那么处理速率为总周期数/每指令所需周期数=30×10<sup>6</sup>/(1.9×10<sup>6</sup>)= 15.79MIP/S，所以提高了</p>
<p>5.假定计算机M1和M2具有相同的指令集体系结构，主频分别为1.5 GHz和1.2 GHz。在M1和M2_上运行某基准程序P，平均CPI分别为2和1，则程序P在M1和M2_上运行时间的比值是?</p>
<p>答：M1的CPI为2即2周/指，而M2为1周/指。同样的程序P即指令数相同。M1的周期T1=1/1.5*10<sup>9</sup>，M2的周期T1=1/1.2*10<sup>9</sup></p>
<p>那么每条指令所需时间分别为2×T1和1×T2，指令数相同，那时间比值就等于一条指令所需时间比值即(2×T1)/(1*T2)=8/5</p>
<h1>运算方法和运算器</h1>
<h2 id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609143207561.png"  alt="image-20200609143207561" style="zoom: 80%;" />1.数字0在原码反码补码的表示</p>
<p>[+0]原码=0000 0000，  [-0]原码=1000 0000</p>
<p>[+0]反码=0000 0000，  [-0]反码=1111 1111</p>
<p>[+0]补码=0000 0000，  [-0]补码=0000 0000   （补码中是唯一的）</p>
<p>0的移码也是唯一的1000 0000</p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609151740827.png"  alt="image-20200609151740827" style="zoom:67%;" />
<p>由于补码0是唯一的所以补码范围要多一个负数(总共都是256个数)</p>
<p>2.对于规格化的浮点数，尾数有三种形式：（小数点左边的是符号位）</p>
<ul>
<li>
<p>原码表示时尾数的小数点后第一数位为1，数符任意</p>
</li>
<li>
<p>补码和反码表示时尾数的符号位与小数点后第一数位不同</p>
</li>
<li>
<p>1.1xx……X(原码)</p>
</li>
<li>
<p>1.0XX……X(补码、反码)</p>
</li>
<li>
<p>0.1xx……x(原码、补码、反码)</p>
</li>
</ul>
<blockquote>
<p>原理是保证   1&gt; |M|≥ 0.5</p>
</blockquote>
<p>3.余3码就是8421码加3所得</p>
<p>4.奇偶校验码：加上校验码后1的个数为奇数就是奇校验。不具备纠错能力。</p>
<p>5.海明码：设有k个数据位，则应设r个校验位，r满足2<sup>r</sup>-1 ≥ k + r 。发现两位错误纠正一位错误。</p>
<p>6.循环冗余检验码(CRC)：k位校验位拼接在n位数据位后面，即为n+k，发现并纠正一位或多位错误</p>
<p>7.A的ascii码：65            a的ascii码：97</p>
<p>8.已知[x]<sub>补</sub>，求[-x]<sub>补</sub>：将[x]<sub>补</sub>连同符号位求反+1</p>
<p>9.移码就是补码的符号位求反</p>
<blockquote>
<p>由于负数的补码如-21(101011)看着好像大于21(010101)，实际正好是21更大，所以浮点数的阶码用移码表示能直观的看出大小便于加减运算</p>
</blockquote>
<p>10.-1的补码永远是全1(可理解为全1加1等于全0)</p>
<p>11.由于补码溢出无法看出是上溢(大于最大数)还是下溢，因此引入变形补码</p>
<ul>
<li>两个符号位不同时表溢出(01为正溢出，10为负溢出(看第一位))</li>
<li>最高位那个数代表真正的符号位</li>
<li>两个符号位均参与运算，若进位舍去</li>
</ul>
<p>12.IEEE754计算公式：真值x=(-1)<sup>S</sup><em>1.M</em>2<sup>e</sup>（S为符号位(正还是负)，E为阶码(转换成e代表多少次方)，M为尾数(小数点后面的数)，顺序为SEM）其中e=E-127(可记成大E大所以要减)</p>
<p>13.补码的1000 0000为什么代表-128</p>
<p><strong>补码就是同余</strong>，比如-3的原码是1011而它的反码是1100则补码为1101,无符号的1101是13和-3正好模2<sup>4</sup>同余</p>
<p>所以给出一个负数的补码将其看为无符号数减去2<sup>n</sup>(n为总位数)即代表真值</p>
<p>为什么会这样呢？4位二进制可表示16个数，那么想表示负数怎么办，就用同余的思想，-1就用15表示，-2就用14表示，-3就用13(1101)表示</p>
<p>回到本题，给出补码求真值，将其看成无符号数即为128，与128模2<sup>8</sup>同余的负数即为-128（也可用128-2<sup>8</sup>计算）</p>
<p>14.IEEE754的尾数用原码表示，阶码用指数的移码-1表示（所以E=e+127）</p>
<h2 id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2>
<p>1.写出D=101101的海明码</p>
<p>答：:one:首先确定检验位的个数：k=6，2<sup>r</sup>-1 ≥ k + r即2<sup>r</sup> ≥7+r，所以r=4</p>
<p>:two:确定检验码的位置：检验码P<sub>i</sub>(i=1,2…)的位置为2<sup>i-1</sup>（2<sup>0</sup>,2<sup>1</sup>,2<sup>2</sup>…）</p>
<p>注意从M10到M1，从大到小且没有0</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609150117418.png"  alt="image-20200609150117418"></p>
<p>:three:求出检验码的值：校验位Pi的值即为所有需要Pi校验的数据位求异或。</p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609150430484.png"  alt="image-20200609150430484" style="zoom:80%;" />
<p>如P2对应M2，需要它的有D1即M3(2+1)、D3即M6(2+4)、D4即M7(2+4+1)…</p>
<p>所以最后的海明码为1011100100</p>
<p>2.已知x=11011，y=-10101，用变形补码计算x+y</p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609154616627.png"  alt="image-20200609154616627" style="zoom:70%;" />
<blockquote>
<p>注意一定要先转换成补码再添符号位运算</p>
</blockquote>
<p>3.假设M(x)=x<sup>3</sup>+1(发送信息的多项式)，G(x)=x<sup>3</sup>+x+1(生成多项式，代表校验位信息)。</p>
<p>:one: 那么M(x)代表的二进制码为: 1001(1*x<sup>3</sup>+1*x<sup>0</sup>)，G(x)代表的二进制码为: 1011</p>
<p>:two:将M(x)的多项式左移G(x)的最高次数，变为1001 000</p>
<p>:three:将1001 000对1011做模2除法得到余数为110,将其与被除数1001合并得到CRC码1001 110</p>
<blockquote>
<p>这里要注意第三步的模2除法和普通除法不同，模2除法不会向上一位借位也不比较被除数和除数的大小(位数相同即可)，如图中第三位商数(1101&gt;1000但仍可做减操作)<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609195155116.png"  alt="image-20200609195155116" style="zoom:80%;" /></p>
</blockquote>
<p>4.若浮点数x的754标准存储格式为(41360000)<sub>16</sub> ,求其浮点数的十进制数值。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609225853843.png"  alt="image-20200609225853843"></p>
<blockquote>
<p>注意阶码没有符号位</p>
</blockquote>
<p>5.将数(20. 59375)<sub>10</sub>转换成754标准的32位浮点数的二进制存储格式。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609230432591.png"  alt="image-20200609230432591"></p>
<p>6.某机器数为1000 0000B，若它代表0，则它是（原）码形式。若代表-128，则它是（补）码形式。若代表-127，则它是（反）码形式。</p>
<p>答：若是原码形式，就是-0。若是反码形式时，转换为原码就是1111 1111即-127(-(2<sup>7</sup>-1)) ，若是补码，1000 0000无符号时是2<sup>7</sup>=128，所以该补码代表-128（详情见上面知识点）</p>
<p>7.某机字长32位，其中1位符号位，31位表示尾数，若用定点小数表示，则最大正小数为多少？（B）</p>
<p>A.(1-2<sup>-32</sup>)		B.(1- 2<sup>-31</sup> )		C.2<sup>-32</sup>		D.2<sup>-31</sup></p>
<p>答：这样的题就用4位的先试试。4位最大小数就是 0 111，也就是0.875  即1-2<sup>-3</sup>  所以可推出32位时最大是 1-2<sup>-31</sup></p>
<p>8.IEEE 754单精度浮点数格式表示的数中，最小的规范化正数为（A）</p>
<p>A.1.0x2<sup>-126</sup>		B.1.0x2<sup>-127</sup>		C.1.0x2<sup>-128</sup>		D.1.0x2<sup>-149</sup></p>
<p>答：浮点数表示为1.M*2<sup>E</sup>，最小M为0,且E也要最小，这样往左移位越多数值越小，这样就转换成IEEE754中指数的最小值问题</p>
<p>对E来说，去除全1和全0(表0和无穷大)，E的范围为1~254，而e=E-127即e的范围为-126～+127，即指数最小为-126</p>
<p>所以本题答案为1.0*2<sup>-126</sup></p>
<p>9.若x=103,y=-25,则下列表达式采用8位定点补码运算实现时，会发生溢出的是 （ C ）</p>
<p>A.x+y				B.-x+y				C.x-y			D.-x-y</p>
<p>答：不用转换成补码再算，直接算。四个选项中B的-128和C的128绝对值最大最可能溢出</p>
<p>而8位补码范围是-128~127，那就是C的128溢出了  (注意补码的0是唯一的所以多了个最大负数-128)</p>
<ol start="10">
<li></li>
</ol>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620135418708.png"  alt="image-20200620135418708"></p>
<p>答：这题的关键点是计算机使用补码参与运算的。-9的原码是1000 1001，补码是1111 0111，扩展到16位高位补1(也可写完整的16位原码再转换成补码)            x = 127，原码：0111 1111，补码：0111 1111，扩展到32位高位补0       z=x+y=118同理高位补0</p>
<p>11.整数x的机器数为1101 1000,分别对x进行逻辑右移1位和算术右移1位操作得到的机器数为_____________<u>0110 1100、1110 1100</u>______________</p>
<p>答：逻辑右移就是右移一位，左边补零即可。算术右移需要考虑符号位(算术要算所以补符号位)，右移一位，左边补符号位。</p>
<p>12.已知x=10111，y=11011，用变形补码求x-y</p>
<p>答：[x-y]<sub>补</sub>=[x]<sub>补</sub>+[-y]<sub>补</sub>，[x]补=00 10111，[-y]补=11 00101</p>
<p>00 10111+11 00101  =11 11100，结果没溢出转换为原码为1 00100即-00100  (注意得到的是补码要转换为真值)</p>
<blockquote>
<p>[y]补=00 11011，[-y]补=[y]补连同符号位求反加1=11 00101，当然也可直接求-11011的补码</p>
</blockquote>
<p>13.假定有4个整数用8位补码分别 表示r1=FEH,r2=F2H, r3=90H, r4=F8H,若将运算结果存放在 一个8位寄存器中，则下列运算会发生溢出的是（ B ）</p>
<p>A.r1×r2			B.r2×r3			C.r1×r4			D.r2×r4</p>
<p>答：这种判断是否溢出的题就算出真值看看是否溢出。r1真值为-2，r2真值为-14，r3真值为-112，r4真值为-8</p>
<p>而这是补码运算最后得到的结果也是补码，8位补码范围为-128~127，所以显然r2*r3得到的结果转换为补码大于8位补码最大值</p>
<h1>多层次的存储器</h1>
<h2 id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610135354300.png"  alt="image-20200610135354300" style="zoom:80%;" />
<p>1.存储器按存取方式可分为</p>
<ul>
<li>
<p>随机存取存储器（RAM）可读可写，断电即失(也称易失性)</p>
<ul>
<li>静态RAM(SRAM)   常用做高速缓冲存储器</li>
<li>动态RAM(DRAM)  常用做主存</li>
</ul>
</li>
<li>
<p>只读存储器（ROM）只读不写，断电保留(也称非易失性)</p>
</li>
<li>
<p>串行访问存储器</p>
<ul>
<li>
<p>顺序存取存储器（如磁带）</p>
</li>
<li>
<p>直接存取存储器（如磁盘）</p>
</li>
</ul>
</li>
</ul>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610140643769.png"  alt="image-20200610140643769" style="zoom:80%;" />
<p>2.这些存储器名称中带E的都表示可擦除（可能出选择题，Erasable：可擦）</p>
<p>3.为了解决存储器大容量、低价格、高速度三者之间的矛盾关系，常采用多级存储器结构</p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610140844977.png"  alt="image-20200610140844977" style="zoom:67%;" />
<p><strong>缓存</strong>-主存层次主要解决CPU和主存速度不匹配的问题，数据交换由硬件完成。</p>
<p>主存-<strong>辅存</strong>层次主要解决存储系统的容量问题，数据交换由硬件和操作系统共同完成</p>
<p>4.存储器带宽就是每秒存储器存储的信息量</p>
<p>5.SRAM存取速度快但容量不如DRAM（记住SRAM用作高速缓冲存储器，速度肯定快）</p>
<blockquote>
<p>DRAM需要刷新会影响速度，所以SRAM速度更快但是价格昂贵</p>
</blockquote>
<p>6.DRAM采用电容存储，由于电荷量会减少所以必须定期(若不说明则是2ms)刷新,可分为</p>
<ul>
<li>集中刷新（集中到一段时间，集中歼灭）死时间是刷新总时间</li>
<li>分散刷新（每存取一次就刷新一次，分散歼灭）加倍存取周期实现死时间为0</li>
<li>异步刷新（折中方案，有计划的刷新）死时间就是一个存取周期</li>
</ul>
<blockquote>
<p>刷新的实质就是读出数据再写入（对行刷新，若不说明刷新一行等于一个存储周期）</p>
</blockquote>
<p>7.ROM也是随机存取(像数组下标一样访问)，但随机存取<strong>存储器</strong>要求可读可写，ROM只读，所以把ROM和RAM分开（第一个随机存取只是取信息的方式和存储器的随机存取含义不一样）</p>
<p>8.如果要求将容量为axb的芯片组成容量为cxd的芯片，假设需要芯片的数量为n,则n=(cxd)/axb     （a是字线连接地址线，b是位线连接数据线）</p>
<p>9.命中率：CPU要访问的信息在Cache中的比例（cache存取次数/(cache存取+主存存取)）</p>
<p>10.平均访问时间：t<sub>a</sub>=命中率×访问cache的时间+(1-命中率)×访问主存时间 (t<sub>a</sub>=ht<sub>c</sub>+(1-h)t<sub>m</sub>)</p>
<p>11.访问效率：访问Cache时间/平均访问时间 (e=t<sub>c</sub>/t<sub>a</sub>)</p>
<p>12.CPU与Cache之间传送数据的基本单位是字，而主存与Cache之间传送数据的基本单位是块(一块包括多个字)。（可理解为CPU容量少传输的也少，主存容量大传输的也大）</p>
<p>13.为了把主存的部分内容放到Cache中要把主存地址转换为Cache地址（因为主存和Cache用块传输，所以主要是块号的转换）</p>
<ul>
<li>直接映射        根据行号指定特定行比（适合大容量Cache）</li>
<li>全相联映射   与Cache所有行全都比（适合小容量Cache）</li>
<li>组相联映射   先根据组号找到对应组，再在组中一个一个比(折中的方法)</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610171302861.png"  alt="image-20200610171302861"></p>
<blockquote>
<p>可以看到直接映射因为要找特定行，所以多了行号地址，组相联因为要找特定组所以多了组号地址，而全相联因为是一行一行比所以啥也没有</p>
</blockquote>
<p>14.替换策略：当要放新的东西而Cache满时就要替换</p>
<ul>
<li>最不经常使用(LFU即Least Frequently Used)算法     首先淘汰一定时期内被访问次数最少的</li>
<li>近期最少使用(LRU即Least Recently Used)算法     首先淘汰最长时间未被使用的</li>
<li>随机替换                              随缘替换</li>
</ul>
<p>15.Cache要和主存内容保持一致(CPU对Cache的写入更改了它)，所以要用到写操作策略</p>
<ul>
<li>写回法    只修改Cache的内容而不立即写入主存，此行被换出时写入主存</li>
<li>全写法(直写法、写直达)    Cache和主存同时修改</li>
<li>写一次法  处理和写回法一致，只是第一次命中要同时写入主存（折中处理）</li>
</ul>
<p>16.TLB(快表)、页表和Cache之间的命中关系</p>
<p>记住只要TLB(页表分为快表和慢表)和Cache有一个命中，页表一定命中，但页表命中那俩不一定命中(数据在主存不在Cache时)，也可能都不命中       （<strong>即页表最大</strong>）</p>
<p>17.DRAM采用地址复用技术，地址线为正常的一半，例如你计算的用10根地址线实际用5根就行 （先送行地址再送列地址）</p>
<h2 id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2>
<p>1.RAM和ROM的区别</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610145652114.png"  alt="image-20200610145652114"></p>
<p>答：RAM断电会失去信息而ROM不会，二者访问信息的方式都是随机存取。Cache需要可读可写，而Rom只能读不能写，肯定不适合。DRAM(动态RAM)才需要刷新。</p>
<p>2.Flash存储器</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610150200185.png"  alt="image-20200610150200185"></p>
<p>3.假定用若干个2K×4位芯片组成一个8K×8位存储器，则地址0B1FH所在芯片的最小地址是</p>
<p>答：8k*8/2k*4=8，需要8个芯片，8k=2<sup>13</sup>，所以需要13位地址。2个4位的芯片构成一个8位的(存取数据一次最少8位)，所以需要4组，片选地址为2位(位扩展两个要选中都是同时选中，所以只看字扩展)，剩下的为片内地址</p>
<p>:one: 每组芯片是2k*8即11个地址线，4组需要2位片选信号，所以每组后11位是从全0到全1</p>
<p>第1组芯片地址范围：000==0 0==000 0000 0000 ~ 0000 0111 1111 1111（黄色的为片选信号）</p>
<p>第2组芯片地址范围：000==0 1==000 0000 0000 ~ 0000 1111 1111 1111</p>
<p>第3组芯片地址范围：000==1 0==000 0000 0000 ~ 0001 0111 1111 1111</p>
<p>第4组芯片地址范围：000==1 1==000 0000 0000 ~ 0001 1111 1111 1111</p>
<p>0B1FH的地址格式是0000 1011 0001 1111，可知是第二组中的一个地址，这个地址所在芯片最小的为地址为0000 1000 0000 0000，即0800H</p>
<p>4.某计算机存储器按字节编址，主存地址空间大小为64MB，现用4MB×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（26位）。</p>
<p>答：MAR要能寻址整个存储器，虽然题目说组成32MB的主存，但是剩余的32MB以后也会用，所以也要考虑，64MB=2<sup>26</sup>，所以最少26位</p>
<p>5.假设 Cache完成缓存的次数为 2000次，主存完成存取的次数为50次。已知Cache的存储周期为50ns，主存的存储周期为200ns，试求:命中率、平均访问时间、效率。</p>
<p>答：:one:命中率为  2000/(2000+50)=97%</p>
<p>:two:t<sub>a</sub>=ht<sub>c</sub>+(1-h)t<sub>m</sub>=0.97*50ns+(1-0.97)*200ns=54.5ns（a表average,c表cache,m表main）</p>
<p>:three:效率e=t<sub>c</sub>/t<sub>a</sub>=50/54.5=91.7%</p>
<p>6.一个组相联cache由64个行组成，每组4行。主存储器包含4K个块，每块128字。请表示内存地址的格式。</p>
<p>答：128字=2<sup>7</sup>，所以字地址位数为7</p>
<p>Cache共64行，每组4行，所以需要16组，16=2<sup>4</sup>，即只需4位组号地址即可表示16组</p>
<p>:one: 主存有4k个块，每块128字，所以总共4k*128=2<sup>19</sup>，19-4-7=8即8位标记位</p>
<p>:two: 主存有4K个块，4k=2<sup>12</sup>，12-4=8，所以标记位需要8位</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610172722721.png"  alt="image-20200610172722721"></p>
<blockquote>
<p>注意这些地址是存放在主存的，所以总位数和主存的容量保持一致</p>
</blockquote>
<p>7.某容量为256MB的存储器由若干4M×8位的DRAM芯片构成，该DRAM芯片的地址引脚和数据引脚总数是 __________<em><strong>19</strong></em></p>
<p>答：注意是DRAM采用地址复用，4M=2<sup>22</sup>，地址复用所以11根就行，11+8=19</p>
<blockquote>
<p>注意地址线是2<sup>n</sup>(译码器译码)，而数据线是一个线对应一位</p>
</blockquote>
<p>8.下列各类存储器中,不采用随机存取方式的是( B)<br>
A.EPROM               B.CD-ROM           C.DRAM            D.SRAM</p>
<p>答：CD-ROM即光盘，采用串行存取方式，它是只读型光盘存储器，不属于只读存储器ROM</p>
<p>9.某存储器容量为64KB ,按字节编址,地址4000H-5FFFH位ROM区,其余为RAM区,若用8Kx4位的SRAM芯片设计,则需要该芯片的数量为_______14____</p>
<p>答：这题主要是计算ROM区的容量，4000~5FFFH有5FFF-4000+1=2000H，而2000H=2<sup>13</sup>=8k（转换成二进制1在从右到左第13位(0开始)可类比10是2即2<sup>1</sup>），剩下的56kb为RAM，(56k*8)/(8k*4)=7*2=14</p>
<p>10.某系统的存储器为2MB，每字块为8个字，每字32位，若Cache为16KB，采用字节编址方式。</p>
<p>(1)采用直接映射，主存地址格式是什么？</p>
<p>(2)采用全相联映射，主存地址格式是什么？</p>
<p>(3)采用16路组相联映射，主存地址格式是什么？</p>
<p>答：一般都只给每块多少字写字号地址就行，既然这题说明一个字多少位了那么就要有字节地址<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610231019657.png"  alt="image-20200610231019657" style="zoom:80%;" /></p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610231039381.png"  alt="image-20200610231039381" style="zoom:80%;" />
<p>16路组相联即每组16块，16kb是2<sup>14</sup>是字节即有2<sup>14</sup>*2<sup>3</sup>=2<sup>17</sup>位，现在需要知道有多少组</p>
<p>组数=2<sup>17</sup>/2<sup>4</sup>(每组16块)*2<sup>3</sup>(每字块8个字)*2<sup>5</sup>(1个字32位)=2<sup>5</sup>，所以组地址为5位</p>
<blockquote>
<p>注意单位要一致，kb是字节，也可以32位换算成字节计算</p>
<p>注意行号和组号是Cache的，块号地址是主存的，根据Cache的行号或组号把主存的块号映射到Cache中，这也是上面根据Cache容量推行号位数的原因。</p>
<p>如全相联，给定一个地址，CPU先根据块内地址然后依次和Cache的每行比较(通过标记)，若命中则按块内地址读取相关内容，若未命中就得到主存去读了(Cache命中率)</p>
</blockquote>
<p>11.某计算机存储器按字节编址，采用<strong>小端方式存放数据</strong>。 假定编译器规定int型和short型长度分别为32位和16位 ，并且<strong>数据按边界对齐存储</strong>。 某C语言程序段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">  <span class="keyword">int</span> a；</span><br><span class="line">  <span class="keyword">char</span> b；</span><br><span class="line">  <span class="keyword">short</span> c；</span><br><span class="line">&#125;record；</span><br><span class="line">record.a=<span class="number">273</span>；</span><br></pre></td></tr></table></figure>
<p>若record变量的首地址为0XC008, 则低地址0XC008中内容为（）及record.c的地址是 （ ）</p>
<p>答：273 = 0X0000 0111(注意是十六进制不是二进制)，采用小端方式存放数据即高字节存放高地址，低字节存放低地址，273的低字节是11，所以低地址存11(往后依次是01,00,00)</p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610234723093.png"  alt="image-20200610234723093" style="zoom:80%;" />
<p>由上图看到0xC00D空了下来，因为题目说数据按边界对齐存储，b后面的c是short2字节，所以c的首地址也得是2的倍数(这样存储器访问一次就可取到数据，若不这样可能存储器一次取的正好是c的一部分，需要再访问一次才能得到完整的c，2的倍数则保证每次都能一次取到)</p>
<p>所以答案为0X11、0XC00E。</p>
<p>12.某计算机主存地址空间大小为256 MB， 按字节编址。虚拟地址空间大小为 4 GB，采用页式存储管理，页面大小为 4 KB， TLB（快表）采用全相联映射，有 4 个页表项， 内容如下表所示。则对虚拟地址03FF F180H 进行虚实地址变换的结果是（ ）</p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620230255835.png"  alt="image-20200620230255835" style="zoom:80%;" />
<p>答：虚存地址空间4GB，则虚地址长度为32位。主存地址空间256MB，则主存地址长度为28位。页面大小4KB，则页内地址长度为<strong>12位</strong>。虚拟地址03FF F180H中<strong>180H</strong>为页内地址(十六进制的3位即二进制的12位和页内地址长度对应)，03FFFH(20位)为虚页号，查TLB(快表)发现，该页在主存中，其实页号为0153H，所以虚实地址变换后的结果为0153 180H(对应主存的28位)。</p>
<blockquote>
<p>TLB根据标记找若找到了但是有效位是0代表TLB缺失。若没找到去页表找若找到了但有效位是0代表缺页。</p>
</blockquote>
<p>13.某计算机的 Cache 共有 16 块，采用 2 路组相联映射方式，每个主存块大小为 32 字节，按字节编址。主存 129 号单元所在主存块应装入到 Cache 的组号是（ C ）</p>
<p>A.0			B.2			C.4			D.6</p>
<p>答：采用2路组相联,所以一共是8组,从0开始,0 1 2 3 4 5 6 7.主存的某一字块按模8映像到Cache中的任一字块中.比如说主存中第0、8、16 字块是映像到Cache里第0组。每个主存块大小32字节，0-31号单元在第0块,32-63号单元在第1块,64-95号单元在第2块,96-127号单元在第3块.由此可见,主存129号单元位于主存中第4块的位置那么对应第4组</p>
<blockquote>
<p>注意块号和单元号都是从0开始</p>
</blockquote>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620233829884.png"  alt="image-20200620233829884" style="zoom:80%;" />
<p>14.若数组a及变量k均为int型，int型数据占4B，数据Cache采用直接映射方式，数据区大小为1KB、块大小为16B，该程序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为 （ C ）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;<span class="number">1000</span>; k++)   </span><br><span class="line">	a[k] = a[k]+<span class="number">32</span>;</span><br></pre></td></tr></table></figure>
<p>A.1.25%							B.2.5 %							C.12.5%					D.25%</p>
<p>答：块大小为16B而int数据4B即每块有4个int数据。a[k] = a[k]+32;首先读取a[k]需访问一次a[k]，之后将结果赋值给a[k]又需要访问一次，即一个int访问两次。第一次访问a[k]未命中，并将该字所在的主存块调入Cache对应的块中。4个整数的各两次访问中只在访问第一个的第一个次时发生缺失，所以缺失率约为1/8=12.5%</p>
<h1>指令系统</h1>
<h2 id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200611145349442.png"  alt="image-20200611145349442" style="zoom:80%;" />
<p>1.CISC：复杂指令系统计算机  （常用的20%频率占80%）C表Complex</p>
<p>RISC：精简指令系统计算机        少、固定、小但是寄存器数量多</p>
<p>2.二地址指令中根据操作数的物理位置，可分为</p>
<ul>
<li>SS(存储器-存储器)        速度最慢</li>
<li>RS(寄存器-存储器)        速度中间</li>
<li>RR(寄存器-寄存器)       速度最快</li>
<li>助记：S表Storage即存储器，R表Register即寄存器</li>
</ul>
<p>3.指令字长：一条指令所占的存储空间大小即二进制代码位数</p>
<p>机器字长：计算机一次能直接处理的二进制位数</p>
<p>若指令字长 = 机器字长，则称它为单字长指令，类比还有半字长指令、双字长指令</p>
<p>4.数据字和指令字的区别：一个字如果表数据那就是数据字，如果表指令那就是指令字</p>
<p>5.定长操作码指令：指令字的高位部分固定位数表示操作码，n位操作码最多表示2<sup>n</sup>条指令</p>
<p>6.不定长操作码设计规则</p>
<ul>
<li>不允许较短的是较长的前缀（这样可根据前缀直接判断它是零地址还是一地址…）</li>
<li>频率较高的指令分配较短的指令</li>
</ul>
<p>7.不定长操作码中的扩展位可理解成一个标志，你看到这个标志就知道它是0地址还是1地址…</p>
<p>8.指令寻址：找到下一条将要执行指令的地址</p>
<ul>
<li>顺序寻址			（按顺序来如1-&gt;2-&gt;3）</li>
<li>跳跃寻址            （发生跳跃如1-&gt;2-&gt;6）</li>
</ul>
<p>9.数据寻址：找到当前正在执行指令的数据地址   多种寻址方式是为了压缩地址码长度</p>
<ul>
<li>隐含寻址       操作数隐含在某寄存器中</li>
<li>立即寻址       指令字中给出立即数，如MOV AX,1234H                         操作数=A</li>
<li>直接寻址       指令字中直接给出操作数的有效地址，如MOV AX,[8054H]             EA=A</li>
<li>间接寻址       指令字中给出的是操作数有效地址<strong>的地址</strong>                                           EA=(A)</li>
<li>寄存器寻址   指令字中给出寄存器的编号，根据编号取寄存器的数值                    EA=R<sub>i</sub></li>
<li>寄存器间接寻址  与寄存器寻址不同的是寄存器存的数值是操作数的有效地址      EA=(R<sub>i</sub>)</li>
<li>偏移寻址     A由指令字给出，R隐含给出           A+R的内容                              EA=A+®
<ul>
<li>相对寻址        PC：程序计数器                                                                      EA=A+(PC)</li>
<li>基址寻址        BR：基址寄存器   形式地址A可控，(BR)不可控                   EA=A+(BR)</li>
<li>变址寻址        IX：变址寄存器    形式地址A不可控，IX的内容可控            EA=A+(IX)</li>
</ul>
</li>
</ul>
<blockquote>
<p>A表指令字给出的形式地址，(A)表A的内容，EA表有效地址</p>
</blockquote>
<p>10.低字节地址为字地址：低位字节的地址是字的起始地址</p>
<p>0X1234（左边是高字节，右边是低字节(可理解成右面是个位所以小)）</p>
<p>如0X4000：0X34             0X4001：0X12   即先存字符低位</p>
<h2 id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2>
<p>1.假设指令字长固定为16位，试设计一套指令系统满足以下要求:</p>
<p>1)有15条三地址指令。                             2)有12条二地址指令。<br>
3)有62条一地址指令。                             4)有30条零地址指令。</p>
<p>答：三地址操作码15条用4位操作码即可，剩下的1111用作扩展(即只要看见前四个是1111那它就肯定是二地址指令)</p>
<p>12条二地址指令又需要4位操作码，即<strong>1111</strong> 0000 ~ <strong>1111</strong> 1011（12条）</p>
<p>剩余的1111 1100 ~ 1111 1111可用来扩展一地址指令(即看到前缀是它就代表是一地址指令)</p>
<p>1111 1100 ~ 1111 1111有4种情况后面加4位可达2<sup>4</sup>*4=64，大于一地址的62条，所以</p>
<p><strong>1111 1100</strong> 0000 ~ <strong>1111 1100</strong> 1111（16条）<strong>1111 1101</strong> 0000 ~ <strong>1111 1101</strong> 1111（16条）</p>
<p><strong>1111 1110</strong> 0000 ~ <strong>1111 1110</strong> 1111（16条）<strong>1111 1111</strong> 0000 ~ 1111 1111 1101（14条）</p>
<p>剩余的1111 1111 1110 ～ 1111 1111 1111可用来扩展零地址指令</p>
<p>再加4位可表示16位，两种拓展码总共表示32种情况而题目0地址只有30条舍去最后两条即可</p>
<p>1111 1111 1110 0000 ～ 1111 1111 1110 1111（16条）</p>
<p>1111 1111 1111 0000 ～ 1111 1111 1111 1101（14条）</p>
<blockquote>
<p>拓展码代表这个指令是0地址还是1地址，后面的才代表这种地址码有多少条指令</p>
<p>多地址指令操作码要最短(存放的地址多)，0地址操作码占满16位，而三地址操作码仅占4位，剩下的12位用来存放三个地址</p>
</blockquote>
<p>2.设相对寻址的转移指令占两个字节，第一节是操作码，第二字节是相对位移量（用补码表示），若CPU每当从存储器中取出一个字节时，即自动完成PC+1 -&gt; PC。设当前PC的内容为2009H，要求转移到2000H地址，则该转移指令的第二字节的内容是（F5H）</p>
<p>答：当前PC为2009H，取指令后变为200BH（要先取指令再执行，取两次所以加2）</p>
<p>2000H-200BH=-11  (相对寻址都是加偏移量，只有偏移量是负的才能使PC数值减小)</p>
<p>-11的原码为1000 1011，反码为1111 0100，补码为1111 0101即F5H (题目说了用补码表示)</p>
<p>3.CISC和RISC的区别</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200611173134098.png"  alt="image-20200611173134098"></p>
<p>答：由于RISC比较简单，因此大多都是在一个时钟周期内完成。特殊的是RISC寄存器此CISC多，因此更能提高计算机速度。CISC更复杂因此种类啥的都比较多。RISC采用组合逻辑控制CISC才会用到微程序控制(可理解为RISC比较简单用不到那么复杂的微程序控制用逻辑电路即可)</p>
<p>4.某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令29条，二地址指令107条，每个地址字段为6位，则指令字长至少应该是____________24_________</p>
<p>答：三地址指令有29条，所以它的操作码至少为5位。2<sup>5</sup>=32，它剩余32-29=3种操作码给二地址。而二地址比三地址少了一个地址的位数多了6位给操作码，因此它数量最大达3*64=192。所以指令字长最少为23位（ 6 + 6 +6 + 5 = 23），因为计算机按字节编址，<strong>需要是8的倍数</strong>，所以指令字长至少应该是24位</p>
<blockquote>
<p>同样是24位，3地址时是3个地址位+操作码5位，而2地址时是11位操作码和两个地址位</p>
</blockquote>
<p>5.某计算机存储器按字编址(16位)读取这条指令后，PC的值自动加1,则说明该指令的长度是( 2 )个字节</p>
<p>答：主要看按字节编址还是按字编址。按字寻址可理解为把字编上号然后去找编号。PC加1的目的是自动指向下一条指令的地址即加了一个编号也就是16位，而16位占了2个字节</p>
<p>6.假设变址寄存器R 的内容为1000H，指令中的形式地址为 2000 H；地址 1000H 中的内容为2000H，地址    2000H 中的内容为 3000H，地址 3000 H 中的内容为 4000H， 则变址寻址方式下访问到的操作数是（ D ）。</p>
<p>A.1000H		B.2000H		C.3000H		D.4000H</p>
<p>答：变址寻址中EA=A+®。这里的A即形式地址也就是指令中直接给出的，®表寄存器R的内容。EA=2000H+1000H=3000H，而这个3000H代表的是有效地址，根据地址取值即4000H</p>
<p>7.某计算机有16个通用寄存器，采用32位定长指令字操作码字段（含寻址方式位）为8位，Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式，若基址寄存器可使用任一通用寄存器，且偏移量用补码表示，则Store指令中偏移量的取值范围是  （ A ）</p>
<p>A.-32768~+32767		B.-32767~+32768		C.-65536~+65535		D.-65535~+65536</p>
<p>答：采用32位定长指令字,其中操作码为8位,两个地址码一共占用32-8=24位。</p>
<p>而Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址,有 16 个通用寄存器，则寻址一个寄存器需要4 位。</p>
<p>源操作数中的寄存器直接寻址用掉4位, 而目的操作数采用基址寻址也要指定一个寄存器,同样用掉 4 位,则留给偏移址的位数为24-4-4=16 位。而偏移址用补码表示,16 位补码的表示范围为-32768~+32767</p>
<blockquote>
<p>可类比8位补码表示范围是 -128～ +127，注意负数多一位</p>
</blockquote>
<p>8.假定编译器将赋值语句“x=x+3;”转换为指令“add xaddr, 3”，其中xaddr是x对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的TLB，且Cache使用直写（Write Through）方式，则完成该指令功能需要访问主存的次数至少是（ B ）</p>
<p>A.0			B.1			C.2			D.3</p>
<p>答：上述指令的执行过程可分为取数、运算和写回过程，取数时读取xaddr可能不需要访问主存而直接访问Cache，但直写方式也即全写法必须要把数据同时写入Cache和主存，因此至少访问1次。</p>
<h1>中央处理器</h1>
<h2 id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616172236584.png"  alt="image-20200616172236584"></p>
<p>1.CPU = 运算器(对数据加工) + 控制器(协调控制各指令序列) + Cache</p>
<p>2.CPU主要有如下5种功能</p>
<ul>
<li>
<p>指令控制：控制器自动形成指令的地址，并发出取指令的命令，将对应的指令取到控制器中。</p>
</li>
<li>
<p>操作控制：取指令后，产生完成每条指令所需的控制命令</p>
</li>
<li>
<p>时间控制：控制命令产生后，需要对各种控制命令加以时间上的控制</p>
</li>
<li>
<p>数据加工：在执行的过程中，可能需要进行算术运算和逻辑运算</p>
</li>
<li>
<p>中断处理：就是处理中断的能力</p>
</li>
</ul>
<p>3.CPU至少需要六类寄存器，它们分别为</p>
<ul>
<li>数据缓冲寄存器(DR)：暂存数据</li>
<li>指令寄存器(IR)：保存正在执行的一条指令</li>
<li>程序计数器(PC)：存放第一条指令的地址，每次加一更换成下条指令地址</li>
<li>数据地址寄存器(AR)：保存当前CPU访问的Cache中单元的地址</li>
<li>通用寄存器(R<sub>0</sub><sub>R</sub>3~)：存放操作数和各种地址信息（如AX，BX等）</li>
<li>状态字寄存器(PSW)：保存各种状态条件控制标志，如进位标志、中断标志等</li>
</ul>
<p>4.指令周期：CPU取出并执行一条指令的时间，由若干机器周期组成</p>
<p>机器周期： 完成某个独立操作的时间，由若干时钟周期组成</p>
<p>时钟周期： 最基本时间单位，由主频决定</p>
<p>5.指令执行方案：</p>
<ul>
<li>单指令周期                  所有指令用相同的执行时间</li>
<li>多指令周期                  不同类型的指令用不同的步骤完成</li>
<li><strong>流水线</strong>方案                  指令之间并行执行</li>
</ul>
<p>6.CPU主频(时钟频率)对应的是时钟周期，每个机器周期(CPU周期)包含好几个时钟周期</p>
<p>7.大小顺序为：机器程序=微<strong>程序</strong> &gt; 微<strong>指令</strong> &gt; 微<strong>命令</strong>=微操作</p>
<p>微<strong>命令</strong>：控制部件向执行部件发出的各种控制命令。而微操作是微命令的执行过程。</p>
<p>微<strong>指令</strong>：若干微命令的集合</p>
<p>微<strong>程序</strong>：若干微指令的有序集合，而一条机器指令对应着一个微程序</p>
<blockquote>
<p>机器指令由微程序解释执行，微程序由微指令构成，微指令由微命令构成</p>
</blockquote>
<p>8.微操作分为相容性和相斥性</p>
<ul>
<li>相容性：同一个CPU周期可以并行执行微操作（也叫兼容性）</li>
<li>相斥性：同一CPU周期不能并行执行微操作</li>
</ul>
<p>9.微命令编码</p>
<ul>
<li>
<p>直接控制法：每一位代表一个微命令。</p>
</li>
<li>
<p>直接编码法：相斥的n个微命令可以采用编码法表示，占log<sub>2</sub><sup>(n+1)</sup>位。</p>
</li>
<li>
<p>混合编码法：相斥微命令采用直接编码法，相容微命令采用直接控制法。</p>
</li>
</ul>
<p>10.数据相关分为以下三类，注意读后写(WAR)啥的英文缩写是从后往前读！</p>
<ul>
<li>
<p>RAW(写后读)：应该先写入再读，但现在没写入就读了，出现错误</p>
</li>
<li>
<p>WAR(读后写)：应该先读再写，但现在是写入后再读了，出现错误</p>
</li>
<li>
<p>WAW(写后写)：应该先一个写入另一个再写入，但现在写入的顺序反了，出现错误</p>
</li>
</ul>
<blockquote>
<p>数据旁路是解决数据相关的一种方法(不用等前一条指令把结果写回寄存器组，结果直接作为输入给下一个指令)</p>
</blockquote>
<h2 id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2>
<p>1.XXX对程序员是透明的表示程序员看不见XXX（不可见就是不可改变）<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616192930989.png"  alt="image-20200616192930989"></p>
<p>2.判断RAW、WAR…<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617152100918.png"  alt="image-20200617152100918"></p>
<p>答：:one: 先将结果送到R1，再取出R1参与运算。先写再读即写后读（RAW注意顺序）</p>
<p>:two: 先读R2再将结果送到R2。先读再写即读后写（WAR）</p>
<p>:three: 先将第一条指令结果送入R3再将第二条指令结果送到R3，先写后写即写后写</p>
<p>3.某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有___________________15位___</p>
<p>答：33个微命令构成5个互斥类，分别包含7、3、12、5和6个微命令，另外每组必须<strong>增加一种不发命令的情况</strong>，则5个段分别需要8、4、13、6和7种状态，分别对应3(2<sup>3</sup>=8)、2、4、3和3位，共15位。</p>
<p>4.CPU中跟踪指令<strong>后继地址</strong>的寄存器是_______程序计数器______</p>
<p>5.在微程序控制器中,构成控制信号序列的最小单位是（ B ）</p>
<p>A.机器指令          B.微命令                       C.微指令                D.微程序</p>
<p>答：可以看到这几个选项中微命令最小所以选它</p>
<p>6.在微程序控制器中，执行指令微程序的首条微指令地址是(  D  )得到的。</p>
<p>A．程序计数器          B．前条微指令          C．μPC          D．指令操作码映射</p>
<p>答：执行指令微程序的首条微指令地址由指令操作码译码的结果，通过专门的硬件提供。后续地址才会用到程序计数器。</p>
<p>7.指令流水线有取指(IF)、译码( ID)、执行(EX)、访存(MEM)、写回寄存器堆(WB)五个过程段,共有20条指令连续输人此流水线。</p>
<p>(1)画出流水处理的时空图，假设时钟周期为100ns。<br>
(2)求流水线的实际吞吐率(单位时间里执行完毕的指令数)。<br>
(3)求流水线的加速比。</p>
<p>答：(2)中20条指令花了24个时钟周期的时间直接计算即可（注意时间的单位）</p>
<p>(3)中的加速比指的是不使用流水线和使用流水线时间的比值也就是所需时钟周期个数之比。</p>
<blockquote>
<p>不用流水线就是顺序执行，一个一个来即20*5（一个取值等过程需要一个时钟周期）</p>
</blockquote>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200622154629411.png"  alt="image-20200622154629411" style="zoom:80%;" />
<h1>总线系统</h1>
<h2 id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617162846524.png"  alt="image-20200617162846524" style="zoom:80%;" />
<p>1.总线：是连接多个部件的信息传输线，是各部件共享的传输介质。</p>
<p>2.总线大致分为三类：</p>
<ul>
<li>内部总线：CPU内部各寄存器与运算部件之间的总线</li>
<li>系统总线：连接其他高速功能部件的总线
<ul>
<li>数据总线：传送各功能部件之间的数据，为双向传输</li>
<li>地址总线：指定主存和I/O设备接口电路地址，为单向传输</li>
<li>控制总线：发出各种控制信号</li>
</ul>
</li>
<li>I/O总线：中、低速I/O设备之间互相连接的总线</li>
</ul>
<p>3.地址线和数据线复用：地址线和数据线用一条线，一个周期传地址，一个周期传数据</p>
<p>4.总线宽度：通常指数据总线的根数</p>
<p>总线带宽：单位时间内总线传输的位数    （可理解为数据传输速率）</p>
<p>5.总线结构可分为</p>
<ul>
<li>单总线结构：将CPU、主存、IO设备连接在一组总线上</li>
<li>多总线结构：高速、中速、低速设备连接在不同的总线上同时工作，提高效率</li>
</ul>
<p>6.CPU-PCI：北桥       PCI-ISA：南桥</p>
<p>CPU总线：也称CPU-存储器总线</p>
<p>PCI总线：连接高速的I/O设备</p>
<p>ISA总线：连接低速I/O设备</p>
<p>7.串行传送：每次一位传送，不管传多少数据只用一条线</p>
<p>并行传送：若有32条线，一次就能传送32位，快但是成本高</p>
<p>8.共享的总线会出现同一时刻多个设备竞争主线控制权，就要从中选择一个</p>
<ul>
<li>集中式仲裁 （重点）
<ul>
<li>链式查询：离总线设备越近优先级越高</li>
<li>计数器查询：地址线的计数值和请求总线的设备地址一致，该设备获得总线控制权</li>
<li>独立请求：每个设备均有总线请求信号和总线同意信号，根据排队电路判定</li>
</ul>
</li>
<li>分布式仲裁</li>
</ul>
<p>9.总线定时指事件出现在总线上的时序</p>
<ul>
<li>同步定时：采用统一的时钟信号协调发送和接收方的传送定时关系</li>
<li>异步定时：同步是在各模块速度一致的情况使用，异步没有公共时钟，采用应答(握手)方式，主模块发请求信号待从模块反馈后开始通信</li>
</ul>
<blockquote>
<p>同步定时比异步定时传输频率高的原因正是其具有统一的公共时钟信号进行同步</p>
</blockquote>
<p>10.系统总线标准分为：ISA、EISA、VESA、PCI、PCI-Express（可能出选择题）</p>
<h2 id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2>
<p>1.假设某系统总线在一个总线周期中并行传输4B信息，一个总线周期占用两个时钟周期，总线时钟频率为10MHz，则总线带宽是(  20MB/s   )。</p>
<p>答：总线宽度是单位时间内传输的位数，通常用每秒钟传输的字节数表示。4B即4字节。总线时钟周期为1/10MHz=0.1us，由题意得每0.2us可传输4B。那么每秒可以传输4B/0.2us=4B/0.2*10<sup>-6</sup>s=20MB/s</p>
<p>2.答：CRT是纯平显示器     CPI是一条指令所需时钟周期个数     RAM是随机存储器<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617182657948.png"  alt="image-20200617182657948"></p>
<p>3.下列关于多总线结构的叙述中，错误的是 ____<em><strong>D</strong></em></p>
<p>A.靠近CPU的总线速度较快					B.存储器总线可支持突发传送方式</p>
<p>C.总线之间须通过桥接器相连				D.PCI-Express×l6采用并行传输方式</p>
<p>答：突发传送方式把多个数据单元作为一个独立传输处理，从而最大化设备的吞吐量。一般用支持突发传送方式的总线提高存储器的读写效率。各总线通过桥接器相连，后者起流量交换作用PCI-Express总线都采用串行数据包传输数据</p>
<p>4.关于提高总线传输率的问题</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200617184609687.png"  alt="image-20200617184609687"></p>
<p>答：传输率就是每秒传输的数据。增加宽度、提高效率、突发传输(多个单元当做一个传送)都可以提高传输率。地址/数据线复用就是地址和数据线用一个线和每秒传输多少数据没关系。</p>
<p>5.某同步总线采用数据线和地址线复用方式，其中地址/数据线有32根，总线时钟频率为66MHz，每个时钟周期传送两次数据（上升沿和下降沿各传送一次数据），该总线的最大数据传输率（总线带宽）是 ___<em><strong>C</strong></em></p>
<p>A.132MB/s       B.264MB/s             C.528MB/s             D.1056MB/s</p>
<p>答：数据线32根代表一次传输32位即4字节(4B)，66MHz即一秒有66M个时钟周期，而每个周期传两次(上下各一次)，即66M/s×2×4B=528MB/s</p>
<p>6.下列关于总线设计的叙述中，错误的是 ___<em><strong><strong>A</strong></strong></em></p>
<p>A.并行总线传输比串行总线传输速度快         B.采用信号线复用技术可减少信号线数量</p>
<p>C.采用突发传输方式可提高总线数据传输率 D.用分离事务通信方式可提高总线利用率</p>
<p>答：通常并行一次能传多位数据看着是比串行的速度快，但时钟频率达到一定程度时并行之间的导线会互相影响所以A不是绝对的。</p>
<p>信号线复用就是线复用不同周期传不一样的信息确实可以减少数量(注意复用)。</p>
<p>突发传输是一个总线周期可以传输多个存储地址连续的数据也可提高传输率。</p>
<p>分离事务通信即通过在不传送数据期间释放总线，使得其他申请者能使用总线，以此来提高总线利用率</p>
<p>7.在集中式总线仲裁中，（B）方式相应时间最快，（A）方式对（C）最敏感</p>
<p>A.菊花链方式		B.独立请求方式		C.电路故障		D.计数器定时查询</p>
<p>答：独立请求有请求信号和同意信号最快但也最贵。菊花链(链式)若a<sub>i</sub>位置发生故障则其之后的都不能工作</p>
<p>8.采用串行接口进行7位ASCII码传送，带有1位奇/偶校验位为1位起始位和1位停止位，当波特率为9600b/s时，字符传送速率为（A）</p>
<p>A．960 			B．873				C．1371			 D．480</p>
<p>答：波特率可理解为比特率，即每秒9600比特。7位ASCII和3位起始停止校验共10位，也就是1个字符要占10位。那传输率就等于总比特除1个字符所占比特即9600/10=960</p>
<h1>外存与IO设备</h1>
<h2 id="知识点-v7"><a class="header-anchor" href="#知识点-v7">¶</a>知识点</h2>
<p>1.磁道：就是磁盘的一个同心圆，每个磁道又分为多个扇区(磁道的某个弧段)</p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200622202745718.png"  alt="image-20200622202745718" style="zoom: 80%;" />
<p>2.<strong>道</strong>密度：单位长度有多少个磁<strong>道</strong>数(同心圆)           多少道</p>
<p>3.<strong>位</strong>密度：单位<strong>磁道</strong>长度能记录的二进制的<strong>位</strong>数      多少位</p>
<p>4.磁盘容量：面数×每面磁道数×每条磁道的二进制位数</p>
<p>5.磁盘平均存取时间：T<sub>a</sub>=寻道(找哪一圈)+延迟(找圈中哪个扇区)+传输(读写扇区时间)</p>
<p>6.数据传输速率：磁盘单位时间向主机传送的字节数（字节/秒）</p>
<ul>
<li>D<sub>r</sub>=rN      r为转速即每秒转多少圈(磁道)，N为每个磁道的容量</li>
<li>D<sub>r</sub>=D*v   D为位密度即单位磁道的位数，v为线速度即每秒能沿着圈走多长</li>
</ul>
<p>7.一个磁盘片有两个面，一个磁盘组有很多片(n)，但最上面和最下面的面不能用(即2n-2可用)</p>
<p>8.显示器刷存带宽=分辨率×每个像素点颜色深度×刷新速率(帧频)</p>
<h2 id="习题-v7"><a class="header-anchor" href="#习题-v7">¶</a>习题</h2>
<p>1.磁盘组有6片磁盘， 每片有两个记录面，最上最下两个面不用。存储区域内径(直径)22cm,外径33cm,道密度为40道/cm，内层位密度400位/cm，转速6000转/分。问:</p>
<p>(1) 共有多少柱面?<br>
(2)盘组总存储容量是多少?<br>
(3)数据传输率多少?<br>
(4)采用定长数据块记录格式，直接寻址的最小单位是什么?寻址命令中如何表示磁盘地址?<br>
(5) 如果某文件长度超过一一个磁道的容量，应将它记录在同一个存储面上，还是记录在同一个柱面上?</p>
<p>答：(1)：有效存储区域为16.5-11=5.5(cm)，道密度为40道/cm，所以共40*5.5=220道即220个圆柱面（就是一面有多少圈）</p>
<blockquote>
<p>要用半径而不是直径因为总圈数用半径算即可，另一半和这一半用的是同一个圈</p>
</blockquote>
<p>(2)：内层磁道周长为2πR=2X3.14X11= 69.08(cm)     因为给的是内径密度所以算内径周长<br>
每道信息量=400位/cmX 69.08cm=27632 位= 3454B    即一圈信息量  位密度×圈长度<br>
每面信息量= 3454BX 220= 759880B     一面一共220圈     道信息×道数<br>
盘组总容量= 759880BX10=7 598 800B    6片可用的面为10  面信息×面数</p>
<p>(3)：磁盘数据传输率D<sub>r</sub>= rN                 N为每条磁道容量，N=3454B<br>
r为磁盘转速，r=6000转/60秒=100转/秒   （注意换算单位!!!）<br>
D,=rN= 100X 3454B= = 345400B/s         每条磁道容量×磁道数量</p>
<blockquote>
<p>注意如果要转换成KB/s，除1024而不是除1000</p>
</blockquote>
<p>(4)：最小单位是一个记录块（一个扇区）</p>
<p>此地址格式表示有4台磁盘，每台有16个记录面，每面有256个磁道，每道有16个扇区</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610184101789.png"  alt="image-20200610184101789"></p>
<blockquote>
<p>台号(一般为2)—&gt;磁道—&gt;面数—&gt;扇区(一般为4)</p>
</blockquote>
<p>(5)：如果某文件长度超过一个磁道的容量，应将它记录在同一个柱面上，因为不需要重新找道，数据读/写速度快。</p>
<blockquote>
<p>同一柱面同时读的是多个存储面相同位置的那一圈，同一面那就得在不同圈，需要找道也就是找到那一圈的位置。</p>
</blockquote>
<p>2.若磁盘转速为7200 转/分，平均寻道时间为 8ms,每个磁道包含 1000 个扇区，则访问一个扇区的平均<strong>存取</strong>时间大约是（ B ）</p>
<p>A.8.1ms		B.12.2ms		C.16.3ms		D.20.5ms</p>
<p>答：存取时间=寻道时间+延迟时间+传输时间</p>
<p>延迟时间等于旋转半圈的时间，1分钟7200圈，那半圈时间为 (60/7200)/2=4.17ms</p>
<p>传输时间等于转过一个扇区的时间即为(60/7200)/1000=0.01ms</p>
<p>所以为4.17+0.01+8=12.18ms，保留一位小数则为 12.2ms</p>
<p>3.假定一台计算机的显示存储器用DRAM芯片实现，若要求显示分辨率为1600×1200，颜色深度为24位，帧频为85Hz，显存总带宽的50%用来刷新屏幕，则需要的显存总带宽至少约为（ D ）</p>
<p>A.245Mbit/s		B.979Mbit/s		C.1958Mbit/s		D.7834Mbit/s</p>
<p>答：刷新所需带宽=分辨率×色深×帧频=1600×1200×24bit×85/s=3916.8Mbit/s</p>
<p>因为显存总带宽的50%用来刷新屏幕，所以显存总带宽为3916.8Mbit/s×2=7834Mbit/s</p>
<p>4.磁盘的盘面上有很多半径不同的同心圆，这些同心圆称为( B )</p>
<p>A、扇区			B、磁道			C、柱面			D、磁表面</p>
<p>答：可以把磁盘想象成一摞蚊香。磁道就是蚊香的一圈，扇区就是蚊香一圈的某个弧段。而柱面相当于在一摞蚊香中间插个柱子那个圆柱就是柱面。读取信息时同时读取一摞蚊香的同一圈(像老式留音机一样)</p>
<p>5.已知某磁盘存储器转速为2400转/分，每个记录面道数为200道，平均找道时间为60ms,每道存储容量为96Kb，求磁盘的存取时间与数据传输率。</p>
<p>答：存取时间=平均查找时间+平均等待时间(半圈时间)=60+(60/2400)*1/2*1000=72.5ms</p>
<p>Dr=96*(2400/60)=3840Kb/s=480KB/s</p>
<blockquote>
<p>注意b是位，B是字节，1B=8b</p>
</blockquote>
<h1>输入输出系统</h1>
<h2 id="知识点-v8"><a class="header-anchor" href="#知识点-v8">¶</a>知识点</h2>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618151509519.png"  alt="image-20200618151509519"></p>
<p>1.CPU管理外围设备大致有三种方式   下面类比成让10个孩子分别吃两个雪糕的问题</p>
<ul>
<li>程序查询方式：先盯着甲吃完一个再给一个然后盯着乙吃完，以此类推</li>
<li>程序中断方式：每人发一根，谁吃完举手报告再发第二根,等待过程可干其他的事</li>
<li>直接内存访问(DMA)方式：每人拿两根，都吃完再报告</li>
</ul>
<p>2.程序查询方式下，CPU和外围设备之间的传送完全靠计算机程序控制，需要输入输出时，CPU暂停主程序转去执行设备的输入输出服务程序。简单经济但浪费时间。</p>
<p>DMA方式传送数据，每传送一个数据就要占用一个<strong>存储周期</strong>时间</p>
<p>DMA方式下DMA控制器从CPU完全接管对总线的控制，数据交换不用经过CPU，直接在内存和I/O设备之间进行。</p>
<p>3.中断处理过程由硬件和软件完成</p>
<ul>
<li>响应中断：有请求就得有响应</li>
<li>关中断：不再受理其它中断   （要用到状态条件寄存器PSW）</li>
<li>保存PC：即保存断点，使得中断服务子程序处理完后可以返回原主程序</li>
<li>保存现场：中断服务子程序修改的寄存器可能会与原寄存器冲突所以先保存 （栈实现）</li>
<li>设备服务：也就是中断处理程序，该咋处理咋处理</li>
<li>开中断：表示CPU现在可以受理中断了</li>
<li>中断返回：先恢复现场(恢复原保存的寄存器和标志位)再恢复断点(返回原主程序)</li>
</ul>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618154711318.png"  alt="image-20200618154711318" style="zoom:80%;" />
<p>从图中我们也可以看出CPU是在结束一个指令周期后检测中断请求信号</p>
<p>4.中断屏蔽触发器(IM)置0表示CPU可受理外界中断请求，为1表不受理外界中断(1为真即屏蔽)</p>
<p>单级中断：所有中断源处于同一级，排成一行，离CPU近的优先权高</p>
<p>多级中断：把中断源分成若干级别，级别高的可以打断级别低的(同级的不行)</p>
<p>5.中断向量地址是指<strong>中断服务程序入口地址</strong></p>
<h2 id="习题-v8"><a class="header-anchor" href="#习题-v8">¶</a>习题</h2>
<p>1.某机器有 4个中断源，中断响应优先级按1→2→3→4降序排列，若想将中断处理<br>
次序改为3→1→4→2，则1、2、3、4中断源对应的屏蔽字分别是为___________________</p>
<p>答：屏蔽字为1表示真即屏蔽了，就是不能打断它的意思，那为0就是可以打断它</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200618160111614.png"  alt="image-20200618160111614"></p>
<blockquote>
<p>主要是看中断处理次序，比如1的屏蔽字，1前面有3，即只有3可以打断它，那么把响应优先级的第三位置为0其他均为1。也可看1后面有4和2，意味着1、4、2不能打断他，即把第1、2、4位置1其他置0即可    （两种思想一个结果）</p>
<p>以后统一用第一种置0的不容易错</p>
</blockquote>
<p>2.屏蔽字问题不要被迷惑，只看响应和处理优先级就行<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618161107440.png"  alt="image-20200618161107440"></p>
<p>答：本题给了中断屏蔽字格式为M<sub>4</sub>M<sub>3</sub>…，那么屏蔽字的第一位到底代表L<sub>4</sub>还是L<sub>0</sub>呢</p>
<p>M<sub>4</sub>对应L<sub>4</sub>级别也就是最高级别，而最高级别是L<sub>0</sub>，所以第一位代表的是L<sub>0</sub></p>
<p>其实这种题只看优先级顺序就行，优先级为L<sub>0</sub><sub>L</sub>4<sub>那么屏蔽字每位对应的也是L</sub>0<sub>～L</sub>4~</p>
<p>可以打断L1的为L4、L0和L2那么把优先级中这些位置置为0即可</p>
<p>3.某计算机处理器主频为50MHz,采用定时查询方式控制设备A的I/O,查询程序运行一次所用的时钟周期至少为500。在设备A工作期间，为保证数据不丢失，每秒需对其查询至少200次，则CPU用于设备A的I/O时间占整个CPU时间的百分比至少是（  0.2%  ）</p>
<p>答：每次查询需要500个周期，每秒要查询200次即需要200*500=10<sup>5</sup>个周期</p>
<p>而主频为50MHz即每秒有50*10<sup>6</sup>个周期</p>
<p>那么占比为  10<sup>5</sup>/50*10<sup>6</sup>=1/500=0.002= 0.2%</p>
<p>4.中断服务程序执行过程<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618164623663.png"  alt="image-20200618164623663"></p>
<p>答：此题选A。注意本题问的是中断服务程序的顺序也就是知识点中图片的右半部分，而保存断点(区别保存现场)和关中断都是中断隐指令的操作，由硬件完成</p>
<p>5.I/O总线：主机和I/O设备之前通过这个总线连接</p>
<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618183826339.png"  alt="image-20200618183826339"  />
<p>答：I/O总线即输入输出总线。肯定就得有指出啥指令的命令字。判断其状态的状态字。而且也得有中断，比如键盘输入引起的中断那肯定也得有中断类型号。</p>
<p>6.下列选项中，能引起外部中断的事件是（ A ）</p>
<p>A.键盘输入			B.除数为0			C.浮点运算下溢			D.访存缺页</p>
<p>答：服务于自己就是内中断，服务于别人就是外中断</p>
<p>A：键盘输入属于外部事件，CPU要想读取外部的输入就得执行中断暂停主程序转而去读取外部键盘输入</p>
<p>B：除数为0属于异常，也就是内中断，发生在CPU内部。</p>
<p>C：浮点运算下溢将按机器零处理，不会产生中断。</p>
<p>D：访存缺页属于CPU执行指令时产生的中断，也不属于外部中断。</p>
<blockquote>
<p>此题只需看外部这两个字就可快速选择键盘，其他仨都是CPU内部的东西</p>
</blockquote>
<p>7.中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调用不需 要保存其内容的是____________B_________</p>
<p>A.程序计数器	B.程序状态字寄存器	C.通用数据寄存器	D.通用地址寄存器</p>
<p>答：程序计数器即PC二者都需要，因为都要返回原主程序。而程序状态字寄存器(PSW)里面保存中断允许标志位和系统工作状态(如进位标志等)等信息。执行中断隐指令时，需要关中断，保护PC需要PC和PSW。所以子程序调用和PSW无关</p>
<p>8.中断I/O和DMA的比较</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618192202277.png"  alt="image-20200618192202277"></p>
<p>答：中断处理方式：在I/O设备输入每个数据的过程中，由于无需CPU干预，因而可使CPU与I/O设备并行工作。仅当输完一个数据时，才需CPU花费极短的时间去做些中断处理。因此中断申请使用的是CPU处理时间，发生的时间是在一条指令执行结束之后，数据是在软件的控制下完成传送。而DMA方式与之不同。DMA方式：数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；DMA方式每次申请的是总线的使用权，所传送的数据是从设备直接送入内存的，或者相反；仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。答案D的说法不正确。</p>
<p>9.某同步总线的时钟频率为100MHz，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发（猝发）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是（ C ）。</p>
<p>A.20ns			B.40ns			C.50ns				D.80ns</p>
<p>答：总线频率为100MHz，则时钟周期为10ns。由于支持突发传送可以连续传送地址连续的数据。传送地址10ns，传送128位数据即4个数据40ns，共需50ns。</p>
<blockquote>
<p>平常传送一个数据需要两个时钟周期，先传地址再传数据。突发传输下可将多个连续的数据看成一个数据(不是一周期传完是不用专门一个一个传地址)，也就是先传首地址，之后就可每一个周期传一次数据</p>
</blockquote>
<p>10.周期挪用方式常用于___________A___方式的输入/输出中。</p>
<p>A.DMA		B.中断		C.程序传送		D.通道</p>
<p>答：周期挪用是指利用CPU不访问存储器的那些周期来实现DMA操作，此时DMA可以使用总线而不用通知CPU也不会妨碍CPU的工作。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">夏日</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zss192.github.io/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/">https://zss192.github.io/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zss192.github.io" target="_blank">夏日 の blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/">计算机专业课</a></div><div class="post_share"><div class="social-share" data-image="/img/post/8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/12/%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"><img class="prev_cover lazyload" data-src="/img/post/6.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">实验六 查找和排序的实现</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/31/%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C/"><img class="next_cover lazyload" data-src="/img/post/5.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">实验五 图的操作</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/11/14/操作系统/" title="操作系统期末总结"><img class="relatedPosts_cover lazyload"data-src="/img/post/8.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-11-14</div><div class="relatedPosts_title">操作系统期末总结</div></div></a></div><div class="relatedPosts_item"><a href="/2022/11/14/网络安全/" title="网络安全期末总结"><img class="relatedPosts_cover lazyload"data-src="/img/post/11.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-11-14</div><div class="relatedPosts_title">网络安全期末总结</div></div></a></div><div class="relatedPosts_item"><a href="/2022/11/14/密码学/" title="密码学期末总结"><img class="relatedPosts_cover lazyload"data-src="/img/post/3.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-11-14</div><div class="relatedPosts_title">密码学期末总结</div></div></a></div><div class="relatedPosts_item"><a href="/2022/11/14/操作系统思维导图/" title="操作系统思维导图"><img class="relatedPosts_cover lazyload"data-src="/img/post/10.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-11-14</div><div class="relatedPosts_title">操作系统思维导图</div></div></a></div><div class="relatedPosts_item"><a href="/2021/07/05/软件工程/" title="软件工程期末总结"><img class="relatedPosts_cover lazyload"data-src="/img/post/10.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-07-05</div><div class="relatedPosts_title">软件工程期末总结</div></div></a></div><div class="relatedPosts_item"><a href="/2021/07/05/软件安全/" title="软件安全期末总结"><img class="relatedPosts_cover lazyload"data-src="/img/post/3.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-07-05</div><div class="relatedPosts_title">软件安全期末总结</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://unpkg.com/valine@1.4.9/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'tekAEc3UtO7aXcLkamh2nCMM-gzGzoHsz',
  appKey: 'qVGeAkqGHCD2n17QxBQW2Q4P',
  placeholder: '建议评论时填写邮箱，可收到回复邮件提醒',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(/img/post/7.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 夏日</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="icp"><a target="_blank" rel="noopener" href="http://www.beian.gov.cn"><img class="icp-icon" src="/img/icp.png"/><span>豫ICP备20013184号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20},"mobile":{"show":false},"log":false,"tagMode":false});</script></body></html><script type="text/javascript" src="/js/crash_cheat.js"></script>